From 7ef6cd016b1a9d933b7a46051a732c231055a7f2 Mon Sep 17 00:00:00 2001
From: Daron Chabot <dchabot@bnl.gov>
Date: Mon, 10 Jun 2013 22:48:44 -0400
Subject: [PATCH 3/4] Omit pmac vme files.

Avoid generating unnecessary binaries, libs, and headers.
---
 Makefile                                      |    2 +-
 pmacApp/Makefile                              |    2 +-
 pmacApp/src/Makefile                          |   42 -
 pmacApp/src/Release.txt                       |   20 -
 pmacApp/src/add_pmac.dbd                      |   26 -
 pmacApp/src/asynUploadFile.c                  |  113 --
 pmacApp/src/devPmacMbx.c                      | 1776 ----------------
 pmacApp/src/devPmacRam.c                      | 1506 --------------
 pmacApp/src/devStatusSoft.c                   |   94 -
 pmacApp/src/drvPmac.c                         | 1953 ------------------
 pmacApp/src/drvPmac.h                         |  130 --
 pmacApp/src/pmacDriver.c                      |  678 -------
 pmacApp/src/pmacDriver.h                      |   15 -
 pmacApp/src/pmacError.c                       |   50 -
 pmacApp/src/pmacError.h                       |   14 -
 pmacApp/src/pmacInclude.dbd                   |    6 -
 pmacApp/src/pmacSerial.c                      |  388 ----
 pmacApp/src/pmacVme.c                         | 1051 ----------
 pmacApp/src/pmacVme.h                         |  176 --
 pmacApp/src/statusDevice.dbd                  |    1 -
 pmacApp/src/statusRecord.c                    |  760 -------
 pmacApp/src/statusRecord.dbd                  |  468 -----
 pmacApp/src/tpmacLIBOBJS                      |    3 -
 pmacApp/src/tsubRecord.c                      |  487 -----
 pmacApp/src/tsubRecord.dbd                    | 2694 -------------------------
 pmacApp/tsubSrc/Makefile                      |   51 -
 pmacApp/tsubSrc/Makefile.Vx                   |   40 -
 pmacApp/tsubSrc/Makefile_3.13                 |    3 -
 pmacApp/tsubSrc/Makefile_3.14                 |   35 -
 pmacApp/tsubSrc/README                        |   37 -
 pmacApp/tsubSrc/tsubA.c                       |  162 --
 pmacApp/tsubSrc/tsubAcc65e.c                  |  137 --
 pmacApp/tsubSrc/tsubBD.c                      |  313 ---
 pmacApp/tsubSrc/tsubBD3.c                     |  367 ----
 pmacApp/tsubSrc/tsubCCD.c                     |  775 -------
 pmacApp/tsubSrc/tsubCCD2009.c                 |  791 --------
 pmacApp/tsubSrc/tsubCCD_bm_no_extern_offset.c |  559 -----
 pmacApp/tsubSrc/tsubCS.c                      |  289 ---
 pmacApp/tsubSrc/tsubCollimator.c              |  112 -
 pmacApp/tsubSrc/tsubDN.c                      |  298 ---
 pmacApp/tsubSrc/tsubHS.c                      |  287 ---
 pmacApp/tsubSrc/tsubInclude.dbd               |   23 -
 pmacApp/tsubSrc/tsubLIBOBJS                   |    2 -
 pmacApp/tsubSrc/tsubMD.c                      |  158 --
 pmacApp/tsubSrc/tsubMI.c                      |  291 ---
 pmacApp/tsubSrc/tsubMO_2mtr_cry2down.c        |  397 ----
 pmacApp/tsubSrc/tsubMO_3mtr_cry2down.c        |  460 -----
 pmacApp/tsubSrc/tsubMO_3mtr_cry2up.c          |  463 -----
 pmacApp/tsubSrc/tsubRecord.c                  |  503 -----
 pmacApp/tsubSrc/tsubRecord.dbd                | 2689 ------------------------
 pmacApp/tsubSrc/tsubSH.c                      |  171 --
 pmacApp/tsubSrc/tsubSeq.c                     |  130 --
 pmacApp/tsubSrc/tsubTB.c                      |  366 ----
 pmacApp/tsubSrc/tsubX.c                       |  160 --
 pmacApp/tsubSrc/tsubXY.c                      |  198 --
 pmacApp/tsubSrc/tsubXYZ.c                     |  238 ---
 pmacApp/tsubSrc/tsubXYZ_frac.c                |  251 ---
 pmacApp/tsubSrc/tsubX_bm_extern_offset.c      |  187 --
 testApp/Db/Makefile                           |    4 -
 testApp/Makefile                              |    7 -
 testApp/src/Makefile                          |   52 -
 testApp/src/testPmacAsynIP.dbd                |    2 -
 testApp/src/testPmacAsynIP.src                |   44 -
 testApp/src/testPmacAsynIPPort.c              |  272 ---
 testApp/src/testPmacAsynIPPort.h              |   17 -
 testApp/src/testPmacAsynIPPortMain.cpp        |   30 -
 66 files changed, 2 insertions(+), 23824 deletions(-)
 delete mode 100644 pmacApp/src/Makefile
 delete mode 100644 pmacApp/src/Release.txt
 delete mode 100644 pmacApp/src/add_pmac.dbd
 delete mode 100644 pmacApp/src/asynUploadFile.c
 delete mode 100644 pmacApp/src/devPmacMbx.c
 delete mode 100644 pmacApp/src/devPmacRam.c
 delete mode 100644 pmacApp/src/devStatusSoft.c
 delete mode 100644 pmacApp/src/drvPmac.c
 delete mode 100644 pmacApp/src/drvPmac.h
 delete mode 100644 pmacApp/src/pmacDriver.c
 delete mode 100644 pmacApp/src/pmacDriver.h
 delete mode 100644 pmacApp/src/pmacError.c
 delete mode 100644 pmacApp/src/pmacError.h
 delete mode 100644 pmacApp/src/pmacInclude.dbd
 delete mode 100644 pmacApp/src/pmacSerial.c
 delete mode 100644 pmacApp/src/pmacVme.c
 delete mode 100644 pmacApp/src/pmacVme.h
 delete mode 100644 pmacApp/src/statusDevice.dbd
 delete mode 100644 pmacApp/src/statusRecord.c
 delete mode 100644 pmacApp/src/statusRecord.dbd
 delete mode 100644 pmacApp/src/tpmacLIBOBJS
 delete mode 100644 pmacApp/src/tsubRecord.c
 delete mode 100644 pmacApp/src/tsubRecord.dbd
 delete mode 100644 pmacApp/tsubSrc/Makefile
 delete mode 100644 pmacApp/tsubSrc/Makefile.Vx
 delete mode 100644 pmacApp/tsubSrc/Makefile_3.13
 delete mode 100644 pmacApp/tsubSrc/Makefile_3.14
 delete mode 100644 pmacApp/tsubSrc/README
 delete mode 100644 pmacApp/tsubSrc/tsubA.c
 delete mode 100644 pmacApp/tsubSrc/tsubAcc65e.c
 delete mode 100644 pmacApp/tsubSrc/tsubBD.c
 delete mode 100644 pmacApp/tsubSrc/tsubBD3.c
 delete mode 100644 pmacApp/tsubSrc/tsubCCD.c
 delete mode 100644 pmacApp/tsubSrc/tsubCCD2009.c
 delete mode 100644 pmacApp/tsubSrc/tsubCCD_bm_no_extern_offset.c
 delete mode 100644 pmacApp/tsubSrc/tsubCS.c
 delete mode 100644 pmacApp/tsubSrc/tsubCollimator.c
 delete mode 100644 pmacApp/tsubSrc/tsubDN.c
 delete mode 100644 pmacApp/tsubSrc/tsubHS.c
 delete mode 100644 pmacApp/tsubSrc/tsubInclude.dbd
 delete mode 100644 pmacApp/tsubSrc/tsubLIBOBJS
 delete mode 100644 pmacApp/tsubSrc/tsubMD.c
 delete mode 100644 pmacApp/tsubSrc/tsubMI.c
 delete mode 100644 pmacApp/tsubSrc/tsubMO_2mtr_cry2down.c
 delete mode 100644 pmacApp/tsubSrc/tsubMO_3mtr_cry2down.c
 delete mode 100644 pmacApp/tsubSrc/tsubMO_3mtr_cry2up.c
 delete mode 100644 pmacApp/tsubSrc/tsubRecord.c
 delete mode 100644 pmacApp/tsubSrc/tsubRecord.dbd
 delete mode 100644 pmacApp/tsubSrc/tsubSH.c
 delete mode 100644 pmacApp/tsubSrc/tsubSeq.c
 delete mode 100644 pmacApp/tsubSrc/tsubTB.c
 delete mode 100644 pmacApp/tsubSrc/tsubX.c
 delete mode 100644 pmacApp/tsubSrc/tsubXY.c
 delete mode 100644 pmacApp/tsubSrc/tsubXYZ.c
 delete mode 100644 pmacApp/tsubSrc/tsubXYZ_frac.c
 delete mode 100644 pmacApp/tsubSrc/tsubX_bm_extern_offset.c
 delete mode 100644 testApp/Db/Makefile
 delete mode 100644 testApp/Makefile
 delete mode 100644 testApp/src/Makefile
 delete mode 100644 testApp/src/testPmacAsynIP.dbd
 delete mode 100644 testApp/src/testPmacAsynIP.src
 delete mode 100644 testApp/src/testPmacAsynIPPort.c
 delete mode 100644 testApp/src/testPmacAsynIPPort.h
 delete mode 100644 testApp/src/testPmacAsynIPPortMain.cpp

diff --git a/Makefile b/Makefile
index 84dc5fe..7931cb3 100644
--- a/Makefile
+++ b/Makefile
@@ -7,7 +7,7 @@ DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *app))
 #DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard iocBoot))
 #DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard iocboot))
 DIRS += pmc
-DIRS += example
+#DIRS += example
 DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard etc))
 # Comment out the following line to disable building of example iocs
 #DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard iocs))
diff --git a/pmacApp/Makefile b/pmacApp/Makefile
index 10e0126..5a73deb 100644
--- a/pmacApp/Makefile
+++ b/pmacApp/Makefile
@@ -3,6 +3,6 @@ include $(TOP)/configure/CONFIG
 DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *src*))
 DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *Src*))
 DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *db*))
-DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *Db*))
+#DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *Db*))
 include $(TOP)/configure/RULES_DIRS
 
diff --git a/pmacApp/src/Makefile b/pmacApp/src/Makefile
deleted file mode 100644
index 923aef7..0000000
--- a/pmacApp/src/Makefile
+++ /dev/null
@@ -1,42 +0,0 @@
-TOP=../..
-
-include $(TOP)/configure/CONFIG
-#----------------------------------------
-#  ADD MACRO DEFINITIONS AFTER THIS LINE
-#==================================================
-USR_CFLAGS += -DSTATUS_RECORD
-# build a support library
-OBJLIB_vxWorks += pmac
-
-# statusRecord.h will be created from statusRecord.dbd
-DBDINC += statusRecord
-
-# tsubRecord.h will be created from tsubRecord.dbd
-DBDINC += tsubRecord
-
-# install <name>.dbd into <top>/dbd
-DBD += add_pmac.dbd
-DBD += pmacInclude.dbd
-DBD += statusDevice.dbd
-
-# The following are compiled and added to the Support library
-OBJLIB_SRCS += devPmacMbx.c
-OBJLIB_SRCS += devPmacRam.c
-OBJLIB_SRCS += drvPmac.c
-OBJLIB_SRCS += pmacVme.c
-OBJLIB_SRCS += pmacSerial.c
-OBJLIB_SRCS += pmacError.c
-OBJLIB_SRCS += pmacDriver.c
-OBJLIB_SRCS += asynUploadFile.c
-OBJLIB_SRCS += statusRecord.c
-OBJLIB_SRCS += devStatusSoft.c
-OBJLIB_SRCS += tsubRecord.c
-
-LIBRARY_vxWorks += pmacIoc
-
-pmacIoc_SRCS += $(OBJLIB_SRCS)
-
-include $(TOP)/configure/RULES
-#----------------------------------------
-#  ADD RULES AFTER THIS LINE
-
diff --git a/pmacApp/src/Release.txt b/pmacApp/src/Release.txt
deleted file mode 100644
index e632346..0000000
--- a/pmacApp/src/Release.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-Release notes:
-
-1) Added reporting of PMAC error messages using an EPICS waveform PV. Before this release PMAC error messages were displayed on IOC console only. One EPICS waveform PV per PMAC card was added to the db file .../pmacApp/Db/pmacDb/AsciiPmac_waveform.db: 
-
-record(waveform, "$(pmac)StrErr") {
-  field(DTYP, "PMAC-VME ASCII")
-  field(INP, "#C$(C) S2 @")
-  field(FTVL, "CHAR")
-  field(NELM, "256")
-}
-
-Files drvPmac.c, drvPmac.h, devPmacMbx.c, add_pmac.dbd were modified to add a waveform record support. 
-
-
-2) File statusRecord.c was modified to include definitions for YES/NO macros since they are no longer defined in EPICS-3.14.11 include files:
-
-#if !defined(YES) || !defined(NO)
-#define YES 1
-#define NO 0
-#endif
diff --git a/pmacApp/src/add_pmac.dbd b/pmacApp/src/add_pmac.dbd
deleted file mode 100644
index 52e881b..0000000
--- a/pmacApp/src/add_pmac.dbd
+++ /dev/null
@@ -1,26 +0,0 @@
-# Local device support:
-device(ai,	 VME_IO, devPmacMbxAi,	  "PMAC-VME ASCII")
-device(ai,	 VME_IO, devPmacRamAi,	  "PMAC-VME DPRAM")
-device(ao,	 VME_IO, devPmacMbxAo,	  "PMAC-VME ASCII")
-device(ao,	 VME_IO, devPmacRamAo,	  "PMAC-VME DPRAM")
-device(bi,	 VME_IO, devPmacMbxBi,	  "PMAC-VME ASCII")
-device(bi,	 VME_IO, devPmacRamBi,	  "PMAC-VME DPRAM")
-device(bo,	 VME_IO, devPmacMbxBo,	  "PMAC-VME ASCII")
-device(bo,	 VME_IO, devPmacRamBo,	  "PMAC-VME DPRAM")
-device(longin,	 VME_IO, devPmacMbxLi,	  "PMAC-VME ASCII")
-device(longin,	 VME_IO, devPmacRamLi,	  "PMAC-VME DPRAM")
-device(longout,	 VME_IO, devPmacMbxLo,	  "PMAC-VME ASCII")
-device(longout,	 VME_IO, devPmacRamLo,	  "PMAC-VME DPRAM")
-device(mbbi,	 VME_IO, devPmacMbxMbbi,  "PMAC-VME ASCII")
-device(mbbi,	 VME_IO, devPmacRamMbbi,  "PMAC-VME DPRAM")
-device(mbbo,	 VME_IO, devPmacMbxMbbo,  "PMAC-VME ASCII")
-device(mbbo,	 VME_IO, devPmacRamMbbo,  "PMAC-VME DPRAM")
-device(status,	 VME_IO, devPmacRamStatus,"PMAC-VME DPRAM")
-device(stringin, VME_IO, devPmacMbxSi,    "PMAC-VME ASCII")
-device(stringout,VME_IO, devPmacMbxSo,    "PMAC-VME ASCII")
-device(waveform, VME_IO, devPmacMbxWf,    "PMAC-VME ASCII")
-#
-# Local driver support:
-driver(drvPmac)
-registrar(pmacAsynConfigRegister)
-registrar(asynUploadFileRegister)
diff --git a/pmacApp/src/asynUploadFile.c b/pmacApp/src/asynUploadFile.c
deleted file mode 100644
index b180596..0000000
--- a/pmacApp/src/asynUploadFile.c
+++ /dev/null
@@ -1,113 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include "asynDriver.h"
-#include "asynOctetSyncIO.h"
-#include <epicsExport.h>
-#include <iocsh.h>
-
-#define TIMEOUT 6.0
-
-int asynUploadFile( char * filename, char * asynPort, char * out_term, char * inp_term )
-{
-    FILE * fd;
-    asynStatus status;
-    asynUser * pasynUser;
-    int linenum=0;
-    char readbuf[255], writebuf[255];
-
-    fd = fopen( filename, "r" );
-    if (fd == NULL)
-    {
-        fprintf( stderr, "asynUploadFile: Cannot open file: %s\n", filename );
-        return ERROR;
-    }
- 
-    status = pasynOctetSyncIO->connect( asynPort, 0, &pasynUser, NULL);
-    if (status) {
-        printf( "asynUploadFile: unable to connect to asynPort %s\n", asynPort );
-        fclose( fd );
-        return ERROR;
-    }
-
-    status = pasynOctetSyncIO->setInputEos( pasynUser, inp_term, strlen(inp_term) );
-    if (status) {
-        printf( "pmacDrvConfig: unable to set input EOS on %s: %s\n", 
-                asynPort, pasynUser->errorMessage);
-        pasynOctetSyncIO->disconnect(pasynUser);
-        fclose( fd );
-        return ERROR;
-    }
-
-    status = pasynOctetSyncIO->setOutputEos( pasynUser, out_term, strlen(out_term) );
-    if (status) {
-        printf( "pmacDrvConfig: unable to set output EOS on %s: %s\n", 
-                asynPort, pasynUser->errorMessage);
-        pasynOctetSyncIO->disconnect(pasynUser);
-        fclose( fd );
-        return ERROR;
-    }
-
-    while ( fgets( writebuf, sizeof(writebuf), fd ) != NULL )
-    {
-        const double timeout=5.0;
-        size_t nwrite, nread;
-        int eomReason;
-        size_t ls = strlen(writebuf);
-        linenum++;
-
-        if ( writebuf[ls-1] == '\n' ) ls--;
-
-        status = pasynOctetSyncIO->writeRead( pasynUser,
-                                              writebuf, ls,
-                                              readbuf, sizeof(readbuf),
-                                              timeout,
-                                              &nwrite, &nread, &eomReason );
-
-        if (status)
-        {
-            asynPrint( pasynUser,
-                       ASYN_TRACE_ERROR,
-                       "Error writing line %d to asyn port %s: command %s\n Status=%d, Error=%s\n",
-                       linenum, asynPort, writebuf, status, pasynUser->errorMessage);
-            fclose( fd );
-            pasynOctetSyncIO->disconnect( pasynUser );
-            return ERROR;
-        }
-
-        if ( nread != 0 )
-        {
-            readbuf[nread]=0;
-            printf( "Received non-null response writing line %d to asyn port %s: \nCommand: %s\nResponse: %s\n",
-                    linenum, asynPort, writebuf, readbuf );
-        }
-    }
-
-    fclose( fd );
-    pasynOctetSyncIO->disconnect( pasynUser );
-    return OK;
-}
-
-static const iocshArg asynUploadFileArg0 = {"File name", iocshArgString};
-static const iocshArg asynUploadFileArg1 = {"Asyn port", iocshArgString};
-static const iocshArg asynUploadFileArg2 = {"Output terminator", iocshArgString};
-static const iocshArg asynUploadFileArg3 = {"Input terminator",  iocshArgString};
-static const iocshArg * const asynUploadFileArgs[] = {&asynUploadFileArg0,
-                                                      &asynUploadFileArg1,
-                                                      &asynUploadFileArg2,
-                                                      &asynUploadFileArg3};
- 
-static const iocshFuncDef asynUploadFileDef = {"asynUploadFile", 4, asynUploadFileArgs};
-
-static void asynUploadFileCallFunc(const iocshArgBuf *args)
-{
-    asynUploadFile(args[0].sval, args[1].sval, args[2].sval, args[3].sval );
-}
-
-
-static void asynUploadFileRegister(void)
-{
-    iocshRegister(&asynUploadFileDef,  asynUploadFileCallFunc);
-}
-
-epicsExportRegistrar(asynUploadFileRegister);
-
diff --git a/pmacApp/src/devPmacMbx.c b/pmacApp/src/devPmacMbx.c
deleted file mode 100644
index db8f152..0000000
--- a/pmacApp/src/devPmacMbx.c
+++ /dev/null
@@ -1,1776 +0,0 @@
-/* devPmacMbx.c -  EPICS Device Support for PMAC-VME Mailbox */
-
-/*
- * Author:      Thomas A. Coleman
- * Date:        97/05/06
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
-
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
-
-Argonne National Laboratory (ANL), with facilities in the States of
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods.
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.
-
-*****************************************************************
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- * .02  7-24-96       wfl     ifdef'ed out use of status record
- * .03  7-03-97       wfl     ifdef'ed out use of load record
- * 2.1  2-27-04       oam     updated for epics 3.14.5
- */
-
-/*
- * DESCRIPTION:
- * ------------
- * This module implements EPICS Device Support for PMAC-VME Mailbox.
- *
- */
-
-/*
- * INCLUDES
- */
-
-/* VxWorks Includes */
-
-#include	<vxWorks.h>
-#include 	<stdlib.h>	/* Sergey */
-#include	<types.h>
-#include	<stdioLib.h>
-#include	<string.h>
-#define __PROTOTYPE_5_0		/* Sergey */
-#include	<logLib.h>	/* Sergey */
-
-/* EPICS Includes */
-
-#include	<alarm.h>
-#include	<cvtTable.h>
-#include	<dbAccess.h>
-#include	<dbDefs.h>
-#include        <recSup.h>
-#include	<devSup.h>
-#include	<dbScan.h>
-#include	<link.h>
-#include	<module_types.h>
-#include	<callback.h>
-#include	<cantProceed.h>
-
-#include	<aiRecord.h>
-#include	<biRecord.h>
-#include	<longinRecord.h>
-#include	<mbbiRecord.h>
-#ifdef STATUS_RECORD
-#include	<statusRecord.h>
-#endif
-#include	<aoRecord.h>
-#include	<boRecord.h>
-#include	<longoutRecord.h>
-#include	<mbboRecord.h>
-#include	<stringinRecord.h>
-#include	<stringoutRecord.h>
-#include	<waveformRecord.h>
-#ifdef LOAD_RECORD
-#include	<loadRecord.h>
-#endif
-
-/* local includes */
-
-#include	<drvPmac.h>
-#include	<pmacError.h>
-#include "recGbl.h"
-#include "epicsExport.h"
-/*
- * DEFINES
- */
-
-#define PMAC_DIAGNOSTICS TRUE
-#define PMAC_PRIVATE FALSE
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-#if PMAC_DIAGNOSTICS
-#define PMAC_MESSAGE	logMsg
-#define PMAC_DEBUG(level,code)       { if (devPmacMbxDebug >= (level)) { code } }
-#define PMAC_TRACE(level,code)       { if ( (pRec->tpro >= (level)) || (devPmacMbxDebug == (level)) ) { code } }
-#else
-#define PMAC_DEBUG(level,code)      ;
-#define PMAC_TRACE(level,code)      ;
-#endif
-
-#define NO_ERR_STATUS   (-1)
-
-/*
- * TYPEDEFS
- */
-typedef struct  /* PMAC_DSET_AI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-	DEVSUPFUN	special_linconv;
-} PMAC_DSET_AI;
-
-typedef struct  /* PMAC_DSET_AO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-	DEVSUPFUN	special_linconv;
-} PMAC_DSET_AO;
-
-typedef struct  /* PMAC_DSET_BI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_BI;
-
-typedef struct  /* PMAC_DSET_BO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_BO;
-
-typedef struct  /* PMAC_DSET_LI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_LI;
-
-typedef struct  /* PMAC_DSET_LO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_LO;
-
-typedef struct  /* PMAC_DSET_MBBI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_MBBI;
-
-typedef struct  /* PMAC_DSET_MBBO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_MBBO;
-
-#ifdef STATUS_RECORD
-typedef struct  /* PMAC_DSET_STATUS */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_STATUS;
-#endif
-
-typedef struct  /* PMAC_DSET_SI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_SI;
-
-typedef struct  /* PMAC_DSET_SO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_SO;
-
-typedef struct  /* PMAC_DSET_WF */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_WF;
-
-#ifdef LOAD_RECORD
-typedef struct  /* PMAC_DSET_LOAD */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	proc;
-} PMAC_DSET_LOAD;
-#endif
-
-
-typedef struct  /* PMAC_MBX_DPVT */
-{
-	PMAC_MBX_IO	MbxIo;
-} PMAC_MBX_DPVT;
-
-/*
- * FORWARD DECLARATIONS
- */
-
-LOCAL long devPmacMbx_init();
-
-LOCAL long devPmacMbxAi_init();
-LOCAL long devPmacMbxAi_read();
-
-LOCAL long devPmacMbxAo_init();
-LOCAL long devPmacMbxAo_write();
-
-LOCAL long devPmacMbxBi_init();
-LOCAL long devPmacMbxBi_read();
-
-LOCAL long devPmacMbxBo_init();
-LOCAL long devPmacMbxBo_write();
-
-LOCAL long devPmacMbxLi_init();
-LOCAL long devPmacMbxLi_read();
-
-LOCAL long devPmacMbxLo_init();
-LOCAL long devPmacMbxLo_write();
-
-LOCAL long devPmacMbxMbbi_init();
-LOCAL long devPmacMbxMbbi_read();
-
-LOCAL long devPmacMbxMbbo_init();
-LOCAL long devPmacMbxMbbo_write();
-
-#ifdef STATUS_RECORD
-LOCAL long devPmacMbxStatus_init();
-LOCAL long devPmacMbxStatus_read();
-#endif
-
-LOCAL long devPmacMbxSi_init();
-LOCAL long devPmacMbxSi_read();
-
-LOCAL long devPmacMbxSo_init();
-LOCAL long devPmacMbxSo_write();
-
-LOCAL long devPmacMbxWf_init();
-LOCAL long devPmacMbxWf_write();
-
-#ifdef LOAD_RECORD
-LOCAL long devPmacMbxLoad_init();
-LOCAL long devPmacMbxLoad_proc();
-#endif
-
-void drvPmacMbxScan (PMAC_MBX_IO * pMbxIo);
-void drvPmacFldScan (PMAC_MBX_IO * pMbxIo);
-
-LOCAL void devPmacMbxCallback (CALLBACK * pCallback);
-
-/*
- * GLOBALS
- */
-
-char * devPmacMbxVersion = "@(#) devPmacMbx.c 2.1 2004/02/27";
-
-#if PMAC_DIAGNOSTICS
-volatile int devPmacMbxDebug = 0;
-#endif
-
-PMAC_DSET_AI devPmacMbxAi =
-{
-	6,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxAi_init,
-	NULL,
-	devPmacMbxAi_read,
-	NULL
-};
-
-PMAC_DSET_AO devPmacMbxAo =
-{
-	6,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxAo_init,
-	NULL,
-	devPmacMbxAo_write,
-	NULL
-};
-
-PMAC_DSET_BI devPmacMbxBi =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxBi_init,
-	NULL,
-	devPmacMbxBi_read
-};
-
-PMAC_DSET_BO devPmacMbxBo =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxBo_init,
-	NULL,
-	devPmacMbxBo_write};
-
-PMAC_DSET_LI devPmacMbxLi =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxLi_init,
-	NULL,
-	devPmacMbxLi_read
-};
-
-PMAC_DSET_LO devPmacMbxLo =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxLo_init,
-	NULL,
-	devPmacMbxLo_write
-};
-
-PMAC_DSET_MBBI devPmacMbxMbbi =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxMbbi_init,
-	NULL,
-	devPmacMbxMbbi_read
-};
-
-PMAC_DSET_MBBO devPmacMbxMbbo =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxMbbo_init,
-	NULL,
-	devPmacMbxMbbo_write
-};
-
-#ifdef STATUS_RECORD
-PMAC_DSET_STATUS devPmacMbxStatus =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxStatus_init,
-	NULL,
-	devPmacMbxStatus_read
-};
-epicsExportAddress(dset,devPmacMbxStatus);
-#endif
-
-PMAC_DSET_SI devPmacMbxSi =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxSi_init,
-	NULL,
-	devPmacMbxSi_read
-};
-
-PMAC_DSET_SO devPmacMbxSo =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxSo_init,
-	NULL,
-	devPmacMbxSo_write
-};
-
-PMAC_DSET_WF devPmacMbxWf =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxWf_init,
-	NULL,
-	devPmacMbxWf_write
-};
-
-#ifdef LOAD_RECORD
-PMAC_DSET_LOAD devPmacMbxLoad =
-{
-	5,
-	NULL,
-	devPmacMbx_init,
-	devPmacMbxLoad_init,
-	NULL,
-	devPmacMbxLoad_proc
-};
-epicsExportAddress(dset,devPmacMbxLoad);
-#endif
-epicsExportAddress(dset,devPmacMbxAi);
-epicsExportAddress(dset,devPmacMbxAo);
-epicsExportAddress(dset,devPmacMbxBi);
-epicsExportAddress(dset,devPmacMbxBo);
-epicsExportAddress(dset,devPmacMbxLi);
-epicsExportAddress(dset,devPmacMbxLo);
-epicsExportAddress(dset,devPmacMbxMbbi);
-epicsExportAddress(dset,devPmacMbxMbbo);
-epicsExportAddress(dset,devPmacMbxSi);
-epicsExportAddress(dset,devPmacMbxSo);
-epicsExportAddress(dset,devPmacMbxWf);
-
-
-/*
- * LOCALS
- */
-
-/*******************************************************************************
- *
- * devPmacMbx_init - EPICS device support init function
- *
- */
-LOCAL long devPmacMbx_init
-(
-	int	after
-)
-{
-/*	char *	MyName = "devPmacMbx_init"; */
-	long		status = 0;
-
-	if (after == 1)
-	{
-		status = drvPmacStartup ();
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * devPmacMbxDpvtInit - EPICS PMAC_MBX_DPVT init
- *
- */
-PMAC_MBX_DPVT * devPmacMbxDpvtInit
-(
-	struct dbCommon *	pRec,
-	int			card
-)
-{
-/*	char *	MyName = "devPmacMbxDpvtInit"; */
-	PMAC_MBX_DPVT *	pDpvt;
-
-	pDpvt = (PMAC_MBX_DPVT *) malloc (sizeof(PMAC_MBX_DPVT));
-
-	pDpvt->MbxIo.pRec = pRec;
-	pDpvt->MbxIo.card = card;
-	pDpvt->MbxIo.terminator = 0;
-	pDpvt->MbxIo.command[0] = (char) NULL;
-	pDpvt->MbxIo.response[0] = (char) NULL;
-
-	callbackSetCallback (devPmacMbxCallback, &pDpvt->MbxIo.callback);
-	callbackSetPriority (pRec->prio, &pDpvt->MbxIo.callback);
-	callbackSetUser ( (void *) pRec, &pDpvt->MbxIo.callback);
-
-	return (pDpvt);
-}
-
-/*******************************************************************************
- *
- * devPmacMbxAi_init - EPICS PMAC device support ai init
- *
- */
-LOCAL long devPmacMbxAi_init
-(
-	struct aiRecord	*pRec
-)
-{
-	char *	MyName = "devPmacMbxAi_init";
-	/* long status; */
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacMbxAi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacMbxBi_init - EPICS PMAC device support bi init
- *
- */
-LOCAL long devPmacMbxBi_init
-(
-	struct biRecord	*pRec
-)
-{
-	char *	MyName = "devPmacMbxBi_init";
-	/* long status; */
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	 default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxBi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacMbxLi_init - EPICS PMAC device support longin init
- *
- */
-LOCAL long devPmacMbxLi_init
-(
-	struct longinRecord	*pRec
-)
-{
-	char *	MyName = "devPmacMbxLi_init";
-	/* long status; */
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxLi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacMbxMbbi_init - EPICS PMAC device support mbbi init
- *
- */
-LOCAL long devPmacMbxMbbi_init
-(
-	struct mbbiRecord	*pRec
-)
-{
-	char *	MyName = "devPmacMbxMbbi_init";
-	/* long status; */
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxMbbi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	 return(0);
-}
-
-#ifdef STATUS_RECORD
-/*******************************************************************************
- *
- * devPmacMbxStatus_init - EPICS PMAC device support status init
- *
- */
-LOCAL long devPmacMbxStatus_init
-(
-	struct statusRecord	*pRec
-)
-{
-	char *	MyName = "devPmacMbxStatus_init";
-	/* long status; */
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-   			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxStatus_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-#endif	/* STATUS_RECORD */
-
-/*******************************************************************************
- *
- * devPmacMbxAo_init - EPICS PMAC device support ao init
- *
- */
-LOCAL long devPmacMbxAo_init
-(
-	struct aoRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxAo_init";
-	/* long status=0; */
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxAo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return (0);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxBo_init - EPICS PMAC device support bo init
- *
- */
-LOCAL long devPmacMbxBo_init
-(
-	struct boRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxBo_init";
-	/* long	status = 0; */
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxBo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-    return (0);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxLo_init - EPICS PMAC device support longout init
- *
- */
-LOCAL long devPmacMbxLo_init
-(
-	struct longoutRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxLo_init";
-	/* long	status = 0; */
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxLo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return (0);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxMbbo_init - EPICS PMAC device support mbbo init
- *
- */
-LOCAL long devPmacMbxMbbo_init
-(
-	struct mbboRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxMbbo_init";
-	long	status = 0;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d parm %s\n", MyName,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxMbbo_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return (status);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxSi_init - EPICS PMAC device support stringin init
- *
- */
-LOCAL long devPmacMbxSi_init
-(
-	struct stringinRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxSi_init";
-	long status = 0;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: name %s card %d parm %s\n", MyName, pRec->name,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxSi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return (status);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxSo_init - EPICS PMAC device support stringout init
- *
- */
-LOCAL long devPmacMbxSo_init
-(
-	struct stringoutRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxSo_init";
-	long status = 0;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: name %s card %d parm %s\n", MyName, pRec->name,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec, (int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxSo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return (status);
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxWf_init - EPICS PMAC device support waveform init
- *
- */
-LOCAL long devPmacMbxWf_init
-(
-	struct waveformRecord *pRec,
-	int pass
-)
-{
-	char *	MyName = "devPmacMbxWf_init";
-	long status = 0;
-
-	if (pass==0){
-            if (pRec->nelm <= 0)
-        	pRec->nelm = 1;
-            if (pRec->ftvl > DBF_ENUM) pRec->ftvl = DBF_UCHAR;
-            pRec->bptr = callocMustSucceed(pRec->nelm, dbValueSize(pRec->ftvl), "waveform calloc failed");
-	    pRec->val = pRec->bptr;
-            if (pRec->nelm == 1) {
-        	pRec->nord = 1;
-            } else {
-        	pRec->nord = 0;
-            }
-            return 0;
-	}
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: name %s card %d parm %s\n", MyName, pRec->name,
-				pRec->inp.value.vmeio.card, pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec, (int) pRec->inp.value.vmeio.card );
-		/* signal 2 is for PMAC error messages; tell PMAC driver where to report error message */
-		if (pRec->inp.value.vmeio.signal == 2) {drvPmacStrErr (pRec);}
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec, "devPmacMbxWf_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-	
- 
-	return (status);
-
-}
-
-#ifdef LOAD_RECORD
-/*******************************************************************************
- *
- * devPmacMbxLoad_init - EPICS PMAC device support load init
- *
- */
-LOCAL long devPmacMbxLoad_init
-(
-	struct loadRecord *pRec
-)
-{
-	char *	MyName = "devPmacMbxLoad_init";
-	long status = 0;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: name %s card %d parm %s\n", MyName, pRec->name,
-				pRec->out.value.vmeio.card, pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pRec->dpvt = (void *) devPmacMbxDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-			"devPmacMbxLoad_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return (status);
-
-}
-#endif	/* LOAD_RECORD */
-
-/*******************************************************************************
- *
- * devPmacMbxAi_read - EPICS PMAC device support ai read
- *
- */
-static long devPmacMbxAi_read
-(
-	struct aiRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxAi_read";
-	/* long	status; */
-
-	double	valD;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-			PMAC_MESSAGE ("%s: TPRO=%d\n", MyName, pRec->tpro,0,0,0,0);
-		)
-
-		if (pRec->inp.value.vmeio.signal == 0xfff) {
-		   /* this is for the ACC59E ADC conversion */
-		   int	valI;
-		   sscanf (pMbxIo->response, "%d", &valI);
-		   valD =  (valI & 0x800) ? (double)(0xFFF-valI) * pRec->egul / 0x7FF : (double)valI * pRec->eguf / 0x7ff;
-		}else{
-		   sscanf (pMbxIo->response, "%lf", &valD);
-
-		   /* Adjust Slope And Offset */
-		   if (pRec->aslo != 0.0)
-		   {
-			valD *= pRec->aslo;
-		   }
-		   if (pRec->aoff != 0.0)
-		   {
-			valD += pRec->aoff;
-		   }
-		}
-
-		/* pRec->linr Conversion Ignored */
-
-		/* Apply Smoothing Algorithm */
-		if (pRec->smoo != 0.0)
-		{
-	    		if (pRec->init == TRUE) pRec->val = valD;	/* initial condition */
-	    		pRec->val = valD * (1.00 - pRec->smoo) + (pRec->val * pRec->smoo);
-		}
-		else
-		{
-	    		pRec->val = valD;
-		}
-
-		pRec->udf = FALSE;
-		return (2);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->inp.value.vmeio.parm);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-			PMAC_MESSAGE ("%s: TPRO=%d\n", MyName, pRec->tpro,0,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxBi_read - EPICS PMAC device support bi read
- *
- */
-LOCAL long devPmacMbxBi_read
-(
-	struct biRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxBi_read";
-	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		sscanf (pMbxIo->response, "%ld", &valL);
-
-		pRec->rval = (unsigned long) valL;
-		pRec->udf = FALSE;
-
-		return (0);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->inp.value.vmeio.parm);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxLi_read - EPICS PMAC device support longin read
- *
- */
-LOCAL long devPmacMbxLi_read
-(
-	struct longinRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxLi_read";
-    	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		sscanf (pMbxIo->response, "%ld", &valL);
-
-		pRec->val = valL;
-		pRec->udf = FALSE;
-
-		return (0);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->inp.value.vmeio.parm);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxMbbi_read - EPICS PMAC device support mbbi read
- *
- */
-LOCAL long devPmacMbxMbbi_read
-(
-	struct mbbiRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxMbbi_read";
-    	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		sscanf (pMbxIo->response, "%ld", &valL);
-
-		pRec->rval = (unsigned long) valL;
-		pRec->udf = FALSE;
-
-		return (0);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->inp.value.vmeio.parm);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-#ifdef STATUS_RECORD
-/*******************************************************************************
- *
- * devPmacMbxStatus_read - EPICS PMAC device support status read
- *
- */
-LOCAL long devPmacMbxStatus_read
-(
-	struct statusRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxStatus_read";
-    	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		sscanf (pMbxIo->response, "%ld", &valL);
-
-		pRec->val = valL;
-		pRec->udf = FALSE;
-
-		return (0);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->inp.value.vmeio.parm);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-#endif	/* STATUS_RECORD */
-
-/*******************************************************************************
- *
- * devPmacMbxAo_write - EPICS PMAC device support ao write
- *
- */
-LOCAL long devPmacMbxAo_write
-(
-	struct aoRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxAo_write";
-	/* long status; */
-
-	double	valD;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		return (0);
-	}
-
-	else
-	{
-
-		/* Output Value */
-		valD = (double) pRec->oval;
-
-		if(pRec->out.value.vmeio.signal == 0xfff) {
-			/* this is for the ACC59E DAC conversion */
-		  	valD = (double)0xfff * (pRec->oval - pRec->egul) / (pRec->eguf - pRec->egul) + 0.5;
-		
-			sprintf (pMbxIo->command, "%s%d", pRec->out.value.vmeio.parm, (int)valD);
-		} else {
-
-			/* Adjust Slope And Offset */
-			if (pRec->aoff != 0.0)
-			{
-				valD -= (double) pRec->aoff;
-			}
-			if (pRec->aslo != 0.0)
-			{
-				valD /= (double) pRec->aslo;
-			}
-
-			/* pRec->linr Conversion Ignored */
-
-			sprintf (pMbxIo->command, "%s%f", pRec->out.value.vmeio.parm, valD);
-		}
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxBo_write - EPICS PMAC device support bo write
- *
- */
-LOCAL long devPmacMbxBo_write
-(
-	struct boRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxBo_write";
-	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		return (0);
-	}
-
-	else
-	{
-
-		valL = (long) pRec->val;
-
-		sprintf (pMbxIo->command,"%s%ld", pRec->out.value.vmeio.parm, valL);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-}
-
-/*******************************************************************************
- *
- * devPmacMbxLo_write - EPICS PMAC device support longout write
- *
- */
-LOCAL long devPmacMbxLo_write
-(
-	struct longoutRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxLo_write";
-	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		return (0);
-	}
-
-	else
-	{
-
-		valL = (long) pRec->val;
-
-		sprintf (pMbxIo->command,"%s%ld", pRec->out.value.vmeio.parm, valL);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxMbbo_write - EPICS PMAC device support mbbo write
- *
- */
-LOCAL long devPmacMbxMbbo_write
-(
-	struct mbboRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxMbbo_write";
-	/* long status; */
-
-	long valL;
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		return (0);
-	}
-
-	else
-	{
-
-		valL = (long) pRec->rval;
-
-		sprintf (pMbxIo->command,"%s%ld", pRec->out.value.vmeio.parm, valL);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxSi_read - EPICS PMAC device support stringin read
- *
- */
-LOCAL long devPmacMbxSi_read
-(
-	struct stringinRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxSi_read";
-	/* long status; */
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		pRec->val[39] = '\0';
-		strncpy (pRec->val, pMbxIo->response, 39);
-
-		pRec->udf = FALSE;
-		return (0);
-	}
-
-	else
-	{
-
-		switch (pRec->inp.value.vmeio.signal)
-		{
-		case (1):
-			sprintf (pMbxIo->command,"%s%s", pRec->inp.value.vmeio.parm, pRec->val);
-			break;
-		case (0):
-		default:
-			sprintf (pMbxIo->command,"%s", pRec->inp.value.vmeio.parm);
-			break;
-		}
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacMbxScan (pMbxIo);
-
-		return (0);
-	}
-
-}
-
-/*******************************************************************************
- *
- * devPmacMbxSo_write - EPICS PMAC device support stringout write
- *
- */
-LOCAL long devPmacMbxSo_write
-(
-	struct stringoutRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxSo_write";
-	/* long status; */
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s response [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-		switch (pRec->out.value.vmeio.signal)
-		{
-		case (1):
-			pRec->val[39] = '\0';
-			strncpy (pRec->val, pMbxIo->response, 39);
-			break;
-		case (0):
-		default:
-			break;
-		}
-
-	} else {
-
-
-	  /*MRP Commeted this change out because it broke I06 hexapod IOC databases. 9 March 2011*/
-	  /*
-		switch (pRec->out.value.vmeio.signal)
-		{
-		case (1):
-			pRec->pact = TRUE;
-			sprintf (pMbxIo->command,"%s%s", pRec->out.value.vmeio.parm, pRec->val);
-
-			PMAC_TRACE
-			(	2,
-				PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-			)
-
-			drvPmacMbxScan (pMbxIo);
-			break;
-		default:
-			PMAC_MESSAGE ("%s: %s s[%d] not supported\n", MyName, pRec->name, pRec->out.value.vmeio.signal,0,0,0);
-			break;
-		}
-
-	  */
-
-	  /*This is the old code from tpmac 3-5dls9.*/
-	  sprintf (pMbxIo->command,"%s%s", pRec->out.value.vmeio.parm, pRec->val);
-	  
-	  PMAC_TRACE
-	  (       2,
-		    PMAC_MESSAGE ("%s: %s command [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-	  )
-	    
-	    drvPmacMbxScan (pMbxIo);
-	  
-	  pRec->pact = TRUE;
-	  
-
-	}
-
-		return (0);
-}
-
-/*******************************************************************************
- *
- * devPmacMbxWf_write - EPICS PMAC device support stringout write
- *
- */
-LOCAL long devPmacMbxWf_write ( struct waveformRecord *pRec)
-{
-	return (0); /* Nothing to do, data are written in the drvPmacMbxTask (), drvPmac.c */
-}
-
-#ifdef LOAD_RECORD
-/*******************************************************************************
- *
- * devPmacMbxLoad_proc - EPICS PMAC device support stringout write
- *
- */
-LOCAL long devPmacMbxLoad_proc
-(
-	struct loadRecord	*pRec
-)
-{
- 	char *	MyName = "devPmacMbxLoad_proc";
-	/* long status;	*/
-
-	PMAC_MBX_DPVT *	pDpvt = (PMAC_MBX_DPVT *) pRec->dpvt;
-	PMAC_MBX_IO *	pMbxIo = &pDpvt->MbxIo;
-
-	if (pRec->pact)
-	{
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s message [%s]\n", MyName, pRec->name, pMbxIo->errmsg,0,0,0);
-		)
-
-		pRec->val = pMbxIo->terminator;
-		sprintf (pRec->msg, "%s", pMbxIo->errmsg);
-
-		return (0);
-	}
-
-	else
-	{
-
-		sprintf (pMbxIo->command, "%s", pRec->dnv);
-		sprintf (pMbxIo->response, "%s", pRec->upv);
-
-		PMAC_TRACE
-		(	2,
-			PMAC_MESSAGE ("%s: %s download [%s]\n", MyName, pRec->name, pMbxIo->command,0,0,0);
-			PMAC_MESSAGE ("%s: %s upload [%s]\n", MyName, pRec->name, pMbxIo->response,0,0,0);
-		)
-
-		pRec->pact = TRUE;
-		drvPmacFldScan (pMbxIo);
-
-
- 		return (0);
-	}
-
-}
-#endif	/* LOAD_RECORD */
-
-/*******************************************************************************
- *
- * devPmacMbxCallback - EPICS device support Callback
- *
- */
-LOCAL void devPmacMbxCallback
-(
-	CALLBACK *	pCallback
-)
-{
-	char *	MyName = "devPmacMbxCallback";
-	/* long	status = 0; */
-
-	struct dbCommon *	pRec;
-	struct rset *		pRset;
-
-	callbackGetUser (pRec, pCallback);
-
-	pRset = pRec->rset;
-
-	PMAC_TRACE
-	(	2,
-		PMAC_MESSAGE ("%s: CALLBACK [%s].\n", MyName, pRec->name,0,0,0,0);
-	)
-/*OAM*/
-	logMsg("%s: pRec = 0x%x, pRset = 0x%x \n", (int)MyName, (int)pRec,(int)pRset,0,0,0);
-        dbScanLock (pRec);
-	(*(pRset->process))(pRec);
-        dbScanUnlock (pRec);
-
-	return;
-}
-
diff --git a/pmacApp/src/devPmacRam.c b/pmacApp/src/devPmacRam.c
deleted file mode 100644
index 8a503c3..0000000
--- a/pmacApp/src/devPmacRam.c
+++ /dev/null
@@ -1,1506 +0,0 @@
-/* devPmacRam.c -  EPICS Device Support for PMAC-VME */
-
-/*
- * Author:      Thomas A. Coleman
- * Date:        97/05/06
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- *
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- * .01  2-27-96       tac     initial
- * .02  7-24-96       wfl     ifdef'ed out use of status record
- * 2.1  2-27-04       oam     updated for epics 3.14.5
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
-
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
-
-Argonne National Laboratory (ANL), with facilities in the States of
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods.
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.
-
-*****************************************************************
-*/
-
-
-/*
- * DESCRIPTION:
- * ------------
- * This module implements EPICS Device Support for PMAC-VME DPRAM.
- *
- */
-
-/*
- * INCLUDES
- */
-
-/* VxWorks Includes */
-
-#include	<vxWorks.h>
-#include 	<stdlib.h>	/* Sergey */
-#include	<types.h>
-#include	<stdioLib.h>
-#include	<string.h>
-#define __PROTOTYPE_5_0		/* Sergey */
-#include	<logLib.h>	/* Sergey */
-
-/* EPICS Includes */
-
-#include	<alarm.h>
-#include	<cvtTable.h>
-#include	<dbAccess.h>
-#include	<dbDefs.h>
-#include        <recSup.h>
-#include	<devSup.h>
-#include	<dbAccess.h>
-#include	<dbScan.h>
-#include	<link.h>
-#include	<module_types.h>
-#include	<callback.h>
-
-#include	<aiRecord.h>
-#include	<aoRecord.h>
-#include	<biRecord.h>
-#include	<boRecord.h>
-#include	<eventRecord.h>
-#include	<longinRecord.h>
-#include	<longoutRecord.h>
-#include	<mbbiRecord.h>
-#include	<mbboRecord.h>
-#include	<errlog.h>
-
-/* local includes */
-
-#ifdef STATUS_RECORD
-#include	<statusRecord.h>
-#endif
-
-#include	<drvPmac.h>
-#include "recGbl.h"
-#include "epicsExport.h"
-/*
- * DEFINES
- */
-
-#define PMAC_DIAGNOSTICS TRUE
-#define PMAC_PRIVATE FALSE
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-#if PMAC_DIAGNOSTICS
-#define PMAC_MESSAGE	logMsg
-#define PMAC_DEBUG(level,code)       { if (devPmacRamDebug >= (level)) { code } }
-#define PMAC_TRACE(level,code)       { if ( (pRec->tpro >= (level)) || (devPmacRamDebug == (level)) ) { code } }
-#else
-#define PMAC_DEBUG(level,code)      ;
-#define PMAC_TRACE(level,code)      ;
-#endif
-
-#define NO_ERR_STATUS   (-1)
-
-/*
- * TYPEDEFS
- */
-typedef struct  /* PMAC_DSET_AI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-	DEVSUPFUN	special_linconv;
-} PMAC_DSET_AI;
-
-typedef struct  /* PMAC_DSET_AO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-	DEVSUPFUN	special_linconv;
-} PMAC_DSET_AO;
-
-typedef struct  /* PMAC_DSET_BI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_BI;
-
-typedef struct  /* PMAC_DSET_BO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_BO;
-
-typedef struct  /* PMAC_DSET_EVENT */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_EVENT;
-
-typedef struct  /* PMAC_DSET_LI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_LI;
-
-typedef struct  /* PMAC_DSET_LO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_LO;
-
-typedef struct  /* PMAC_DSET_MBBI */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_MBBI;
-
-typedef struct  /* PMAC_DSET_MBBO */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	write;
-} PMAC_DSET_MBBO;
-
-#ifdef STATUS_RECORD
-typedef struct  /* PMAC_DSET_STATUS */
-{
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read;
-} PMAC_DSET_STATUS;
-#endif
-
-typedef struct  /* PMAC_RAM_DATA */
-{
-	long		ramLong;
-	double		ramDouble;
-} PMAC_RAM_DATA;
-
-typedef struct  /* PMAC_RAM_DPVT */
-{
-	int		card;
-	PMAC_RAM_DATA	dpramData;
-	PMAC_RAM_DATA	dpramDataPrev;
-	PMAC_RAM_IO	* pRamIo;
-	IOSCANPVT	ioscanpvt;
-	CALLBACK	callback;
-	struct dbCommon *pRecord;     /* pointer to the record that owns this private */
-	void          (*process)();   /* callback to perform forward db processing */
-	int           processPri;     /* process callback's priority */
-} PMAC_RAM_DPVT;
-
-/*
- * FORWARD DECLARATIONS
- */
-
-LOCAL long devPmacRam_init();
-
-LOCAL long devPmacRamAi_init();
-LOCAL long devPmacRamAi_read();
-LOCAL long devPmacRamAi_get_ioint_info();
-
-LOCAL long devPmacRamAo_init();
-LOCAL long devPmacRamAo_write();
-
-LOCAL long devPmacRamBi_init();
-LOCAL long devPmacRamBi_read();
-LOCAL long devPmacRamBi_get_ioint_info();
-
-LOCAL long devPmacRamBo_init();
-LOCAL long devPmacRamBo_write();
-
-LOCAL long devPmacRamEvent_init();
-LOCAL long devPmacRamEvent_read();
-LOCAL long devPmacRamEvent_get_ioint_info();
-
-LOCAL long devPmacRamLi_init();
-LOCAL long devPmacRamLi_read();
-LOCAL long devPmacRamLi_get_ioint_info();
-
-LOCAL long devPmacRamLo_init();
-LOCAL long devPmacRamLo_write();
-
-LOCAL long devPmacRamMbbi_init();
-LOCAL long devPmacRamMbbi_read();
-LOCAL long devPmacRamMbbi_get_ioint_info();
-
-LOCAL long devPmacRamMbbo_init();
-LOCAL long devPmacRamMbbo_write();
-
-LOCAL long devPmacRamStatus_init();
-LOCAL long devPmacRamStatus_read();
-LOCAL long devPmacRamStatus_get_ioint_info();
-
-/*
- * GLOBALS
- */
-
-char * devPmacRamVersion = "@(#) devPmacRam.c 2.1 2004/02/27";
-
-#if PMAC_DIAGNOSTICS
-volatile int devPmacRamDebug = 0;
-#endif
-
-PMAC_DSET_AI devPmacRamAi =
-{
-	6,
-	NULL,
-	devPmacRam_init,
-	devPmacRamAi_init,
-	devPmacRamAi_get_ioint_info,
-	devPmacRamAi_read,
-	NULL
-};
-
-PMAC_DSET_AO devPmacRamAo =
-{
-	6,
-	NULL,
-	devPmacRam_init,
-	devPmacRamAo_init,
-	NULL,
-	devPmacRamAo_write,
-	NULL
-};
-
-PMAC_DSET_BI devPmacRamBi =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamBi_init,
-	devPmacRamBi_get_ioint_info,
-	devPmacRamBi_read
-};
-
-PMAC_DSET_BO devPmacRamBo =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamBo_init,
-	NULL,
-	devPmacRamBo_write
-};
-
-PMAC_DSET_EVENT devPmacRamEvent =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamEvent_init,
-	devPmacRamEvent_get_ioint_info,
-	devPmacRamEvent_read
-};
-
-PMAC_DSET_LI devPmacRamLi =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamLi_init,
-	devPmacRamLi_get_ioint_info,
-	devPmacRamLi_read
-};
-
-PMAC_DSET_LO devPmacRamLo =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamLo_init,
-	NULL,
-	devPmacRamLo_write
-};
-
-PMAC_DSET_MBBI devPmacRamMbbi =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamMbbi_init,
-	devPmacRamMbbi_get_ioint_info,
-	devPmacRamMbbi_read
-};
-
-PMAC_DSET_MBBO devPmacRamMbbo =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamMbbo_init,
-	NULL,
-	devPmacRamMbbo_write
-};
-
-#ifdef STATUS_RECORD
-PMAC_DSET_STATUS devPmacRamStatus =
-{
-	5,
-	NULL,
-	devPmacRam_init,
-	devPmacRamStatus_init,
-	devPmacRamStatus_get_ioint_info,
-	devPmacRamStatus_read
-};
-epicsExportAddress(dset,devPmacRamStatus);
-#endif
-
-epicsExportAddress(dset,devPmacRamAi);
-epicsExportAddress(dset,devPmacRamAo);
-epicsExportAddress(dset,devPmacRamBi);
-epicsExportAddress(dset,devPmacRamBo);
-epicsExportAddress(dset,devPmacRamEvent);
-epicsExportAddress(dset,devPmacRamLi);
-epicsExportAddress(dset,devPmacRamLo);
-epicsExportAddress(dset,devPmacRamMbbi);
-epicsExportAddress(dset,devPmacRamMbbo);
-
-
-/*
- * LOCALS
- */
-
-/*******************************************************************************
- *
- * devPmacRam_init - EPICS device support init function
- *
- */
-LOCAL long devPmacRam_init
-(
-	int	after
-)
-{
-	/* char * MyName = "devPmacRam_init"; */
-	long	status = 0;
-
-	if (after == 1)
-	{
-		status = drvPmacStartup ();
-	}
-
-	return (status);
-}
-
-
-/*******************************************************************************
- *
- * devPmacRamUpdated - function called when driver has next value
- *
- */
-void devPmacRamUpdated
-(
-	void*	pvoid
-)
-{
-	char *	MyName = "devPmacRamUpdated";
-	/* int	i; */
-	/* long	data32; */
-
-	PMAC_RAM_DPVT	*pDpvt = (PMAC_RAM_DPVT *)pvoid;
-
-	PMAC_RAM_IO	*pRamIo = pDpvt->pRamIo;
-
-	PMAC_DEBUG
-	(	7,
-		PMAC_MESSAGE ("%s: pDpvt=%010lx\n", MyName, pDpvt,0,0,0,0);
-		PMAC_MESSAGE ("%s: RamIo valLong=%#010x valDouble=%lf\n",
-			MyName, pRamIo->valLong, pRamIo->valDouble,0,0,0);
-	)
-
-	if ( (pRamIo->valLong != pDpvt->dpramData.ramLong)
-		|| (pRamIo->valDouble != pDpvt->dpramData.ramDouble) )
-	{
-		pDpvt->dpramDataPrev.ramLong = pDpvt->dpramData.ramLong;
-		pDpvt->dpramDataPrev.ramDouble = pDpvt->dpramData.ramDouble;
-
-		pDpvt->dpramData.ramLong = pRamIo->valLong;
-		pDpvt->dpramData.ramDouble = pRamIo->valDouble;
-
-		scanIoRequest (pDpvt->ioscanpvt);
-	}
-
-	return;
-}
-
-/*******************************************************************************
- *
- * devPmacRamDpvtInit - EPICS PMAC_RAM_DPVT init
- *
- */
-PMAC_RAM_DPVT * devPmacRamDpvtInit
-(
-	struct dbCommon *	pRec,
-	int			card
-)
-{
-	/* char * MyName = "devPmacRamDpvtInit"; */
-	PMAC_RAM_DPVT *	pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) malloc (sizeof(PMAC_RAM_DPVT));
-	pDpvt->pRecord = pRec;
-	pDpvt->card = card;
-
-	return (pDpvt);
-}
-
-/*******************************************************************************
- *
- * devPmacRamAi_init - EPICS device support init function for ai record
- *
- */
-LOCAL long devPmacRamAi_init
-(
-	struct aiRecord		*pRec
-)
-{
-	char *	MyName = "devPmacRamAi_init";
-	long		status;
-	PMAC_RAM_DPVT	*pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-    				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo );
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamAi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamBi_init - EPICS device support init function for bi record
- *
- */
-LOCAL long devPmacRamBi_init
-(
-	struct biRecord		*pRec
-)
-{
-	char *	MyName = "devPmacRamBi_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-    				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo );
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamBi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamEvent_init - EPICS device support init function for event record
- *
- */
-LOCAL long devPmacRamEvent_init
-(
-	struct eventRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamEvent_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-    				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamEvent_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamLi_init - EPICS device support init function for longin record
- *
- */
-LOCAL long devPmacRamLi_init
-(
-	struct longinRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamLi_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-    				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamLi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamMbbi_init - EPICS device support init function for mbbi record
- *
- */
-LOCAL long devPmacRamMbbi_init
-(
-	struct mbbiRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamMbbi_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-    				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamMbbi_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-#ifdef STATUS_RECORD
-/*******************************************************************************
- *
- * devPmacRamStatus_init - EPICS device support init function for status record
- *
- */
-LOCAL long devPmacRamStatus_init
-(
-	struct statusRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamStatus_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->inp.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->inp.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		scanIoInit (&pDpvt->ioscanpvt);
-
-		status = drvPmacDpramRequest ( pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.signal,
-				pRec->inp.value.vmeio.parm,
-   				devPmacRamUpdated, pRec->dpvt,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->inp.value.vmeio.card,
-				pRec->inp.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamStatus_init: Illegal INP field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-#endif	/* STATUS_RECORD */
-
-/*******************************************************************************
- *
- * devPmacRamAo_init - EPICS device support init function for ao record
- *
- */
-LOCAL long devPmacRamAo_init
-(
-	struct aoRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamAo_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		status = drvPmacDpramRequest ( pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,
-    				(void *) NULL, (void *) NULL,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamAo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamBo_init - EPICS device support init function for bo record
- *
- */
-LOCAL long devPmacRamBo_init
-(
-	struct boRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamBo_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		status = drvPmacDpramRequest ( pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,
-    				(void *) NULL, (void *) NULL,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamBo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamLo_init - EPICS device support init function for longout record
- *
- */
-LOCAL long devPmacRamLo_init
-(
-	struct longoutRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamLo_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		status = drvPmacDpramRequest ( pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,
-    				(void *) NULL, (void *) NULL,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamLo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamMbbo_init - EPICS device support init function for mbbo record
- *
- */
-LOCAL long devPmacRamMbbo_init
-(
-	struct mbboRecord	*pRec
-)
-{
-	char *	MyName = "devPmacRamMbbo_init";
-	long		status;
-	PMAC_RAM_DPVT *	pDpvt;
-
-	switch (pRec->out.type) {
-	case (VME_IO) :
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ("%s: card %d signal %d parm %s\n",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,0,0);
-		)
-
-		pDpvt = devPmacRamDpvtInit ( (struct dbCommon *) pRec,
-						(int) pRec->out.value.vmeio.card );
-		pRec->dpvt = (void *) pDpvt;
-
-		status = drvPmacDpramRequest ( pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.signal,
-				pRec->out.value.vmeio.parm,
-    				(void *) NULL, (void *) NULL,
-    				&pDpvt->pRamIo);
-		if (!RTN_SUCCESS(status))
-		{
-			errPrintf (status, __FILE__, __LINE__,
-				"%s: Unsuccessful DPRAM request - card %d pmacAdr %s.",
-				MyName,
-				pRec->out.value.vmeio.card,
-				pRec->out.value.vmeio.parm);
-			return (status);
-		}
-
-		break;
-
-	default :
-		recGblRecordError(S_db_badField,(void *)pRec,
-		"devPmacRamMbbo_init: Illegal OUT field");
-		return(S_db_badField);
-	}
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamAi_get_ioint_info - EPICS device support get_ioint_info function for ai record
- *
- */
-LOCAL long devPmacRamAi_get_ioint_info
-(
-	int		cmd,
-	struct aiRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamBi_get_ioint_info - EPICS device support get_ioint_info function for bi record
- *
- */
-LOCAL long devPmacRamBi_get_ioint_info
-(
-	int		cmd,
-	struct biRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamEvent_get_ioint_info - EPICS device support get_ioint_info function for event record
- *
- */
-LOCAL long devPmacRamEvent_get_ioint_info
-(
-	int		cmd,
-	struct eventRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-
-
-/*******************************************************************************
- *
- * devPmacRamLi_get_ioint_info - EPICS device support get_ioint_info function for longin record
- *
- */
-LOCAL long devPmacRamLi_get_ioint_info
-(
-	int		cmd,
-	struct longinRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamMbbi_get_ioint_info - EPICS device support get_ioint_info function for mbbi record
- *
- */
-LOCAL long devPmacRamMbbi_get_ioint_info
-(
-	int		cmd,
-	struct mbbiRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-
-#ifdef STATUS_RECORD
-/*******************************************************************************
- *
- * devPmacRamStatus_get_ioint_info - EPICS device support get_ioint_info function for status record
- *
- */
-LOCAL long devPmacRamStatus_get_ioint_info
-(
-	int		cmd,
-	struct statusRecord	*pRec,
-	IOSCANPVT	*ppvt
-)
-{
-	/* char * MyName = "devPmacRamStatus_init"; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	*ppvt = pDpvt->ioscanpvt;
-	return(0);
-}
-#endif	/* STATUS_RECORD */
-
-/*******************************************************************************
- *
- * devPmacRamAi_read - EPICS device support read function for ai record
- *
- */
-LOCAL long devPmacRamAi_read
-(
-	struct aiRecord		*pRec
-)
-{
-	/* char * MyName = "devPmacRamAi_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-	double	val;
-	
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-
-	/* Raw Value */
-	val = pDpvt->dpramData.ramDouble;
-	
-	/* this is for raw timer value */
-	if ((val >= -2147483648.0) && (val < 2147483647.1)) pRec->rval = (int) val;
-
-	/* Adjust Slope And Offset */
-	if (pRec->aslo != 0.0)
-	{
-		val *= pRec->aslo;
-	}
-	if (pRec->aoff != 0.0)
-	{
-		val += pRec->aoff;
-	}
-
-	/* pRec->linr Conversion Ignored */
-
-	/* Apply Smoothing Algorithm */
-	if (pRec->smoo != 0.0)
-	{
-	    if (pRec->init == TRUE) pRec->val = val;	/* initial condition */
-	    pRec->val = val * (1.00 - pRec->smoo) + (pRec->val * pRec->smoo);
-	}
-	else
-	{
-	    pRec->val = val;
-	}
-	
-	pRec->udf = FALSE;
-	return (2);
-}
-
-/*******************************************************************************
- *
- * devPmacRamBi_read - EPICS device support read function for bi record
- *
- */
-LOCAL long devPmacRamBi_read
-(
-	struct biRecord		*pRec
-)
-{
-	/* char * MyName = "devPmacRamBi_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-	
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-
-	pRec->rval = (unsigned long) pDpvt->dpramData.ramLong;
-	pRec->udf = FALSE;
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamEvent_read - EPICS device support read function for event record
- *
- */
-LOCAL long devPmacRamEvent_read
-(
-	struct eventRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamEvent_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pRec->val = (short) (0x0000ffff & pDpvt->dpramData.ramLong);
-	pRec->udf = FALSE;
-
-    return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamLi_read - EPICS device support read function for longin record
- *
- */
-LOCAL long devPmacRamLi_read
-(
-	struct longinRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamLi_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pRec->val = pDpvt->dpramData.ramLong;
-	pRec->udf = FALSE;
-
-    return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamMbbi_read - EPICS device support read function for mbbi record
- *
- */
-LOCAL long devPmacRamMbbi_read
-(
-	struct mbbiRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamMbbi_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pRec->rval = (unsigned long) pDpvt->dpramData.ramLong;
-	pRec->udf = FALSE;
-
-    return(0);
-}
-
-#ifdef STATUS_RECORD
-/*******************************************************************************
- *
- * devPmacRamStatus_read - EPICS device support read function for status record
- *
- */
-LOCAL long devPmacRamStatus_read
-(
-	struct statusRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamStatus_read"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pRec->val = pDpvt->dpramData.ramLong;
-	pRec->udf = FALSE;
-
-    return(0);
-}
-#endif	/* STATUS_RECORD */
-
-/*******************************************************************************
- *
- * devPmacRamAo_write - EPICS device support write function for ao record
- *
- */
-LOCAL long devPmacRamAo_write
-(
-	struct aoRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamLo_write"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-	double val;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	/* Output Value */
-	val = (double) pRec->oval;
-		
-	/* Adjust Slope And Offset */
-	if (pRec->aoff != 0.0)
-	{
-		val -= (double) pRec->aoff;
-	}
-	if (pRec->aslo != 0.0)
-	{
-		val /= (double) pRec->aslo;
-	}
-
-	/* pRec->linr Conversion Ignored */
-
-	pDpvt->pRamIo->valDouble = val; 
-	pDpvt->pRamIo->valLong = (long) val;
-	drvPmacRamPutData (pDpvt->pRamIo);
-
-    return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamBo_write - EPICS device support write function for bo record
- *
- */
-LOCAL long devPmacRamBo_write
-(
-	struct boRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamBo_write"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pDpvt->pRamIo->valLong = (long) pRec->val;
-	pDpvt->pRamIo->valDouble = (double) pDpvt->pRamIo->valLong;
-	drvPmacRamPutData (pDpvt->pRamIo);
-
-   return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamLo_write - EPICS device support write function for longout record
- *
- */
-LOCAL long devPmacRamLo_write
-(
-	struct longoutRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamLo_write"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pDpvt->pRamIo->valLong = (long) pRec->val;
-	pDpvt->pRamIo->valDouble = (double) pDpvt->pRamIo->valLong;
-	drvPmacRamPutData (pDpvt->pRamIo);
-
-    return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamMbbo_write - EPICS device support write function for mbbo record
- *
- */
-LOCAL long devPmacRamMbbo_write
-(
-	struct mbboRecord	*pRec
-)
-{
-	/* char * MyName = "devPmacRamMbbo_write"; */
-	/* long	status; */
-	PMAC_RAM_DPVT	*pDpvt;
-
-	pDpvt = (PMAC_RAM_DPVT *) pRec->dpvt;
-	
-	pDpvt->pRamIo->valLong = (long) pRec->rval;
-	pDpvt->pRamIo->valDouble = (double) pDpvt->pRamIo->valLong;
-	drvPmacRamPutData (pDpvt->pRamIo);
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * devPmacRamDpvtShow - EPICS report device private area
- *
- */
-long devPmacRamDpvtShow
-(
-	PMAC_RAM_DPVT *	pDpvt
-)
-{
-	char *	MyName = "devPmacRamDpvtShow";
-	
-	printf ("%s: Device Private for record name %s\n",
-		MyName, pDpvt->pRecord->name);
-	printf ("%s: dpramDataPrev\tramLong %#010lx\tramDouble %f\n",
-		MyName, pDpvt->dpramDataPrev.ramLong, pDpvt->dpramDataPrev.ramDouble);
-	printf ("%s: dpramData\t\tramLong %#010lx\tramDouble %f\n",
-		MyName, pDpvt->dpramData.ramLong, pDpvt->dpramData.ramDouble);
-	printf ("%s: pRamIo\t\tvalLong %#010lx\tvalDouble %f\n",
-		MyName, pDpvt->pRamIo->valLong, pDpvt->pRamIo->valDouble);
-
-	return (0);
-}		
diff --git a/pmacApp/src/devStatusSoft.c b/pmacApp/src/devStatusSoft.c
deleted file mode 100644
index 31b2ce6..0000000
--- a/pmacApp/src/devStatusSoft.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/* devStatusSoft.c - Device Support Routines for Soft Status Input */
-/*
- *      Author:		Janet Anderson
- *      Date:   	09-23-91
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- *
- *      Copyright 1991, the Regents of the University of California,
- *      and the University of Chicago Board of Governors.
- *
- *      This software was produced under  U.S. Government contracts:
- *      (W-7405-ENG-36) at the Los Alamos National Laboratory,
- *      and (W-31-109-ENG-38) at Argonne National Laboratory.
- *
- *      Initial development by:
- *              The Controls and Automation Group (AT-8)
- *              Ground Test Accelerator
- *              Accelerator Technology Division
- *              Los Alamos National Laboratory
- *
- *      Co-developed with
- *              The Controls and Computing Group
- *              Accelerator Systems Division
- *              Advanced Photon Source
- *              Argonne National Laboratory
- *
- * Modification Log:
- * -----------------
- * .01  11-11-91        jba     Moved set of alarm stat and sevr to macros
- * .02	03-13-92	jba	ANSI C changes
- * .03  10-10-92        jba     replaced code with recGblGetLinkValue call
- * 2.1  2-27-04       oam     updated for epics 3.14.5
-*/
-
-
-#include	<vxWorks.h>
-#include	<types.h>
-#include	<stdioLib.h>
-#include	<string.h>
-
-#include	<alarm.h>
-#include	<dbDefs.h>
-#include	<dbAccess.h>
-#include        <recGbl.h>
-#include        <recSup.h>
-#include	<devSup.h>
-#include	<module_types.h>
-
-#include	<statusRecord.h>
-#include "epicsExport.h"
-/* Create the dset for devStatusSoft */
-static long init_record();
-static long read_status();
-
-struct {
-	long		number;
-	DEVSUPFUN	report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record;
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read_status;
-} devStatusSoft={
-	5,
-	NULL,
-	NULL,
-	init_record,
-	NULL,
-	read_status};
-epicsExportAddress(dset,devStatusSoft);	
-
-static long init_record( struct statusRecord *pstatus )
-{
-    if( pstatus->inp.type == CONSTANT )
-    {
-      if(recGblInitConstantLink(&pstatus->inp, DBF_LONG, &pstatus->val))
-	pstatus->udf = FALSE;
-    }
-    return(0);
-}
-
-
-static long read_status( struct statusRecord *pstatus )
-{
-    long status;
-    long options  = 0;
-    long nRequest = 1;
-
-    status = dbGetLink( &(pstatus->inp), DBR_LONG, &(pstatus->val),
-                        &options, &nRequest );
-
-    if(RTN_SUCCESS(status)) pstatus->udf=FALSE;
-
-    return(status);
-}
diff --git a/pmacApp/src/drvPmac.c b/pmacApp/src/drvPmac.c
deleted file mode 100644
index 0cff9f9..0000000
--- a/pmacApp/src/drvPmac.c
+++ /dev/null
@@ -1,1953 +0,0 @@
-/* drvPmac.c -  EPICS Device Driver Support for Turbo PMAC2-VME Ultralite
- * Author       Oleg A. Makarov
- *              Thomas A. Coleman's PMAC-VME driver was used as a prototype 
- * Date:        2003/08/19
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
-
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
-
-Argonne National Laboratory (ANL), with facilities in the States of
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods.
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.
-
-*****************************************************************
-LICENSING INQUIRIES MAY BE DIRECTED TO THE INDUSTRIAL TECHNOLOGY
-DEVELOPMENT CENTER AT ARGONNE NATIONAL LABORATORY (630-252-2000).
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- * .02  7-3-97        wfl     added include of stdioLib.h
- * .03  7-15-03       oam     rewrited for Turbo PMAC2 Ultralite
- * .04  26th May 2006 ajf     Addition of Open/Close/Read/Write/Ioctl interface.
- *                            Changed WAIT_TIMEOUT to WAIT_FOREVER in
- *                            semTake of Mailbox semaphore.
- */
-
-/*
- * DESCRIPTION:
- * ------------
- * This module implements EPICS Device Driver Support for Turbo PMAC-VME Ultralite.
- *
- */
-
-/*
- * INCLUDES
- */
-
-/* VxWorks Includes */
-
-#include	<vxWorks.h>
-#include	<vxLib.h>
-#include	<stdioLib.h>
-#include	<sysLib.h>
-#include	<taskLib.h>
-#include	<iv.h>
-#include	<math.h>
-#include	<rngLib.h>
-#include	<string.h>	/* Sergey */
-#define __PROTOTYPE_5_0		/* Sergey */
-#include	<logLib.h>	/* Sergey */
-#include	<semLib.h>	/* semGive() */
-
-
-/* EPICS Includes */
-
-#include	<dbDefs.h>
-#include	<dbTest.h>
-#include	<recSup.h>
-#include	<devLib.h>
-#include	<devSup.h>
-#include	<drvSup.h>
-#include	<errMdef.h>
-#include	<taskwd.h>
-#include	<callback.h>
-#include	<dbLock.h>
-#include	<dbCommon.h>
-#include	<errlog.h>
-#include	<tsDefs.h>
-#define PMAC_ASYN
-#ifdef PMAC_ASYN
-#include "asynDriver.h"
-#include "asynOctetSyncIO.h"
-#endif
-/* local includes */
-
-#include	<drvPmac.h>
-#include "epicsExport.h"
-
-
-/*
- * DEFINES
- */
-
-#define PMAC_DIAGNOSTICS TRUE
-#define PMAC_PRIVATE FALSE
-#define vxTicksPerSecond (sysClkRateGet())	/*clock ticks per second*/
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-#if PMAC_DIAGNOSTICS
-#define PMAC_MESSAGE	logMsg
-#define PMAC_DEBUG(level,code)	{ if (drvPmacDebug >= (level)) { code } }
-#else
-#define PMAC_DEBUG(level,code)      ;
-#endif
-
-#define NO_ERR_STATUS	(-1)
-
-#define FILE_TEXT_BUFLEN	(256)
-
-#define PMAC_MEM_SIZE	0x7B31F
-#define PMAC_DPRAM	0x60000
-
-#define PMAC_MAX_CARDS	(PMAC_MAX_CTLRS)
-
-#define PMAC_MAX_MTR	(256) /* 32 motors x 8 values = 256 */
-#define	PMAC_MAX_BKG	(314) /* 16 C.S. x 19 values + 10 global = 314 */
-#define	PMAC_MAX_VAR	(128) /* max allowed */
-#define	PMAC_MAX_OPN	(480) /* */
-#define	PMAC_MAX_TIM	(1)   /* */
-
-#define PMAC_TASKNAME_LEN	15
-
-#define PMAC_MBX_QUEUE_SIZE 1000
-
-#define PMAC_MBX_SCAN		"pmacMbx"
-#define PMAC_MBX_PRI		(45)
-#define PMAC_MBX_OPT		(VX_FP_TASK)
-#define PMAC_MBX_STACK		(8000)
-
-#define PMAC_MTR_SCAN		"pmacMtr"
-#define PMAC_MTR_PRI		(44)		/* OLeg 2005/11/15 (was 45) */
-#define PMAC_MTR_RATE		(vxTicksPerSecond/10)
-#define PMAC_MTR_OPT		(VX_FP_TASK)
-#define PMAC_MTR_STACK		(8000)
-
-#define PMAC_BKG_SCAN		"pmacBkg"
-#define PMAC_BKG_PRI		(45)
-#define PMAC_BKG_RATE		(vxTicksPerSecond/10)
-#define PMAC_BKG_OPT		(VX_FP_TASK)
-#define PMAC_BKG_STACK		(8000)
-
-#define PMAC_VAR_SCAN		"pmacVar"
-#define PMAC_VAR_PRI		(45)
-#define PMAC_VAR_RATE		(vxTicksPerSecond/10)
-#define PMAC_VAR_OPT		(VX_FP_TASK)
-#define PMAC_VAR_STACK		(8000)
-
-#define PMAC_OPN_SCAN		"pmacOpn"
-#define PMAC_OPN_PRI		(46)		/* Oleg 2005/11/15 (was 45) */
-#define PMAC_OPN_RATE		(vxTicksPerSecond*1)
-#define PMAC_OPN_OPT		(VX_FP_TASK)
-#define PMAC_OPN_STACK		(8000)
-
-#define PMAC_DPRAM_MTR		1
-#define PMAC_DPRAM_BKG		2
-#define	PMAC_DPRAM_VAR		3
-#define PMAC_DPRAM_OPN		4
-#define PMAC_DPRAM_NONE		(-1)
-
-#define PMAC_MEMTYP_Y		1
-#define PMAC_MEMTYP_X		2
-#define PMAC_MEMTYP_SY		3
-#define PMAC_MEMTYP_SX		4
-#define PMAC_MEMTYP_DP		5
-#define PMAC_MEMTYP_D		6
-#define PMAC_MEMTYP_F		7
-#define PMAC_MEMTYP_L		8
-#define PMAC_MEMTYP_HY		9
-#define PMAC_MEMTYP_HX		10
-#define PMAC_MEMTYP_NONE	(-1)
-
-/* PMAC Hardware Constants */
-
-#define PMAC_VARTYP_Y		0x00
-#define PMAC_VARTYP_L		0x10
-#define PMAC_VARTYP_X		0x20
-#define PMAC_VARTYP_NONE	(-1)
-
-/*
- * TYPEDEFS
- */
-
-typedef struct  /* PMAC_DRVET */
-{
-	long		number;
-	DRVSUPFUN	report;
-	DRVSUPFUN	init;
-} PMAC_DRVET;
-
-typedef struct  /* PMAC_CARD */
-{
-	int		card;
-	int		configured;
-
-	int		enabledMbx;
-	int		enabledRam;
-	int		enabledMtr;
-	int		enabledBkg;
-	int		enabledVar;
-	int		enabledOpn;
-
-	SEM_ID		scanMbxSem;
-	SEM_ID		mutex_rngBuf;
-	RING_ID		scanMbxQ;
-
-	volatile int	scanMtrRate;
-	volatile int	scanBkgRate;
-	volatile int	scanVarRate;
-	volatile int	scanOpnRate;
-
-	int		scanMbxTaskId;
-	int		scanMtrTaskId;
-	int		scanBkgTaskId;
-	int		scanVarTaskId;
-	int		scanOpnTaskId;
-
-	char		scanMbxTaskName[PMAC_TASKNAME_LEN];
-	char		scanMtrTaskName[PMAC_TASKNAME_LEN];
-	char		scanBkgTaskName[PMAC_TASKNAME_LEN];
-	char		scanVarTaskName[PMAC_TASKNAME_LEN];
-	char		scanOpnTaskName[PMAC_TASKNAME_LEN];
-
-	int		numMtrIo;
-	int		numBkgIo;
-	int		numVarIo;
-	int		numOpnIo;
-	int		numtimMT;
-	int		numtimCS;
-	int		numtimVB;
-
-	PMAC_RAM_IO	MtrIo[PMAC_MAX_MTR];
-	PMAC_RAM_IO	BkgIo[PMAC_MAX_BKG];
-	PMAC_RAM_IO	VarIo[PMAC_MAX_VAR];
-	PMAC_RAM_IO	OpnIo[PMAC_MAX_OPN];
-	PMAC_RAM_IO	timMT[PMAC_MAX_TIM];
-	PMAC_RAM_IO	timCS[PMAC_MAX_TIM];
-	PMAC_RAM_IO	timVB[PMAC_MAX_TIM];
-	
-	struct waveformRecord *StrErr;
-	char	 	*Err;
-
-#ifdef PMAC_ASYN
-        asynUser *      pasynUser;
-#endif
-} PMAC_CARD;
-
-/*
- * FORWARD DECLARATIONS
- */
-
-PMAC_LOCAL long		drvPmacRamGetData (PMAC_RAM_IO * pRamIo);
-PMAC_LOCAL long		drvPmacRamPutData (PMAC_RAM_IO * pRamIo);
-
-PMAC_LOCAL long		drvPmac_report (int level);
-PMAC_LOCAL long		drvPmac_init (void);
-
-PMAC_LOCAL int		drvPmacMtrScan();
-PMAC_LOCAL int		drvPmacBkgScan();
-PMAC_LOCAL int		drvPmacVarScan();
-
-PMAC_LOCAL void		drvPmacMtrScanInit (int card);
-int			drvPmacMtrTask (int card);
-
-PMAC_LOCAL void		drvPmacBkgScanInit (int card);
-int			drvPmacBkgTask (int card);
-
-PMAC_LOCAL void		drvPmacVarScanInit (int card);
-int			drvPmacVarTask (int card);
-
-PMAC_LOCAL void		drvPmacMbxScanInit (int card);
-int			drvPmacMbxTask (int card);
-char			drvPmacMbxWriteRead (int card, char * writebuf, char * readbuf, char * errmsg);
-
-void 			drvPmacStrErr (waveformRecord *pRec);
-
-/*
- * GLOBALS
- */
-
-char * drvPmacVersion = "@(#) drvPmac.c 2.0 2003/08/27";
-
-#if PMAC_DIAGNOSTICS
-volatile int	drvPmacDebug = 0;		/* must be > 0 to see messages */
-#endif
-
-/* EPICS Driver Support Entry Table */
-
-PMAC_DRVET drvPmac =
-{
-	2,
-	drvPmac_report,
-	drvPmac_init,
-};
-epicsExportAddress(drvet,drvPmac);
-
-/*
- * LOCALS
- */
-
-LOCAL int	   drvPmacConfigLock = 0;
-LOCAL int	   drvPmacNumCards = 0;
-LOCAL PMAC_CARD    drvPmacCard[PMAC_MAX_CARDS];
-
-/*******************************************************************************
- *
- * pmacDrvConfig - Configure PMAC-VME Driver
- *
- * This routine is to be called in the startup script in order to init the
- * driver options.
- *
- * By default there are no cards configured.
- *
- */
-long pmacDrvConfig
-(
-	int		cardNumber,
-	int		scanMtrRate,
-	int		scanBkgRate,
-	int		scanVarRate,
-#ifdef PMAC_ASYN
-	char *		asynMbxPort
-#else
-	int		disableMbx
-#endif
-)
-{
-	char *		MyName = "pmacDrvConfig";
-	int		i;
-	/* long		status; */
-	PMAC_CARD	*pCard;
-
-	if (drvPmacConfigLock != 0)
-	{
-		printf ( "%s: Cannot change configuration after initialization -- request ignored.",
-			MyName);
-		return (ERROR);
-	}
-
-	PMAC_DEBUG
-       	(	1,
-		PMAC_MESSAGE ("%s: drvPmacNumCards = %d  PMAC_MAX_CARDS = %d\n",
-			      MyName, drvPmacNumCards, PMAC_MAX_CARDS,0,0,0);
-	)
-
-	if ( drvPmacNumCards == 0 )
-	{
-		for (i=0; i < PMAC_MAX_CARDS; i++ )
-		{
-			drvPmacCard[i].configured = FALSE;
-		}
-	}
-
-	if ( (cardNumber < 0) | (cardNumber >= PMAC_MAX_CARDS) )
-	{
-		printf ("%s: Controller number %d invalid -- must be 0 to %d.",
-			MyName, cardNumber, PMAC_MAX_CARDS - 1);
-		return(ERROR);
-	}
-
-	if (drvPmacCard[cardNumber].configured)
-	{
-		printf ("%s: Controller %d already configured -- request ignored.",
-			MyName, cardNumber);
-		return(ERROR);
-	}
-
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: Initializing card %d.\n", MyName, cardNumber);
-	)
-
-	pCard = &drvPmacCard[cardNumber];
-	pCard->card = cardNumber;
-	pCard->numMtrIo = 0;
-	pCard->numBkgIo = 0;
-	pCard->numVarIo = 0;
-	pCard->numOpnIo = 0;
-	pCard->numtimCS = 0;
-	pCard->numtimMT = 0;
-	pCard->numtimVB = 0;
-
-	pCard->scanMtrRate = PMAC_MTR_RATE;
-	pCard->scanBkgRate = PMAC_BKG_RATE;
-	pCard->scanVarRate = PMAC_VAR_RATE;
-	pCard->scanOpnRate = PMAC_OPN_RATE;
-
-	pCard->enabledMbx = TRUE;
-	pCard->enabledRam = TRUE;
-	pCard->enabledMtr = TRUE;
-	pCard->enabledBkg = TRUE;
-	pCard->enabledVar = TRUE;
-	pCard->enabledOpn = TRUE;
-	pCard->StrErr = NULL;
-	pCard->Err = NULL;
-	pCard->configured = TRUE;
-	drvPmacNumCards++;
-	
-	/* clear motor masks for data reporting buffer */
-	pmacRamPut16 ( pmacRamAddr(cardNumber,0x70), 0 );
-	pmacRamPut16 ( pmacRamAddr(cardNumber,0x72), 0 );
-	
-	/* clear max C.S. number for C.S. data reporting buffer */
-	pmacRamPut16 ( pmacRamAddr(cardNumber,0x674), 0 );
-
-#ifdef PMAC_ASYN
-        /* Setup connection to MBX port */
-        pCard->enabledMbx = FALSE;
-        if ( asynMbxPort != NULL )
-        {
-            asynStatus status;
-            const char ack = PMAC_TERM_ACK;
- 
-            status = pasynOctetSyncIO->connect( asynMbxPort, 0, &(pCard->pasynUser), NULL);
-            if (status) {
-                printf( "pmacDrvConfig: unable to connect to asynPort %s\n", asynMbxPort );
-                return ERROR;
-            }
-
-            status = pasynOctetSyncIO->setInputEos( pCard->pasynUser, &ack, 1 );
-            if (status) {
-                printf( "pmacDrvConfig: unable to set input EOS on %s: %s\n", 
-                        asynMbxPort, pCard->pasynUser->errorMessage);
-                pasynOctetSyncIO->disconnect(pCard->pasynUser);
-                return ERROR;
-            }
-
-            status = pasynOctetSyncIO->setOutputEos( pCard->pasynUser, "\r", 1 );
-            if (status) {
-                printf( "pmacDrvConfig: unable to set output EOS on %s: %s\n", 
-                        asynMbxPort, pCard->pasynUser->errorMessage);
-                pasynOctetSyncIO->disconnect(pCard->pasynUser);
-                return ERROR;
-            }
-
-            pCard->enabledMbx = TRUE;
-        }
-#endif
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * drvPmac_report - print driver report information
- *
- */
-PMAC_LOCAL long drvPmac_report
-(
-	int	level
-)
-{
-	/* char *	MyName = "drvPmac_report"; */
-	short int	i;
-	/* short int	j; */
-	PMAC_CARD *	pCard;
-
-	if (level > 0)
-	{
-	        printf ("PMAC-VME driver: %s\n", drvPmacVersion);
-		printf ("Number of cards configured = %d.\n", drvPmacNumCards);
-        	for (i = 0; i < PMAC_MAX_CARDS; i++)
-        	{
-        		if ( drvPmacCard[i].configured )
-              		{
-				pCard = &drvPmacCard[i];
-
-				printf ("card = %d  \n",
-					pCard->card);
-				printf ("    enabledMbx = %d  enabledRam = %d\n",
-					pCard->enabledMbx, pCard->enabledRam);
-				printf ("    enabledMtr = %d  enabledBkg = %d  enabledVar = %d\n",
-					pCard->enabledMtr, pCard->enabledBkg, pCard->enabledVar);
-				printf ("    enabledOpn = %d\n", pCard->enabledOpn);
-				printf ("    numMtrIo = %d  numBkgIo = %d  numVarIo = %d  numOpnIo = %d\n",
-					drvPmacCard[i].numMtrIo, drvPmacCard[i].numBkgIo,
-					drvPmacCard[i].numVarIo, drvPmacCard[i].numOpnIo);
-				pmacVmeReport( i, level );
- 			}
-
-		}
- 	}
-
- 	if (level > 1)
- 	{
- 		printf ("Print even more info. The user may be prompted for options.\n");
- 	}
-
- 	return (0);
- }
-
-/*******************************************************************************
- *
- * drvPmac_init - initialize PMAC driver
- *
- */
-PMAC_LOCAL long drvPmac_init (void)
-{
-	/* char *	MyName = "drvPmac_init"; */
-	int		status;
-
-	drvPmacConfigLock = 1;
-
-	status = pmacVmeInit ();
-
-        /* ajf: Addition of the Open/Close/Read/Write/Ioctl interface */
-/*         status = pmacDrv(); */
-
-	return (status);
-}
-
-/*******************************************************************************
- *
- * drvPmacStartup - startup PMAC driver
- *
- */
-PMAC_LOCAL long drvPmacStartup (void)
-{
-	char *		MyName = "drvPmacStartup";
-	int		i;
-
-	static	long	status = 0;
-	static	int	oneTimeOnly = 0;
-
-	if (oneTimeOnly != 0) return (status);
-
-	oneTimeOnly = -1;
-
-        for (i = 0; i < PMAC_MAX_CARDS; i++)
-        {
-                if ( drvPmacCard[i].configured )
-		{
-
-			PMAC_DEBUG
-			(	1,
-				PMAC_MESSAGE ("%s: Starting tasks for card %d.\n", MyName, i,0,0,0,0);
-			)
-
-			if ( drvPmacCard[i].enabledMbx )
-			{
-				drvPmacMbxScanInit (i);
-			}
-
-			if ( drvPmacCard[i].enabledMtr )
-			{
-				drvPmacMtrScanInit (i);
-			}
-
-			if ( drvPmacCard[i].enabledBkg )
-			{
-				drvPmacBkgScanInit (i);
-			}
-
-			if ( drvPmacCard[i].enabledVar )
-			{
-				drvPmacVarScanInit (i);
-			}
-
-		}
-	}
-
-	return (status);
-}
-
-/*******************************************************************************
- *
- * drvPmacRamDisable - Disable PMAC card DPRAM
- *
- */
-long drvPmacRamDisable
-(
-	int	card
-)
-{
-    /* char * MyName = "drvPmacRamDisable"; */
-    PMAC_CARD	*pCard;
-
-    pCard = &drvPmacCard[card];
-    pCard->enabledRam = FALSE;
-
-    return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacRamEnable - Enable PMAC card DPRAM
- *
- */
-long drvPmacRamEnable
-(
-	int	card
-)
-{
-    /* char * MyName = "drvPmacRamEnable"; */
-    PMAC_CARD	*pCard;
-
-    pCard = &drvPmacCard[card];
-    pCard->enabledRam = pCard->configured;
-
-    return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacMemSpecParse - parse a PMAC address specification into values
- *
- * specification is of the form <memType>:$<hexAddr> where valid <memType>
- * strings are Y, X, SY, SX, DP, D, F, L, HY and HX and <hexAddr> must be
- * in the range 0000 -> PMAC_MEM_SIZE.
- *
- * For example, "SX:$8000" is memory type "SX" and Hex address 0x8000.
- *
- */
-long drvPmacMemSpecParse
-(
-	char	*pmacAdrSpec,
-	int	*memType,
-	int	*pmacAdr
-)
-{
-	char *	MyName = "drvPmacMemSpecParse";
-	int	parmCount;
-
-	long	status;
-	char	memTypeStr[11];
-
-	parmCount = 0;
-	memTypeStr[0] = '\0';
-	*memType = PMAC_MEMTYP_NONE;
-	*pmacAdr = 0;
-
-	parmCount = sscanf (pmacAdrSpec, "%[^:]:$%x", memTypeStr, pmacAdr);
-
-	PMAC_DEBUG
-	(	1,
-		PMAC_MESSAGE ("%s: parse '%s' results parmCount %d\n",
-			MyName, pmacAdrSpec, parmCount,0,0,0);
-		PMAC_MESSAGE ("%s: memTypeStr '%c' pmacAdr %x\n",
-			MyName, memTypeStr[0], *pmacAdr,0,0,0);
-	)
-
-	if ( (parmCount != 2) )
-	{
-		status = S_dev_badInit;
-		errPrintf (status, __FILE__, __LINE__,
-			"%s: Improper address specification '%s'.",
-			MyName, pmacAdrSpec);
-		return (status);
-	}
-
-	if ( strcmp (memTypeStr,"Y") == 0)
-	{
-		*memType = PMAC_MEMTYP_Y;
-	}
-	else if ( strcmp (memTypeStr,"X") == 0 )
-	{
-		*memType = PMAC_MEMTYP_X;
-	}
-	else if ( strcmp (memTypeStr,"SY") == 0 )
-	{
-		*memType = PMAC_MEMTYP_SY;
-	}
-	else if ( strcmp (memTypeStr,"SX") == 0 )
-	{
-		*memType = PMAC_MEMTYP_SX;
-	}
-	else if ( strcmp (memTypeStr,"HY") == 0 )
-	{
-		*memType = PMAC_MEMTYP_HY;
-	}
-	else if ( strcmp (memTypeStr,"HX") == 0 )
-	{
-		*memType = PMAC_MEMTYP_HX;
-	}
-	else if ( strcmp (memTypeStr,"DP") == 0 )
-	{
-		*memType = PMAC_MEMTYP_DP;
-	}
-	else if ( strcmp (memTypeStr,"F") == 0 )
-	{
-		*memType = PMAC_MEMTYP_F;
-	}
-	else if ( strcmp (memTypeStr,"D") == 0 )
-	{
-		*memType = PMAC_MEMTYP_D;
-	}
-	else if ( strcmp (memTypeStr,"L") == 0 )
-	{
-		*memType = PMAC_MEMTYP_L;
-	}
-	else
-	{
-		status = S_dev_badInit;
-		errPrintf (status, __FILE__, __LINE__,
-			"%s: Illegal address type '%s' for '%s'.",
-			MyName, memTypeStr, pmacAdrSpec);
-		return (status);
-	}
-
-	PMAC_DEBUG
-	(	1,
-		PMAC_MESSAGE ("%s: memType %d\n", MyName, *memType,0,0,0,0);
-	)
-
-	if ( (*pmacAdr < 0) || (*pmacAdr > PMAC_MEM_SIZE) )
-	{
-		status = S_dev_badInit;
-		errPrintf (status, __FILE__, __LINE__,
-			"%s: Address %x out of range for '%s'.",
-			MyName, (unsigned int)pmacAdr, pmacAdrSpec);
-		return (status);
-	}
-
-	return (0);
-
-}
-
-/*******************************************************************************
- *
- * drvPmacDpramRequest - add PMAC DPRAM address to scan list
- *
- */
-long drvPmacDpramRequest
-(
-	short	card,
-	short	pmacAdrOfs,
-	char	*pmacAdrSpec,
-	void	(*pFunc)(void *),
-	void	*pParm,
-	PMAC_RAM_IO ** ppRamIo
-)
-{
-	char *	MyName = "drvPmacDpramRequest";
-	int	i;
-	long	status;
-	int	hostOfs;
-
-	PMAC_CARD *	pCard;
-	PMAC_RAM_IO *	pMtrIo;
-	PMAC_RAM_IO *	pBkgIo;
-	PMAC_RAM_IO *	pVarIo;
-	PMAC_RAM_IO *	pOpnIo;
-	PMAC_RAM_IO *	ptimCS;
-	PMAC_RAM_IO *	ptimMT;
-	PMAC_RAM_IO *	ptimVB;
-
-	int	memType;
-	int	pmacAdr;
-	long 	num, mask;
-
-	pCard = &drvPmacCard[card];
-
-	/* Parse PMAC Address Specification */
-	status = drvPmacMemSpecParse (pmacAdrSpec, &memType, &pmacAdr);
-	if (!RTN_SUCCESS(status))
-	{
-		return (status);
-	}
-
-	/* Add PMAC Address Offset */
-	pmacAdr += (long) pmacAdrOfs;
-	hostOfs = 4 * (pmacAdr - PMAC_DPRAM);
-	if (memType == PMAC_MEMTYP_HX) {
-	  hostOfs += 2;
-	}
-
-
-	/* If Motor Data Reporting Buffer */
-	if ( (pmacAdr >= PMAC_DPRAM + 0x1D) && (pmacAdr < PMAC_DPRAM + 0x19D) )
-	{
-		/* set motor mask registers */
-		num = (short)(pmacAdr-PMAC_DPRAM-0x1D)/0xC;
-		if (num < 16) { 
-		  mask = 1 << num;
-		  pmacRamGet16 ( pmacRamAddr(card,0x70), &status );
-		  status |= mask;
-		  pmacRamPut16 ( pmacRamAddr(card,0x70), status );
-		}
-		else {
-		  mask = 1 << (num - 16);
-		  pmacRamGet16 ( pmacRamAddr(card,0x72), &status );
-		  status |= mask;
-		  pmacRamPut16 ( pmacRamAddr(card,0x72), status );
-		}
-		
-		i = pCard->numMtrIo;
-		pMtrIo = &pCard->MtrIo[i];
-		*ppRamIo = pMtrIo;
-
-		pMtrIo->memType = memType;
-		pMtrIo->pmacAdr = pmacAdr;
-		pMtrIo->hostOfs = hostOfs;
-		pMtrIo->pAddress = pmacRamAddr(card,pMtrIo->hostOfs);
-		pMtrIo->pFunc = pFunc;
-		pMtrIo->pParm = pParm;
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: Mtr -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, pMtrIo->memType, pMtrIo->hostOfs, pMtrIo->pAddress,0);
-		)
-
-		pCard->numMtrIo++;
-		if (pCard->numMtrIo > PMAC_MAX_MTR) {
-		  printf("%s: too many records refer to MtrIo %d \n",MyName,pCard->numMtrIo);
-		  return -1;
-		}
-	}
-
-	/* If Background Fixed Data Buffer */
-	else if ( (pmacAdr >= PMAC_DPRAM + 0x19E) && (pmacAdr < PMAC_DPRAM + 0x3A7) )
-	{
-	
-		/* update max CS number */
-		num = (pmacAdr-PMAC_DPRAM-0x1A7)/0x20;
-		pmacRamGet16 ( pmacRamAddr(card,0x674), &status );
-		if (num >= (status & 0x1f)) {
-		  status = num + 1;
-		  pmacRamPut16 ( pmacRamAddr(card,0x674), status );
-		}
-		
-		i = pCard->numBkgIo;
-		pBkgIo = &pCard->BkgIo[i];
-		*ppRamIo = pBkgIo;
-
-		pBkgIo->memType = memType;
-		pBkgIo->pmacAdr = pmacAdr;
-		pBkgIo->hostOfs = hostOfs;
-		pBkgIo->pAddress = pmacRamAddr(card,pBkgIo->hostOfs);
-		pBkgIo->pFunc = pFunc;
-		pBkgIo->pParm = pParm;
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: Bkg -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, pBkgIo->memType, pBkgIo->hostOfs, pBkgIo->pAddress,0);
-		)
-
-		pCard->numBkgIo++;
-		if (pCard->numBkgIo > PMAC_MAX_BKG) {
-		  printf("%s: too many records refer to BkgIo %d \n",MyName,pCard->numBkgIo);
-		  return -1;
-		}
-	}
-
-	/* If Background Variable Data Buffer -- Outside of DPRAM */
-	else if ( (pmacAdr < PMAC_DPRAM) || (pmacAdr > PMAC_DPRAM + 0xFFF) )
-	{
-		i = pCard->numVarIo;
-		pVarIo = &pCard->VarIo[i];
-		*ppRamIo = pVarIo;
-
-		pVarIo->memType = memType;
-		pVarIo->pmacAdr = pmacAdr;
-		pVarIo->hostOfs = 0;		/* Unknown at this time */
-		pVarIo->pAddress = pmacRamAddr(card,pVarIo->hostOfs);
-		pVarIo->pFunc = pFunc;
-		pVarIo->pParm = pParm;
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: Var -- index %d memType %d\n",
-				MyName, i, pVarIo->memType,0,0,0);
-		)
-
-		pCard->numVarIo++;
-		if (pCard->numVarIo > PMAC_MAX_VAR) {
-		  printf("%s: too many records refer to VarIo %d \n",MyName,pCard->numVarIo);
-		  return -1;
-		}
-	}
-	/* If Background data reporting time stamp */
-	else if (pmacAdr == PMAC_DPRAM + 0x19E)
-	{
-		i = pCard->numtimCS;
-		ptimCS = &pCard->timCS[i];
-		*ppRamIo = ptimCS;
-
-		ptimCS->memType = memType;
-		ptimCS->pmacAdr = pmacAdr;
-		ptimCS->hostOfs = hostOfs;
-		ptimCS->pAddress = pmacRamAddr(card,ptimCS->hostOfs);
-		ptimCS->pFunc = pFunc;
-		ptimCS->pParm = pParm;
-
-		(*pFunc)(ptimCS->pParm); /* read CS time register once */
-		
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: timCS -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, ptimCS->memType, ptimCS->hostOfs, ptimCS->pAddress,0);
-		)
-
-		pCard->numtimCS++;
-		if (pCard->numtimCS > PMAC_MAX_TIM) {
-		  printf("%s: too many records refer to timCS %d \n",MyName,pCard->numtimCS);
-		  return -1;
-		}
-	}
-	/* If Motor data reporting time stamp */
-	else if (pmacAdr == PMAC_DPRAM + 0x1B)
-	{
-		i = pCard->numtimMT;
-		ptimMT = &pCard->timMT[i];
-		*ppRamIo = ptimMT;
-
-		ptimMT->memType = memType;
-		ptimMT->pmacAdr = pmacAdr;
-		ptimMT->hostOfs = hostOfs;
-		ptimMT->pAddress = pmacRamAddr(card,ptimMT->hostOfs);
-		ptimMT->pFunc = pFunc;
-		ptimMT->pParm = pParm;
-
-		(*pFunc)(ptimMT->pParm); /* read MT time register once */
-		
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: timMT -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, ptimMT->memType, ptimMT->hostOfs, ptimMT->pAddress,0);
-		)
-
-		pCard->numtimMT++;
-		if (pCard->numtimMT > PMAC_MAX_TIM) {
-		  printf("%s: too many records refer to timMT %d \n",MyName,pCard->numtimMT);
-		  return -1;
-		}
-	}
-	/* If Variable Buffer reporting time stamp */
-	else if (pmacAdr == PMAC_DPRAM + 0x411)
-	{
-		i = pCard->numtimVB;
-		ptimVB = &pCard->timVB[i];
-		*ppRamIo = ptimVB;
-
-		ptimVB->memType = memType;
-		ptimVB->pmacAdr = pmacAdr;
-		ptimVB->hostOfs = hostOfs;
-		ptimVB->pAddress = pmacRamAddr(card,ptimVB->hostOfs);
-		ptimVB->pFunc = pFunc;
-		ptimVB->pParm = pParm;
-		
-		(*pFunc)(ptimVB->pParm); /* read VB time register once */
-		
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: timVB -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, ptimVB->memType, ptimVB->hostOfs, ptimVB->pAddress,0);
-		)
-
-		pCard->numtimVB++;
-		if (pCard->numtimVB > PMAC_MAX_TIM) {
-		  printf("%s: too many records refer to timVB %d \n",MyName,pCard->numtimVB);
-		  return -1;
-		}
-	}
-
-	/* If 	Control Panel Function (does not yet existing) Or 
-		Motor Data Reporting Buffer Control Or
-		Background Data reporting Buffer Control Or
-		DPRAM ASCII Buffers Or
-		Background Variable Read & Write Buffer Control Or
-		Binary Rotary Program Buffer Control Or
-		Data Gathering Control Or
-		Variable-Sized Buffers / Open Use DPRAM */
-	else if ( ( (pmacAdr >= PMAC_DPRAM) && (pmacAdr < PMAC_DPRAM + 0x1D) ) ||
-		  ( (pmacAdr >= PMAC_DPRAM + 0x19D) && (pmacAdr < PMAC_DPRAM + 0x19F) ) ||
-		  ( (pmacAdr >= PMAC_DPRAM + 0x3A7) && (pmacAdr < PMAC_DPRAM + 0x1000) ) )
-	{
-		i = pCard->numOpnIo;
-		pOpnIo = &pCard->OpnIo[i];
-		*ppRamIo = pOpnIo;
-
-		pOpnIo->memType = memType;
-		pOpnIo->pmacAdr = pmacAdr;
-		pOpnIo->hostOfs = hostOfs;
-		pOpnIo->pAddress = pmacRamAddr(card,pOpnIo->hostOfs);
-		pOpnIo->pFunc = pFunc;
-		pOpnIo->pParm = pParm;
-
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: Opn -- index %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				i, pOpnIo->memType, pOpnIo->hostOfs, pOpnIo->pAddress,0);
-		)
-
-		pCard->numOpnIo++;
-		if (pCard->numOpnIo > PMAC_MAX_OPN) {
-		  printf("%s: too many records refer to OpnIo %d \n",MyName,pCard->numOpnIo);
-		  return -1;
-		}
-	}
-	else
-	{
-		status = S_dev_badRequest;
-		errPrintf (status, __FILE__, __LINE__,
-			"%s: Unsupported DPRAM address range %#06x.",
-			MyName, pmacAdr);
-		return (status);
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacVarSetup - enable operation of background variable data buffer
- *
- */
-long drvPmacVarSetup
-(
-	int	card
-)
-{
-	char *	MyName = "drvPmacVarSetup";
-	int	i;
-	long	status;
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pVarIo;
-	int	hostOfs;
-	int	configOfs;
-	long	configFormat	= PMAC_VARTYP_NONE;
-
-	/* Start Config Table At PMAC_DPRAM + 0x540 */
-	/* Maximum 128 addresses + 128 Data Words */
-	/* End of data at PMAC_DPRAM + 0xFFF */
-
-	/* Determine First Data Location */
-	configOfs = 4 * 0x540;
-	hostOfs = 4 * (0x540 + pCard->numVarIo );
-
-	/* Set Size Of Buffer To Zero Before Changing Buffer Configuration */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x1048), 0);
-
-	/* Configure Starting Address Offset Of Buffer 0x540 = 0x450 + 0xF0*/
-	status = pmacRamPut16 ( pmacRamAddr(card,0x104A), 0xF0);
-
-	/* For Each Background Variable */
-	for (i=0; i < pCard->numVarIo; i++)
-	{
-		/* Determine Location */
-		pVarIo = &pCard->VarIo[i];
-		pVarIo->hostOfs = hostOfs;
-		pVarIo->pAddress = pmacRamAddr(card,pVarIo->hostOfs);
-
-		/* Determine Memory Format */
-		switch (pVarIo->memType)
-		{
-			case (PMAC_MEMTYP_Y) :
-			case (PMAC_MEMTYP_SY) :
-				configFormat = PMAC_VARTYP_Y;
-				break;
-			case (PMAC_MEMTYP_X) :
-			case (PMAC_MEMTYP_SX) :
-				configFormat = PMAC_VARTYP_X;
-				break;
-			case (PMAC_MEMTYP_D) :
-			case (PMAC_MEMTYP_L) :
-				configFormat = PMAC_VARTYP_L;
-				break;
-			default :
-				status = ERROR;
-				/* Oleg */
-				errPrintf (status, __FILE__, __LINE__,
-					"%s: Illegal address type '%d' at address 0x%x (index %d of %d).",
-						MyName, pVarIo->memType,*pVarIo->pAddress,i,pCard->numVarIo);
-				return (status);
-				break;
-		}
-
-		/* Configure PMAC Address To Be Copied Into Buffer */
-		status = pmacRamPut16 ( pmacRamAddr(card,configOfs), pVarIo->pmacAdr );
-		status = pmacRamPut16 ( pmacRamAddr(card,configOfs + 2), configFormat );
-/*testing for D:$208 - CmdPos of the motor #4 
-                if (pVarIo->pmacAdr == 0x208) {
-		  printf ("drvPmacVarSetup: i = %d, PMAC addr = $%x, config addr = 0x%x, location Addr Offset= $%x \n",
-		  i, pVarIo->pmacAdr, (int) pmacRamAddr(card,configOfs), pVarIo->hostOfs / 4);
-		}*/
-		PMAC_DEBUG
-		(	1,
-			PMAC_MESSAGE ( "%s: configFormat %d memType %d hostOfs %x pAddress %#010lx\n",
-				MyName,
-				configFormat, pVarIo->memType,
-				pVarIo->hostOfs, pVarIo->pAddress,0);
-		)
-
-		/* Determine Location Of Next Variable */
-		configOfs += 4;
-		if (configFormat == PMAC_VARTYP_L)
-		{
-			hostOfs += 8;
-		}
-		else
-		{
-			hostOfs += 4;
-		}
-
-	}
-
-	/* Clear Data Ready Bit For Next Data Fill */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x1044), 0 );
-
-	/* Configure Size Of Buffer */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x1048), pCard->numVarIo);
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacMtrRead - read fixed motor data buffer
- *
- */
-long drvPmacMtrRead
-(
-	int	card
-)
-{
-	int	i;
-	long	status;
-	long	pmacStatus;
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pMtrIo;
-	PMAC_RAM_IO *	ptimMT;
-
-
-
-	/* Check PMAC Busy Bit */
-	status = pmacRamGet16 ( pmacRamAddr(card,0x06E), &pmacStatus );
-
-	
-	if((pmacStatus & 0x00008000) == 0){/*PMAC writing to DPRAM*/
-		return (0);
-	}
-	
-	/* Set Host Busy Bit */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x6A), 0x8000 );
-
-	/* Read PMAC Motor Fixed Data Buffer */
- 	for (i=0; i < pCard->numMtrIo; i++)
- 	{
-		pMtrIo = &pCard->MtrIo[i];
-		status = drvPmacRamGetData (pMtrIo);
-	}
-
- 	for (i=0; i < pCard->numtimMT; i++)
- 	{
-		ptimMT = &pCard->timMT[i];
-		status = drvPmacRamGetData (ptimMT);
-	}
-
-	/* Clear Host Busy Bit */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x06A), 0);
-
-	/* Notify Requester Of New Data */
-	for (i=0; i < pCard->numMtrIo; i++)
-	{
-		if ( pCard->MtrIo[i].pFunc != (void *) NULL )
-		{
-			(*pCard->MtrIo[i].pFunc)(pCard->MtrIo[i].pParm);
-		}
-	}
-
-	for (i=0; i < pCard->numtimMT; i++)
-	{
-		if ( pCard->timMT[i].pFunc != (void *) NULL )
-		{
-			(*pCard->timMT[i].pFunc)(pCard->timMT[i].pParm);
-		}
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacBkgRead - read PMAC card background fixed data buffer
- *
- */
-long drvPmacBkgRead
-(
-	int	card
-)
-{
-	char *	MyName = "drvPmacBkgRead";
-	int	i;
-	long	status;
-	long	pmacStatus;
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pBkgIo;
-	PMAC_RAM_IO *	ptimCS;
-
-	/* Check for PMAC Data Ready */
-	status = pmacRamGet16 ( pmacRamAddr(card,0x067A), &pmacStatus );
-
-	PMAC_DEBUG
-	(	5,
-		PMAC_MESSAGE ("%s: PMAC status %x\n", MyName, pmacStatus,0,0,0,0);
-	)
-
-	/* If No Data Ready Then Return Without Reading */
-	if ( (pmacStatus & 0x8000) == 0)
-	{
-		return (0);
-	}
-
-	/* Read PMAC Background Fixed Data Buffer */
-	for (i=0; i<pCard->numBkgIo; i++)
-	{
-		pBkgIo = &pCard->BkgIo[i];
-		status = drvPmacRamGetData (pBkgIo);
-	}
-
-	for (i=0; i<pCard->numtimCS; i++)
-	{
-		ptimCS = &pCard->timCS[i];
-		status = drvPmacRamGetData (ptimCS);
-	}
-
-	/* Clear Data Ready Bit For Next Data */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x67A), 0);
-
-	/* Notify Requester Of New Data */
- 	for (i=0; i < pCard->numBkgIo; i++)
-	{
-		if ( pCard->BkgIo[i].pFunc != (void *) NULL )
-		{
-			(*pCard->BkgIo[i].pFunc)(pCard->BkgIo[i].pParm);
-		}
-	}
-
- 	for (i=0; i < pCard->numtimCS; i++)
-	{
-		if ( pCard->timCS[i].pFunc != (void *) NULL )
-		{
-			(*pCard->timCS[i].pFunc)(pCard->timCS[i].pParm);
-		}
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacVarRead - read PMAC card background var data buffer
- */
-long drvPmacVarRead
-(
-	int	card
-)
-{
-	char *	MyName = "drvPmacVarRead";
-	int	i;
-	long	status;
-	long	pmacStatus;
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pVarIo;
-	PMAC_RAM_IO *	ptimVB;
-
-	/* Check For PMAC Data Ready */
-	status = pmacRamGet16 ( pmacRamAddr(card,0x1044), &pmacStatus );
-
-	PMAC_DEBUG
-	(	5,
-		PMAC_MESSAGE ("%s: PMAC status %x\n", MyName, pmacStatus,0,0,0,0);
-	)
-
-	/* If No Data Ready Then Return Without Reading */
-	if ( (pmacStatus & 0x0001) != 1) {
-		return (0);
-	}
-
-	/* Read PMAC Background Variable Data Buffer */
-	for (i=0; i<pCard->numVarIo; i++) {
-		pVarIo = &pCard->VarIo[i];
-		status = drvPmacRamGetData (pVarIo);
-	}
-	/* Read PMAC Background Variable Data Buffer time stamp*/
-	for (i=0; i<pCard->numtimVB; i++) {
-		ptimVB = &pCard->timVB[i];
-		status = drvPmacRamGetData (ptimVB);
-	}
-
-	/* Clear PMAC Data Ready Bit For Next Data */
-	status = pmacRamPut16 ( pmacRamAddr(card,0x1044), 0);
-
-	/* Notify Requester Of New Data */
- 	for (i=0; i < pCard->numVarIo; i++) {
-		if ( pCard->VarIo[i].pFunc != (void *) NULL ) {
-			(*pCard->VarIo[i].pFunc)(pCard->VarIo[i].pParm);
-		}
-	}
- 	for (i=0; i < pCard->numtimVB; i++) {
-		if ( pCard->timVB[i].pFunc != (void *) NULL ) {
-			(*pCard->timVB[i].pFunc)(pCard->timVB[i].pParm);
-		}
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacMtrShow - print motor fixed data scan information
- *
- */
-int pmacMtrShow
-(
-	int	card,
-	int	index
-)
-{
-	char *		MyName = "pmacMtrShow";
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pMtrIo	= &pCard->MtrIo[index];
-
-	printf ("%s: memType %d pmacAdr %X \n",
-		MyName,
-		pMtrIo->memType,
-		pMtrIo->pmacAdr);
-	printf ("%s: hostOfs %#x pAddress %#010x\n",
-		MyName,
-		pMtrIo->hostOfs,
-		(int)pMtrIo->pAddress);
-	printf ("%s: valLong %d valDouble %f\n",
-		MyName,
-		(int)pMtrIo->valLong,
-		pMtrIo->valDouble );
-	printf ("%s: pFunc %#010lx pParm %#010x\n",
-		MyName,
-		(long)pMtrIo->pFunc,
-		(int)pMtrIo->pParm );
-
-	return (0);
-}
-
-
-/*******************************************************************************
- *
- * pmacBkgShow - print background scan information
- *
- */
-int pmacBkgShow
-(
-	int	card,
-	int	index
-)
-{
-	char *		MyName = "pmacBkgShow";
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pBkgIo	= &pCard->BkgIo[index];
-
-	printf ("%s: memType %d pmacAdr %X \n",
-		MyName,
-		pBkgIo->memType,
-		pBkgIo->pmacAdr);
-	printf ("%s: hostOfs %#x pAddress %#010x\n",
-		MyName,
-		pBkgIo->hostOfs,
-		(int)pBkgIo->pAddress);
-	printf ("%s: valLong %d valDouble %f\n",
-		MyName,
-		(int)pBkgIo->valLong,
-		pBkgIo->valDouble );
-	printf ("%s: pFunc %#010lx pParm %#010x\n",
-		MyName,
-		(long)pBkgIo->pFunc,
-		(int)pBkgIo->pParm );
-
-	return (0);
-}
-
-
-/*******************************************************************************
- *
- * pmacVarShow - print background scan information
- *
- */
-int pmacVarShow
-(
-	int	card,
-	int	index
-)
-{
-	char *		MyName = "pmacVarShow";
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pVarIo	= &pCard->VarIo[index];
-
-	printf ("%s: memType %d pmacAdr %X \n",
-		MyName,
-		pVarIo->memType,
-		pVarIo->pmacAdr);
-	printf ("%s: hostOfs %#x pAddress %#010x\n",
-		MyName,
-		pVarIo->hostOfs,
-		(int)pVarIo->pAddress);
-	printf ("%s: valLong %d valDouble %f\n",
-		MyName,
-		(int)pVarIo->valLong,
-		pVarIo->valDouble );
-	printf ("%s: pFunc %#010lx pParm %#010x\n",
-		MyName,
-		(long)pVarIo->pFunc,
-		(int)pVarIo->pParm );
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacOpnShow - print background scan information
- *
- */
-int pmacOpnShow
-(
-	int	card,
-	int	index
-)
-{
-	char *		MyName = "pmacOpnShow";
-	PMAC_CARD *	pCard	= &drvPmacCard[card];
-	PMAC_RAM_IO *	pOpnIo	= &pCard->OpnIo[index];
-
-	printf ("%s: memType %d pmacAdr %X \n",
-		MyName,
-		pOpnIo->memType,
-		pOpnIo->pmacAdr);
-	printf ("%s: hostOfs %#x pAddress %#010x\n",
-		MyName,
-		pOpnIo->hostOfs,
-		(int)pOpnIo->pAddress);
-	printf ("%s: valLong %d valDouble %f\n",
-		MyName,
-		(int)pOpnIo->valLong,
-		pOpnIo->valDouble );
-	printf ("%s: pFunc %#010lx pParm %#010x\n",
-		MyName,
-		(long)pOpnIo->pFunc,
-		(int)pOpnIo->pParm );
-
-	return (0);
-}
-
-
-/*******************************************************************************
- * drvPmacRamGetData - read data from PMAC DPRAM
- */
-PMAC_LOCAL long drvPmacRamGetData ( PMAC_RAM_IO *	pRamIo ) {
-	/* char * MyName = "drvPmacRamGetData"; */
-	long	status;
-
-	switch (pRamIo->memType) {
-		case (PMAC_MEMTYP_Y) :
-		case (PMAC_MEMTYP_X) :
-			status = pmacRamGet24U (pRamIo->pAddress,
-						&pRamIo->valLong);
-			pRamIo->valDouble = (double) pRamIo->valLong;
-			break;
-		case (PMAC_MEMTYP_SY) :
-		case (PMAC_MEMTYP_SX) :
-			status = pmacRamGet24 (pRamIo->pAddress,
-						&pRamIo->valLong);
-			pRamIo->valDouble = (double) pRamIo->valLong;
-			break;
-		case (PMAC_MEMTYP_HY) :
-		case (PMAC_MEMTYP_HX) :
-			status = pmacRamGet16 (pRamIo->pAddress,
-						&pRamIo->valLong);
-			pRamIo->valDouble = (double) pRamIo->valLong;
-			break;
-		case (PMAC_MEMTYP_DP) :
-			status = pmacRamGet24 (pRamIo->pAddress,
-						&pRamIo->valLong);
-			pRamIo->valDouble = (double) pRamIo->valLong;
-			break;
-		case (PMAC_MEMTYP_F) :
-			status = pmacRamGetF (pRamIo->pAddress,
-						&pRamIo->valDouble);
-			pRamIo->valLong = 0;
-			break;
-		case (PMAC_MEMTYP_D) :
-			status = pmacRamGetD (pRamIo->pAddress,
-						&pRamIo->valDouble);
-			pRamIo->valLong = 0;
-			break;
-		case (PMAC_MEMTYP_L) :
-			status = pmacRamGetL (pRamIo->pAddress,
-						&pRamIo->valDouble);
-			pRamIo->valLong = 0;
-			break;
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- * drvPmacRamPutData - write data to PMAC DPRAM
- */
-PMAC_LOCAL long drvPmacRamPutData ( PMAC_RAM_IO *	pRamIo ) {
-	/* char * MyName = "drvPmacRamPutData"; */
-	long	status;
-
-	switch (pRamIo->memType) {
-		case (PMAC_MEMTYP_Y) :
-		case (PMAC_MEMTYP_X) :
-		case (PMAC_MEMTYP_SY) :
-		case (PMAC_MEMTYP_SX) :
-			status = pmacRamPut32 (pRamIo->pAddress,
-						pRamIo->valLong);
-			break;
-		case (PMAC_MEMTYP_HY) :
-		case (PMAC_MEMTYP_HX) :
-			status = pmacRamPut16 (pRamIo->pAddress,
-						pRamIo->valLong);
-			break;
-		case (PMAC_MEMTYP_DP) :
-			status = pmacRamPut32 (pRamIo->pAddress,
-						pRamIo->valLong);
-			break;
-		case (PMAC_MEMTYP_F) :
-			status = pmacRamPutF (pRamIo->pAddress,
-						pRamIo->valDouble);
-			break;
-	}
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * drvPmacMbxWriteRead - write command and read response in PMAC mailbox
- *
- */
-char drvPmacMbxWriteRead (
-	int	card,
-	char	*writebuf,
-	char	*readbuf,
-	char	*errmsg
-) {
-    /* char * MyName = "drvPmacMbxWriteRead"; */
-    char	terminator;
-#ifdef PMAC_ASYN
-    asynStatus status;
-    const double timeout=1.0;
-    size_t nwrite, nread;
-    int eomReason;
-    asynUser * pasynUser = drvPmacCard[card].pasynUser;
-    char * pEnd;
-
-    status = pasynOctetSyncIO->writeRead( pasynUser,
-                                          writebuf, strlen(writebuf),
-                                          readbuf, PMAC_MBX_IN_BUFLEN,
-                                          timeout,
-                                          &nwrite, &nread, &eomReason );
-
-    /* To simplify later processing, pretend a NULL response has a <CR> termination */
-    if (nread == 0)
-    {
-        readbuf[0] = PMAC_TERM_CR;
-        nread = 1;
-    }
-    pEnd = &readbuf[nread-1];
-
-    if ( status || *pEnd != PMAC_TERM_CR || readbuf[0] == PMAC_TERM_BELL )
-    {
-        if (status) asynPrintIO( pasynUser,
-                                 ASYN_TRACE_ERROR,
-                                 readbuf, nread,
-                                 "Asyn read/write error to PMAC card %d, command=%s. Status=%d, Error=%s\n",
-                                 card, writebuf, status, pasynUser->errorMessage);
-        else {
-	asynPrintIO( pasynUser,
-                          ASYN_TRACE_ERROR,
-                          readbuf, nread,
-                          "PMAC error on card %d, command=%s, Error=%s\n",
-                          card, writebuf, pmacError( readbuf ) );
-	}
-
-        strncpy( errmsg, readbuf, nread-1 ); errmsg[nread-1]='\0';
-        *readbuf = 0;
-        terminator = PMAC_TERM_BELL;
-    }
-    else terminator = PMAC_TERM_ACK;
-
-    /* Remove the trailing terminator */
-    if ( *pEnd == PMAC_TERM_CR  || *pEnd == PMAC_TERM_ACK || *pEnd == PMAC_TERM_BELL )
-    {
-	*pEnd = 0;
-    }
-        
-#else
-    char buffer[PMAC_MBX_IN_BUFLEN];
-
-    pmacMbxLock (card);
-
-    terminator = pmacMbxWrite (card, writebuf);
-    terminator = pmacMbxRead (card, readbuf, errmsg);
-    while ( terminator == PMAC_TERM_CR ) {
-	 terminator = pmacMbxRead (card, buffer, errmsg);
-    }
-
-    pmacMbxUnlock (card);
-#endif
-
-    return (terminator);
-}
-
-/*******************************************************************************
- *
- * drvPmacMbxScan - put PMAC MBX request on queue
- *
- */
-void drvPmacMbxScan
-(
-	PMAC_MBX_IO *	pMbxIo
-)
-{
-	char *	MyName = "drvPmacMbxScan";
-	PMAC_CARD *	pCard;
-	struct dbCommon * pRec;
-
-	pCard = &drvPmacCard[pMbxIo->card];
-	
-	semTake (pCard->mutex_rngBuf, WAIT_FOREVER);
-	if ( rngBufPut(pCard->scanMbxQ,(void *)&pMbxIo,sizeof(pMbxIo)) != sizeof(pMbxIo) ) {
-		errMessage (0,"drvPmacMbxScan: rngBufPut overflow.");
-		callbackGetUser (pRec, &pMbxIo->callback);
-		pRec->pact = FALSE;
-	} else {
-		PMAC_DEBUG
-		(	9,
-			PMAC_MESSAGE ("%s: rngBufPut completed.\n", MyName,0,0,0,0,0);
-		)
-
-		semGive (pCard->scanMbxSem);
-	}
-
-	semGive (pCard->mutex_rngBuf);
-	return;
-}
-
-/*******************************************************************************
- *
- * drvPmacMbxScanInit - initialize PMAC MBX scan task
- *
- */
-PMAC_LOCAL void drvPmacMbxScanInit
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacMbxScanInit"; */
-	/* long	status; */
-
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	pCard->scanMbxQ = rngCreate(sizeof(void *) * PMAC_MBX_QUEUE_SIZE);
-
-	if ( pCard->scanMbxQ == NULL ) {
-		errMessage (0, "drvPmacMbxScanInit: rngCreate failed");
-		exit(1);
-	}
-
-	pCard->mutex_rngBuf = semBCreate(SEM_Q_PRIORITY,SEM_FULL);
-	pCard->scanMbxSem = semBCreate(SEM_Q_FIFO,SEM_EMPTY);
-	if ( pCard->scanMbxSem == NULL ) {
-		errMessage (0, "drvPmacMbxScanInit: semBcreate failed.");
-	} else {
-		sprintf ( pCard->scanMbxTaskName, "%s%d", PMAC_MBX_SCAN, pCard->card);
-		pCard->scanMbxTaskId = taskSpawn ( pCard->scanMbxTaskName,
-					PMAC_MBX_PRI, PMAC_MBX_OPT, PMAC_MBX_STACK,
-					(FUNCPTR)drvPmacMbxTask,
-					pCard->card,0,0,0,0,0,0,0,0,0 );
-		taskwdInsert ((void*)pCard->scanMbxTaskId, NULL, 0L);
-
-             /* epicsPrintf( "***** %s: created queue size of: %d\n",
-                             pCard->scanMbxTaskName, PMAC_MBX_QUEUE_SIZE ); */
-	}
-
-	return;
-}
-
-/*******************************************************************************
- *
- * drvPmacMbxTask - task for PMAC MBX input/output
- *
- */
-int drvPmacMbxTask
-(
-	int	card
-)
-{
-	char *	MyName = "drvPmacMbxTask";
-	/* long	status; */
-
-	PMAC_CARD *	        pCard = &drvPmacCard[card];
-
-	PMAC_MBX_IO *		pMbxIo = NULL;
-
-	struct dbCommon *	pRec = NULL;
-	struct rset *		pRset = NULL;
-	int                     len;
-	epicsTimeStamp          err_time;
-	char			time_str[40];
-
-	len = sizeof(pMbxIo);
-	
-	FOREVER
-	{
-                /*ajf: Change WAIT_TIMEOUT to WAIT_FOREVER           */
-                /*     to avoid repeated messages when we do not     */
-                /*     have a database record connected to the ASCII */
-                /*     mailboxes                                     */
-		if ( semTake(pCard->scanMbxSem,WAIT_FOREVER) != OK ) {
-			errMessage(0,"drvPmacMbxTask: semTake returned error.");
-		}
-
-		semTake(pCard->mutex_rngBuf, WAIT_FOREVER);
-		while ( rngNBytes(pCard->scanMbxQ) >= len ) {
-			if ( rngBufGet(pCard->scanMbxQ,(void *)&pMbxIo,len) != len ) {
-				errMessage (0,"drvPmacMbxTask: rngBufGet returned error.");
-			} else {
-				semGive(pCard->mutex_rngBuf);
-				callbackGetUser (pRec, &pMbxIo->callback);
-				PMAC_DEBUG
-				(	6,
-					PMAC_MESSAGE ("%s: rngBufGet completed.\n", MyName,0,0,0,0,0);
-					PMAC_MESSAGE ("%s: card=%d command=[%s]\n", MyName, pMbxIo->card, pMbxIo->command,0,0,0);
-				)
-				pMbxIo->terminator = drvPmacMbxWriteRead (pMbxIo->card, pMbxIo->command, pMbxIo->response, pMbxIo->errmsg);
-
-				if ( pMbxIo->terminator == PMAC_TERM_BELL ) {
-					epicsTimeGetCurrent (&err_time);
-					pRec->pact = FALSE;
-					
-				        if (pCard->StrErr) { 	/* report error through the StrErr waveform record */
-					       tsStampToText (&err_time, TS_TEXT_MMDDYY, time_str);
-					       dbScanLock ((struct dbCommon *)pCard->StrErr); pCard->StrErr->putf = TRUE;
-					       sprintf (pCard->Err, "%17.17s PV=%s CMD=%s %s %s", time_str, pRec->name, pMbxIo->command, &pMbxIo->errmsg[1], pmacError (pMbxIo->errmsg));
-					       pCard->StrErr->nord = strlen (pCard->Err); pCard->Err[pCard->StrErr->nelm - 1] = '\0';
-					       pCard->StrErr->pact = TRUE; pRset = pCard->StrErr->rset; (*(pRset->process))(pCard->StrErr); dbScanUnlock ((struct dbCommon *)pCard->StrErr);
-					       
-					}	
-				} else {
-					PMAC_DEBUG
-					(	6,
-						PMAC_MESSAGE ("%s: response=[%s]\n", MyName, pMbxIo->response,0,0,0,0);
-					)
-        				dbScanLock (pRec); pRset = pRec->rset; (*(pRset->process))(pRec); dbScanUnlock (pRec);
-				}
-				semTake(pCard->mutex_rngBuf, WAIT_FOREVER);
-
-			}
-
-		}
-		semGive(pCard->mutex_rngBuf);
-	}
-}
-
-/*******************************************************************************
- *
- * drvPmacMtrTask - perform motor fixed buffer scanning
- *
- */
-int drvPmacMtrTask
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacMtrTask"; */
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	FOREVER
-	{
-		if ( pCard->enabledMtr )
-		{
-			drvPmacMtrRead (pCard->card);
-		}
-		taskDelay (pCard->scanMtrRate);
-	}
-}
-
-/*******************************************************************************
- *
- * drvPmacMtrScanInit - spawn task to perform scanning of the motor fixed buffer
- *
- */
-PMAC_LOCAL void drvPmacMtrScanInit
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacMtrScanInit"; */
-	/* long	status; */
-
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	sprintf ( pCard->scanMtrTaskName, "%s%d", PMAC_MTR_SCAN, pCard->card);
-	pCard->scanMtrTaskId = taskSpawn ( pCard->scanMtrTaskName,
-				PMAC_MTR_PRI, PMAC_MTR_OPT, PMAC_MTR_STACK,
-				drvPmacMtrTask,
-				pCard->card,0,0,0,0,0,0,0,0,0 );
-	taskwdInsert ((void*)pCard->scanMtrTaskId, NULL, NULL);
-
-	return;
-}
-
-/*******************************************************************************
- *
- * drvPmacBkgTask - perform background scanning
- *
- */
-int drvPmacBkgTask
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacBkgTask"; */
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	FOREVER
-	{
-		if ( pCard->enabledBkg )
-		{
-			drvPmacBkgRead (pCard->card);
-		}
-		taskDelay (pCard->scanBkgRate);
-	}
-}
-
-/*******************************************************************************
- *
- * drvPmacBkgScanInit - spawn task to perform background scanning
- *
- */
-PMAC_LOCAL void drvPmacBkgScanInit
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacBkgScanInit"; */
-	/* long	status; */
-
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	sprintf ( pCard->scanBkgTaskName, "%s%d", PMAC_BKG_SCAN, pCard->card);
-	pCard->scanBkgTaskId = taskSpawn ( pCard->scanBkgTaskName,
-				PMAC_BKG_PRI, PMAC_BKG_OPT, PMAC_BKG_STACK,
-				drvPmacBkgTask,
-				pCard->card,0,0,0,0,0,0,0,0,0 );
-	taskwdInsert ((void*)pCard->scanBkgTaskId, NULL, NULL);
-
-	return;
-}
-
-/*******************************************************************************
- *
- * drvPmacVarTask - perform background variable scanning
- *
- */
-int drvPmacVarTask
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacVarTask"; */
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	FOREVER
-	{
-		if ( pCard->enabledVar )
-		{
-			drvPmacVarRead (pCard->card);
-		}
-		taskDelay (pCard->scanVarRate);
-	}
-}
-
-/*******************************************************************************
- *
- * drvPmacVarScanInit - spawn task to perform background scanning
- *
- */
-PMAC_LOCAL void drvPmacVarScanInit
-(
-	int	card
-)
-{
-	/* char * MyName = "drvPmacVarScanInit"; */
-	long	status;
-
-	PMAC_CARD *	pCard = &drvPmacCard[card];
-
-	status = drvPmacVarSetup (pCard->card);
-
-	sprintf ( pCard->scanVarTaskName, "%s%d", PMAC_VAR_SCAN, pCard->card);
-	pCard->scanVarTaskId = taskSpawn ( pCard->scanVarTaskName,
-				PMAC_VAR_PRI, PMAC_VAR_OPT, PMAC_VAR_STACK,
-				drvPmacVarTask,
-				pCard->card,0,0,0,0,0,0,0,0,0 );
-	taskwdInsert ((void*)pCard->scanVarTaskId, NULL, NULL);
-
-	return;
-}
-
-void drvPmacStrErr (struct waveformRecord *pRec) { /* set StrErr pointer in the drvPmacCard[card] structure */
-	PMAC_CARD * 	pCard = &drvPmacCard[pRec->inp.value.vmeio.card];
-	pCard->StrErr = pRec;
-	pCard->Err = pRec->bptr;
-	printf ("drvPmacStrErr: pRec=0x%x [%s], pval=0x%x, card=%d \n", (unsigned int)pRec, pRec->name, (unsigned int)pRec->bptr, pRec->inp.value.vmeio.card);
-	return;
-}
diff --git a/pmacApp/src/drvPmac.h b/pmacApp/src/drvPmac.h
deleted file mode 100644
index 5f29831..0000000
--- a/pmacApp/src/drvPmac.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/* drvPmac.h -  EPICS Device Driver Support for Turbo PMAC2-VME Ultralite
- * Author       Oleg A. Makarov
- *              Thomas A. Coleman's PMAC-VME driver was used as a prototype 
- * Date:        2003/08/19
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
-
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
-
-Argonne National Laboratory (ANL), with facilities in the States of
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods.
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.
-
-*****************************************************************
-LICENSING INQUIRIES MAY BE DIRECTED TO THE INDUSTRIAL TECHNOLOGY
-DEVELOPMENT CENTER AT ARGONNE NATIONAL LABORATORY (708-252-2000).
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- */
-
-#ifndef __INCdrvPmacH
-#define __INCdrvPmacH
-
-#include <pmacVme.h>
-#include <pmacError.h>
-#include <waveformRecord.h>
-
-typedef struct  /* PMAC_MBX_IO */
-{
-	struct dbCommon *	pRec;
-	int			card;
-	long			terminator;
-	char			command[PMAC_MBX_OUT_BUFLEN];
-	char			response[PMAC_MBX_IN_BUFLEN];
-	char			errmsg[PMAC_MBX_ERR_BUFLEN];
-	CALLBACK		callback;
-} PMAC_MBX_IO;
-
-typedef struct  /* PMAC_RAM_IO */
-{
-	int		memType;
-	int		pmacAdr;
-	int		hostOfs;
-  	PMAC_DPRAM *	pAddress;
-	long		valLong;
-	double		valDouble;
- 	VOIDFUNCPTR	pFunc;
-  	void *		pParm;
-} PMAC_RAM_IO;
-
-/* ---- Sergey ----- */
-long pmacDrvConfig (int	cardNumber, int	scanMtrRate, int scanBkgRate, int scanVarRate,
-#ifdef PMAC_ASYN
-	char *		asynMbxPort
-#else
-	int		disableMbx
-#endif
-);
-PMAC_LOCAL long drvPmac_report (int level);
-PMAC_LOCAL long drvPmac_init (void);
-PMAC_LOCAL long drvPmacStartup (void);
-long drvPmacRamDisable (int card);
-long drvPmacRamEnable (int card);
-long drvPmacMemSpecParse (char *pmacAdrSpec, int *memType, int *pmacAdr);
-long drvPmacVarSetup ( int card);
-long drvPmacMtrRead ( int card);
-long drvPmacBkgRead ( int card);
-long drvPmacVarRead ( int card);
-int pmacMtrShow ( int card, int	index);
-int pmacBkgShow ( int card, int index);
-int pmacVarShow ( int card, int	index);
-int pmacOpnShow ( int card, int index);
-char drvPmacMbxWriteRead ( int card, char *writebuf, char *readbuf, char *errmsg);
-PMAC_LOCAL void drvPmacMbxScanInit(int card);
-int drvPmacMbxTask(int card);
-int drvPmacMtrTask(int card);
-PMAC_LOCAL void drvPmacMtrScanInit(int card);
-int drvPmacBkgTask(int card);
-PMAC_LOCAL void drvPmacBkgScanInit(int card);
-int drvPmacVarTask(int card);
-PMAC_LOCAL void drvPmacVarScanInit(int card);
-long drvPmacDpramRequest (short card, short pmacAdrOfs, char *pmacAdrSpec, void (*pFunc)(void *), void *pParm, PMAC_RAM_IO **ppRamIo);
-PMAC_LOCAL long drvPmacRamGetData(PMAC_RAM_IO *pRamIo);
-PMAC_LOCAL long drvPmacRamPutData(PMAC_RAM_IO *pRamIo);
-void drvPmacMbxScan (PMAC_MBX_IO *pMbxIo);
-void drvPmacStrErr (waveformRecord *pRec);
-
-#endif /* __INCdrvPmacH */
diff --git a/pmacApp/src/pmacDriver.c b/pmacApp/src/pmacDriver.c
deleted file mode 100644
index e620d4a..0000000
--- a/pmacApp/src/pmacDriver.c
+++ /dev/null
@@ -1,678 +0,0 @@
-/*
- *  Implementation of the Open/Close/Read/Write/Ioctl interface to
- *  PMAC DPRAM ASCII and PMAC Mailbox ASCII.
- *
- *  Author: Andy Foster (for Diamond)
- *  Date:   26th May 2006
- *
-*/
-
-/* ANSI C headers */
-#include <stdio.h>
-
-/* vxWorks headers */
-#include <iosLib.h>    /* For DEV_HDR, iosDrvCreate and iosDevAdd */
-#include <logLib.h>    /* For logMsg */
-
-/* EPICS headers */
-#include <epicsRingBytes.h>
-#include <epicsTypes.h>
-#include <epicsThread.h>
-#include <epicsEvent.h>
-#include <cantProceed.h>
-#include <devLib.h>
-
-/* PMAC headers */
-#include <pmacVme.h>
-#include <pmacDriver.h>
-
-/** Makes writing to a register on the VME board a bit more explicit */
-#define getReg(location)          (location)
-#define setReg(location, value)   (location) = (value)
-
-#define PMAC_DRIVER_DEBUG        0
-#define PMAC_BASE_MBX_REGS_IN   16
-#define PMAC_BASE_MBX_REGS_OUT  15
-#define PMAC_BASE_ASC_REGS_OUT 160
-
-int    pmacDrvNumAsc  = 0;     /* DPRAM ASCII driver number   */
-int    pmacDrvNumMbx  = 0;     /* Mailbox ASCII driver number */
-int    replyQueueSize = 40960; /* Size of ring buffer - large enough for a list gather response of 1024 samples of 3 variables */
-
-typedef struct
-{
-    DEV_HDR          devHdr;
-    int              ctlr;
-    int              openFlag;
-    int              cancelFlag;
-    epicsRingBytesId replyQ;
-    epicsEventId     ioReadmeId;
-    epicsEventId     ioReceivedId;
-    void             (*readMeISR)( void * );
-} PMAC_DEV;
-
-/* Function prototypes */
-
-static int  pmacOpen(           PMAC_DEV *, char *, int );
-static int  pmacClose(          PMAC_DEV *              );
-static int  pmacRead(           PMAC_DEV *, char *, int );
-static int  pmacIoctl(          PMAC_DEV *, int, int *  );
-static int  pmacWriteAsc(       PMAC_DEV *, char *, int );
-static int  pmacWriteMbx(       PMAC_DEV *, char *, int );
-static void pmacAscReadMeISR(   PMAC_DEV *              );
-static void pmacMbxReadMeISR(   PMAC_DEV *              );
-static void pmacMbxReceivedISR( PMAC_DEV *              );
-
-PMAC_DEV pmacAscDev[PMAC_MAX_CTLRS];
-PMAC_DEV pmacMbxDev[PMAC_MAX_CTLRS];
-
-IMPORT int       pmacVmeConfigLock;
-IMPORT PMAC_CTLR pmacVmeCtlr[PMAC_MAX_CTLRS];
-
-/* TRANSACTION_LOCK introduces a binary semaphore that is taken by the DPRAM
-   write routine and given by the read ISR when it sees the end of transaction.
-   terminator (ACK). This ensures that there is only one transaction going to
-   one PMAC at a time. This makes communication more reliable if there is more
-   than one PMAC in the VME chassis */
-
-#define TRANSACTION_LOCK
-#ifdef TRANSACTION_LOCK
-static epicsEventId transactionLock = NULL;
-#endif
-
-/* This routine installs the DPRAM ASCII driver and the Mailbox ASCII driver.
-   It adds a DRPAM ASCII device and a Mailbox ASCII device for every PMAC
-   card that has been configured.
-   This routine is called from "drvPmac_init" in "drvPmac.c"
-   which in turn is called from EPICS "iocInit()" */
-
-STATUS pmacDrv(void)
-{
-  STATUS ret;
-  int    installedAsc;
-  int    installedMbx;
-  int    i;
-  char   devNameAsc[32];
-  char   devNameMbx[32];
-  char   errorString[64];
-  long   status;
-
-  ret          = OK;
-  installedAsc = FALSE;
-  installedMbx = FALSE;
-
-  /* For the DPRAM ASCII driver */
-
-  /* check if driver already installed */
-
-  if (pmacDrvNumAsc > 0)
-  {
-    installedAsc = TRUE;
-    ret          = OK;
-  }
-
-  if( !installedAsc )
-  {
-#ifdef TRANSACTION_LOCK
-    if (transactionLock == NULL) transactionLock = epicsEventMustCreate (epicsEventFull);
-#endif
-    pmacDrvNumAsc = iosDrvInstall( 0, 0, pmacOpen,  pmacClose, pmacRead, pmacWriteAsc, pmacIoctl );
-
-    /* Add a DPRAM ASCII device for every configured card */
-    for( i=0; i < PMAC_MAX_CTLRS; i++ )
-    {
-      pmacAscDev[i].ctlr       = pmacVmeCtlr[i].ctlr;
-      pmacAscDev[i].openFlag   = 0;
-      pmacAscDev[i].cancelFlag = 0;
-
-      if( pmacVmeCtlr[i].configured )
-      {
-        sprintf( devNameAsc, "/dev/pmac/%d/asc", pmacVmeCtlr[i].ctlr );
-        ret = iosDevAdd( &pmacAscDev[i].devHdr, devNameAsc, pmacDrvNumAsc);
-        if( ret == ERROR )
-        {
-          sprintf( errorString, "pmacDrv: Error adding: /dev/pmac/%d/asc device", pmacVmeCtlr[i].ctlr );
-          cantProceed( errorString );
-        }
-
-        pmacAscDev[i].replyQ = epicsRingBytesCreate(replyQueueSize);
-        if( !pmacAscDev[i].replyQ )
-          cantProceed("pmacDrv: Failed to create ring buffer");
-
-        pmacAscDev[i].ioReadmeId   = epicsEventMustCreate( epicsEventEmpty ); 
-        pmacAscDev[i].ioReceivedId = 0;
-        pmacAscDev[i].readMeISR    = (void *)pmacAscReadMeISR;
-
-        status = devConnectInterruptVME( pmacVmeCtlr[i].irqVector + 1,
-                                      (void *)pmacAscReadMeISR, (void *) &(pmacAscDev[i]) );
-        if(!RTN_SUCCESS(status))
-          cantProceed("pmacDrv: Failed to connect to DPRAM ASCII readme interrupt");
-      }
-    }
-  }
-
-  /* For the Mailbox ASCII driver */
-
-  /* check if driver already installed */
-
-  if(pmacDrvNumMbx > 0)
-  {
-    installedMbx = TRUE;
-    ret          = OK;
-  }
-
-  if( !installedMbx )
-  {
-    pmacDrvNumMbx = iosDrvInstall( 0, 0, pmacOpen,  pmacClose, pmacRead, pmacWriteMbx, pmacIoctl );
-
-    /* Add a Mailbox ASCII device for every configured card */
-    for( i=0; i < PMAC_MAX_CTLRS; i++ )
-    {
-      pmacMbxDev[i].ctlr       = pmacVmeCtlr[i].ctlr;
-      pmacMbxDev[i].openFlag   = 0;
-      pmacMbxDev[i].cancelFlag = 0;
-
-      if ( pmacVmeCtlr[i].configured )
-      {
-        sprintf( devNameMbx, "/dev/pmac/%d/mbx", pmacVmeCtlr[i].ctlr );           
-        ret = iosDevAdd( &pmacMbxDev[i].devHdr, devNameMbx, pmacDrvNumMbx );
-        if( ret == ERROR ) 
-        {
-          sprintf( errorString, "pmacDrv: Error adding: /dev/pmac/%d/mbx device", pmacVmeCtlr[i].ctlr );
-          cantProceed( errorString );
-        }
-
-        pmacMbxDev[i].replyQ = epicsRingBytesCreate(replyQueueSize);
-        if( !pmacMbxDev[i].replyQ )
-          cantProceed("pmacDrv: Failed to create ring buffer");
-
-        pmacMbxDev[i].ioReadmeId   = epicsEventMustCreate( epicsEventEmpty ); 
-        pmacMbxDev[i].ioReceivedId = epicsEventMustCreate( epicsEventEmpty );
-        pmacMbxDev[i].readMeISR    = (void *)pmacMbxReadMeISR;
-
-        status = devConnectInterruptVME( pmacVmeCtlr[i].irqVector,
-                                      (void *)pmacMbxReadMeISR, (void *) &(pmacMbxDev[i]) );
-
-        if( !RTN_SUCCESS(status) )
-          cantProceed("pmacDrv: Failed to connect to Mailbox ASCII readme interrupt");
-
-        status = devConnectInterruptVME( pmacVmeCtlr[i].irqVector - 1,
-                                      (void *)pmacMbxReceivedISR, (void *) &(pmacMbxDev[i]) );
-
-        /* Pre-enable responses to commands */
-        /* pmacVmeCtlr[i].pBase->mailbox.MB[1].data = 0; */
-
-       if( !RTN_SUCCESS(status) )
-          cantProceed("pmacDrv: Failed to connect to Mailbox ASCII received interrupt");
-      }
-    }
-  }
-  return( ret );
-}
-
-
-/* The routines:                                                      */
-/*   pmacOpen                                                         */
-/*   pmacClose                                                        */
-/*   pmacRead                                                         */
-/*   pmacIoctl                                                        */
-/*   are generic between the DPRAM ASCII and Mailbox ASCII interfaces */
-
-static int pmacOpen( PMAC_DEV *pPmacDev, char * remainder, int mode )
-{
-  if( remainder[0] != 0 || pPmacDev->openFlag )
-    return ERROR;
-  else
-    pPmacDev->openFlag = TRUE;
-
-  return( (int)pPmacDev );
-}
-
-
-static int pmacClose( PMAC_DEV *pPmacDev )
-{
-  if( pPmacDev->openFlag )
-    pPmacDev->openFlag = FALSE;
-
-  return( OK );
-}
-
-int pmacNoInterruptCount=0;
-int pmacDriverDebug=0;
-
-static int pmacRead( PMAC_DEV *pPmacDev, char *buffer, int nBytes )
-{
-  int numRead;
-
-  numRead = epicsRingBytesGet(pPmacDev->replyQ, buffer, nBytes);
-
-  if( numRead == 0 )  /* The buffer was empty */
-  {
-      epicsEventWaitStatus status;
-
-      /* Check to see if the semaphore was given */
-      status = epicsEventWaitWithTimeout( pPmacDev->ioReadmeId, 0.2 );
-
-      if (status == epicsEventWaitTimeout)
-      {
-          int irqLevel = pmacVmeCtlr[pPmacDev->ctlr].irqLevel;
-
-	  pmacNoInterruptCount++;
-
-          if ( pPmacDev->readMeISR ) {
-              if (pmacDriverDebug)
-                  logMsg( "Manually calling ISR for PMAC card %d, vector %d\n",
-                          pPmacDev->ctlr, pmacVmeCtlr[pPmacDev->ctlr].irqVector,0,0,0,0 );
-
-              devDisableInterruptLevel (intVME, irqLevel);
-              pPmacDev->readMeISR( pPmacDev );
-              devEnableInterruptLevel (intVME, irqLevel);
-          }
-          epicsEventWait( pPmacDev->ioReadmeId );
-      }
-
-      if( pPmacDev->cancelFlag )
-      {
-        pPmacDev->cancelFlag = FALSE;
-      }
-      else
-      {
-        numRead    = epicsRingBytesGet(pPmacDev->replyQ, buffer, nBytes);
-      }
-  }
-
-  return( numRead );
-}
-
-
-static int pmacIoctl( PMAC_DEV *pPmacDev, int request, int *arg )
-{
-  int ret = 0;
-
-  switch( request )
-  {
-    case FIONREAD:
-      *arg = epicsRingBytesUsedBytes( pPmacDev->replyQ );
-      break;
-
-    case FIORFLUSH:
-      epicsRingBytesFlush( pPmacDev->replyQ );
-      break;
-
-    case FIOCANCEL:
-      pPmacDev->cancelFlag = TRUE;
-      epicsEventSignal( pPmacDev->ioReadmeId );
-      break;
-
-    default:
-      break;
-  }
-  return( ret );
-}
-
-
-/* The write and ISR routines are specific to the */
-/* DPRAM ASCII and Mailbox ASCII interfaces       */
-
-static int pmacWriteAsc( PMAC_DEV *pDev, char *buffer, int nBytes )
-{
-  int        i;
-  int        ctlr;
-  int        numWritten;
-  static int totalWritten = 0;
-  PMAC_DPRAM *dpramAsciiOut;
-  PMAC_DPRAM *dpramAsciiOutControl;
-
-  ctlr                 = pDev->ctlr;
-  dpramAsciiOut        = pmacRamAddr(ctlr,0x0EA0);
-  dpramAsciiOutControl = pmacRamAddr(ctlr,0x0E9C);
-  i                    = 0;
-  numWritten           = 0;
-
-#ifdef TRANSACTION_LOCK
-  epicsEventWaitWithTimeout( transactionLock, 0.3 );
-#endif
-
-  for( i=0; (i < nBytes) && (i < PMAC_BASE_ASC_REGS_OUT); i++ )
-  {
-    if( buffer[i] == '\r' )
-    {
-      /* Send command to PMAC */
-      setReg( dpramAsciiOut[totalWritten], (char) 0 );
-      setReg( *dpramAsciiOutControl, (char) 1 );
-      totalWritten = 0;
-    }
-    else
-    {
-      if( totalWritten == 0 )
-      {
-        /* Line termination just sent - ensure PMAC is ready */
-        int count = 0;
-        const double delay = epicsThreadSleepQuantum();
-
-        while( getReg( *dpramAsciiOutControl ) != 0x0 )
-        {
-          epicsThreadSleep(delay);
-          count++;
-          if( count > 10 )
-            printf( "pmacWriteAsc: Stuck in while loop\n" );
-        }
-      }
-      setReg( dpramAsciiOut[totalWritten], buffer[i] );
-      totalWritten++;
-    }
-    numWritten++;
-  }
-  return(numWritten);
-}
-
-
-/* pmacAscReadMeISR - Interrupt Service Routine which is called when
-                      PMAC issues an interrupt to tell us the DPRAM ASCII buffer
-                      can be read.
-                      Note: There is 1 interrupt per line of the response and
-                      1 interrupt for the ACK at the end. */
-
-static void pmacAscReadMeISR( PMAC_DEV *pDev )
-{
-  int         i;
-  int         ctlr;
-  int         pushOK;
-  int         length;
-  volatile epicsUInt16 *dpramAsciiInControl;
-  PMAC_DPRAM  *dpramAsciiIn;
-  union {epicsUInt16 S; char C[2];} control;
-  ctlr                = pDev->ctlr;
-  dpramAsciiInControl = (volatile epicsUInt16 *) pmacRamAddr(ctlr, 0x0F40);
-  dpramAsciiIn        = pmacRamAddr(ctlr, 0x0F44);
-  control.S           = getReg (*dpramAsciiInControl);
-
-  if (control.S == 0)
-  {
-      logMsg( "No response from PMAC in pmacAscInISR\n", 0,0,0,0,0,0 );
-      return;
-  }
-  if (control.C[1] == 0 )
-  {
-    length = getReg( *pmacRamAddr(ctlr, 0x0F42) ) - 1;
-    for( i=0; i<length; i++ )
-    {
-        char c = getReg(*dpramAsciiIn);
-        pushOK = epicsRingBytesPut( pDev->replyQ, &c, 1);
-        if( !pushOK ) logMsg("PMAC reply ring buffer full\n", 0,0,0,0,0,0);
-        dpramAsciiIn++;
-    }
-    pushOK = epicsRingBytesPut( pDev->replyQ, &(control.C[0]), 1);
-    if( !pushOK ) logMsg("PMAC reply ring buffer full\n", 0,0,0,0,0,0);
-  }
-  else
-  {
-    /* Build a "ERRnnn" string from the BCD error code in dpramAsciiInControl */
-    char response[]={PMAC_TERM_BELL,'E','R','R','0','0','0',PMAC_TERM_CR,PMAC_TERM_ACK};
-
-    /* Convert the BCD encoded error number to its ASCII equivalent */
-    response[4] += ((control.C[1])       & 0xF );
-    response[5] += ((control.C[0] >> 4 ) & 0xF );
-    response[6] += ((control.C[0] )      & 0xF );
-
-    /* Push the data the onto the ring buffer */
-    pushOK = epicsRingBytesPut( pDev->replyQ, response, sizeof(response) );
-    if( !pushOK )
-      logMsg("PMAC reply ring buffer full\n", 0, 0, 0, 0, 0, 0);
-  }
-
-  setReg( *dpramAsciiInControl, (epicsUInt16) 0 );
-  epicsEventSignal( pDev->ioReadmeId );
-
-#ifdef TRANSACTION_LOCK
-  if ( control.C[0] == PMAC_TERM_ACK ) epicsEventSignal( transactionLock );
-#endif
-
-  return;
-}
-
-
-static int pmacWriteMbx( PMAC_DEV *pPmacDev, char *buffer, int nBytes )
-{
-  int       i;
-  int       j;
-  int       numWritten;
-  int       ctlr;
-  char      firstChar, c;
-  PMAC_CTLR *pPmacCtlr;
-
-  j          = 0;
-  numWritten = 0;
-  ctlr       = pPmacDev->ctlr;
-  pPmacCtlr  = &pmacVmeCtlr[ctlr];
-
-  while( numWritten < nBytes )
-  {
-    firstChar = buffer[j];
-    for( i = 1; i < PMAC_BASE_MBX_REGS_OUT; i++ )
-    {
-      if( PMAC_DRIVER_DEBUG )
-        printf("pmacWriteMbx: 0x%x (%d)\n", buffer[j+i], i);
-      pPmacCtlr->pBase->mailbox.MB[i+1].data = buffer[j+i];
-      numWritten++;
-      if( buffer[j+i] == PMAC_TERM_CR )
-        break;
-    }
-
-    if( PMAC_DRIVER_DEBUG )
-      printf("pmacWriteMbx: 0x%x (0)\n", firstChar);
-    pPmacCtlr->pBase->mailbox.MB[0].data = firstChar;
-    numWritten++;
-
-    /* Now, enable the response, and read the data back to ensure it is written */
-    pPmacCtlr->pBase->mailbox.MB[1].data = 0;
-    c = pPmacCtlr->pBase->mailbox.MB[1].data;
-
-    epicsEventWait( pPmacDev->ioReceivedId );
-    j += PMAC_BASE_MBX_REGS_OUT;
-  }
-
-  return( numWritten );
-}
-
-
-/* We get this interrupt when PMAC has filled the Mailbox registers */
-/* and we can then read the data                                    */
-
-static void pmacMbxReadMeISR( PMAC_DEV *pPmacDev )
-{
-  int       i;
-  int       ctlr;
-  int       pushOK;
-  int       sendMore;
-  char	    c;
-  PMAC_CTLR *pPmacCtlr;
-  int        terminator=0;
-
-  /* logMsg("Inside pmacMbxReadMeISR...\n", 0, 0, 0, 0, 0, 0); */
-
-  ctlr      = pPmacDev->ctlr;
-  pPmacCtlr = &pmacVmeCtlr[ctlr];
-  sendMore  = 1;
-
-  for( i = 0; i < PMAC_BASE_MBX_REGS_IN && !terminator; i++ )
-  {
-    c      = pPmacCtlr->pBase->mailbox.MB[i].data;
-
-    pushOK = epicsRingBytesPut( pPmacDev->replyQ, &c, 1);
-    if( !pushOK )
-      logMsg("PMAC reply ring buffer full\n", 0, 0, 0, 0, 0, 0);
-
-    terminator = ( (c == PMAC_TERM_CR) || (c == PMAC_TERM_ACK) || (c == PMAC_TERM_BELL) );
-    if (terminator)
-    {
-        static int hadBell = 0;
-        int bell = (c == PMAC_TERM_BELL);
-
-        /* Add an ACK to the first terminator after a BELL to make parsing easier */
-        if (hadBell) 
-        {
-            c = PMAC_TERM_ACK;
-            pushOK = epicsRingBytesPut( pPmacDev->replyQ, &c, 1);
-            if( !pushOK )
-                logMsg("PMAC reply ring buffer full\n", 0, 0, 0, 0, 0, 0);
-        }
-        hadBell = bell;
-    }
-  }
-
-  /* Write to mailbox register number 1 if there is more data in the response
-     to this command. According to the manual we should be able to do this
-     after receiving any response to pre-enable the next response, but in
-     reality, this doesn't always work */
-
-  if (c != PMAC_TERM_ACK) 
-  {
-      pPmacCtlr->pBase->mailbox.MB[1].data = 0;
-      c = pPmacCtlr->pBase->mailbox.MB[1].data;
-  }
-  epicsEventSignal( pPmacDev->ioReadmeId );
-
-  return;
-}
-
-
-/* We get this interrupt when PMAC has successfully received the data */
-/* we have placed in the Mailbox registers                            */
-
-static void pmacMbxReceivedISR( PMAC_DEV *pPmacDev )
-{
-  /* logMsg("Inside pmacMbxReceivedISR...\n", 0, 0, 0, 0, 0, 0); */
-
-  epicsEventSignal( pPmacDev->ioReceivedId );
-  return;
-}
-
-
-/* This is a test routine for testing Open/Close of multiple PMAC devices
-   without having PMAC cards in the crate */
-
-long pmacVmeConfigSim( int ctlrNumber, unsigned long addrBase, unsigned long addrDpram,
-                       unsigned int irqVector, unsigned int irqLevel )
-{
-  PMAC_CTLR *pPmacCtlr;
-	
-  if( pmacVmeConfigLock != 0 )
-  {
-    printf( "pmacVmeConfigSim: Cannot change configuration after initialization\n" );
-    return(ERROR);
-  }
-  	
-  if( (ctlrNumber < 0) | (ctlrNumber >= PMAC_MAX_CTLRS) )
-  {
-    printf( "pmacVmeConfigSim: Controller number %d invalid -- must be 0 to %d.\n",
-             ctlrNumber, PMAC_MAX_CTLRS-1 );
-    return(ERROR);
-  }
-  
-  if( pmacVmeCtlr[ctlrNumber].configured )
-  {
-    printf( "pmacVmeConfigSim: Controller %d already configured -- request ignored.\n",
-            ctlrNumber );
-    return(ERROR);
-  }
-	
-  pPmacCtlr                = &pmacVmeCtlr[ctlrNumber];
-  pPmacCtlr->ctlr          = ctlrNumber;
-  pPmacCtlr->vmebusBase    = addrBase;
-  pPmacCtlr->irqVector     = irqVector;
-  pPmacCtlr->irqLevel      = irqLevel;
-  pPmacCtlr->enabled       = FALSE;
-  pPmacCtlr->present       = FALSE;
-  pPmacCtlr->active        = FALSE;
-  pPmacCtlr->enabledBase   = TRUE;
-  pPmacCtlr->presentBase   = TRUE;
-  pPmacCtlr->activeBase    = FALSE;
-  pPmacCtlr->enabledDpram  = TRUE;
-  pPmacCtlr->presentDpram  = TRUE;
-  pPmacCtlr->activeDpram   = FALSE;
-  pPmacCtlr->enabledGather = TRUE;
-  pPmacCtlr->activeGather  = FALSE;
-  pPmacCtlr->vmebusDpram   = addrDpram;
-  if( addrDpram == 0 )
-    pPmacCtlr->enabledDpram = FALSE;
-
-  pPmacCtlr->present    = pPmacCtlr->presentBase | pPmacCtlr->presentDpram;
-  pPmacCtlr->enabled    = pPmacCtlr->enabledBase | pPmacCtlr->enabledDpram;
-  pPmacCtlr->configured = TRUE;
-	
-  return(0);
-}
-
-
-#define PMAC_ASYN
-#ifdef PMAC_ASYN
-#include "asynDriver.h"
-#include "drvAsynSerialPort.h"
-#include <epicsExport.h>
-#include <iocsh.h>
-
-int pmacAsynConfig( char * mbx_prefix, char * asc_prefix, unsigned int priority)
-{
-    int i;
-    char devName[32];
-    char asynName[32];
-    static int installedAsynAsc = 0;
-    static int installedAsynMbx = 0;
-
-    pmacDrv();
-
-    if( !installedAsynMbx && mbx_prefix )
-    {
-        /* Add a DPRAM ASCII device for every configured card */
-        for( i=0; i < PMAC_MAX_CTLRS; i++ )
-        {
-            if( pmacVmeCtlr[i].configured )
-            {
-                sprintf( devName,  "/dev/pmac/%d/mbx", pmacVmeCtlr[i].ctlr );
-                sprintf( asynName, "%s%d", mbx_prefix, pmacVmeCtlr[i].ctlr );
-                drvAsynSerialPortConfigure( asynName, devName, priority, 0, 0 );
-            }
-        }
-        installedAsynMbx = 1;
-    }
-
-    if( !installedAsynAsc && asc_prefix )
-    {
-        /* Add a DPRAM ASCII device for every configured card */
-        for( i=0; i < PMAC_MAX_CTLRS; i++ )
-        {
-            if( pmacVmeCtlr[i].configured )
-            {
-                sprintf( devName,  "/dev/pmac/%d/asc", pmacVmeCtlr[i].ctlr );
-                sprintf( asynName, "%s%d", asc_prefix, pmacVmeCtlr[i].ctlr );
-                drvAsynSerialPortConfigure( asynName, devName, priority, 0, 0 );
-            }
-        }
-        installedAsynAsc = 1;
-    }
-
-    return 0;
-}
-
-static const iocshArg pmacAsynConfigArg0 = {"PMAC Mailbox Asyn port prefix",     iocshArgString};
-static const iocshArg pmacAsynConfigArg1 = {"PMAC DPRAM ASCII Asyn port prefix", iocshArgString};
-static const iocshArg pmacAsynConfigArg2 = {"Asyn port priority (0 for default)", iocshArgInt};
-static const iocshArg * const pmacAsynConfigArgs[] = {&pmacAsynConfigArg0, &pmacAsynConfigArg1, &pmacAsynConfigArg2};
- 
-static const iocshFuncDef pmacAsynConfigDef = {"pmacAsynConfig", 3, pmacAsynConfigArgs};
-
-static void pmacAsynConfigCallFunc(const iocshArgBuf *args)
-{
-    pmacAsynConfig(args[0].sval, args[1].sval, args[2].ival);
-}
-
-
-static void pmacAsynConfigRegister(void)
-{
-    iocshRegister(&pmacAsynConfigDef,  pmacAsynConfigCallFunc);
-}
-
-epicsExportRegistrar(pmacAsynConfigRegister);
-
-#endif
diff --git a/pmacApp/src/pmacDriver.h b/pmacApp/src/pmacDriver.h
deleted file mode 100644
index 0579cb3..0000000
--- a/pmacApp/src/pmacDriver.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/*
- *  Implementation of the Open/Close/Read/Write/Ioctl interface to
- *  PMAC DPRAM ASCII and PMAC Mailbox ASCII.
- *
- *  Author: Andy Foster (for Diamond)
- *  Date:   26th May 2006
- *
-*/
-
-#ifndef __INCpmacDriverH
-#define __INCpmacDriverH
-
-STATUS pmacDrv();
-
-#endif
diff --git a/pmacApp/src/pmacError.c b/pmacApp/src/pmacError.c
deleted file mode 100644
index af9782d..0000000
--- a/pmacApp/src/pmacError.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <stdlib.h>
-#include <ctype.h>
-#include <string.h>
-
-static const char * pmacErrors[] = {
-    /* ERR000 */ "No Error",
-    /* ERR001 */ "Command not allowed during program execution \n\t(should halt program execution before issuing command)",
-    /* ERR002 */ "Password error \n\t(should enter the proper password)",
-    /* ERR003 */ "Data error or unrecognized command \n\t(should correct syntax of command)",
-    /* ERR004 */ "Illegal character: bad value (>127 ASCII) or serial parity/framing error \n\t(should correct the character and or check for noise on the serial cable)",
-    /* ERR005 */ "Command not allowed unless buffer is open (should open a buffer first)",
-    /* ERR006 */ "No room in buffer for command \n\t(should allow more room for buffer -- DELETE or CLEAR other buffers)",
-    /* ERR007 */ "Buffer already in use (should CLOSE currently open buffer first)",
-    /* ERR008 */ "MACRO auxiliary communications error \n\t(should check MACRO ring hardware and software setup)",
-    /* ERR009 */ "Program structural error (e.g. ENDIF without IF) \n\t(should correct structure of program)",
-    /* ERR010 */ "Both overtravel limits set for a motor in the C. S. (should correct or disable limits)",
-    /* ERR011 */ "Previous move not completed (should Abort it or allow it to complete)",
-    /* ERR012 */ "A motor in the coordinate system is open-loop (should close the loop on the motor)",
-    /* ERR013 */ "A motor in the coordinate system is not activated \n\t(should set Ix00 to 1 or remove motor from C.S.)",
-    /* ERR014 */ "No motors in the coordinate system (should define at least one motor in C.S.)",
-    /* ERR015 */ "Not pointing to valid program buffer \n\t(should use B command first, or clear out scrambled buffers)",
-    /* ERR016 */ "Running improperly structured program (e.g.missing ENDWHILE) \n\t(should correct structure of program)",
-    /* ERR017 */ "Trying to resume after H or Q with motors out of stopped position \n\t(should use J= to return motor[s] to stopped position)",
-    /* ERR018 */ "Attempt to perform phase reference during move, move during phase reference., or enabling with phase clock error. \n\t(should finish move before phase reference, finish phase reference before move, or fix phase clock source problem)",
-    /* ERR019 */ "Illegal position-change command while moves stored in CCBUFFER \n\t(should pass through section of Program requiring storage of moves in CCBUFFER, or abort)"
-};
-
-static const char * badErrString = "Not a valid PMAC error string";
-static const char * badErrNum = "Not a valid PMAC error number";
-
-const char * pmacError( const char * errStr )
-{
-    const char * result;
-
-    /* Strip any leading BELL */
-    if (*errStr == '\a') errStr++;
-
-    /* Check for correct format */
-    if (strncmp(errStr, "ERR", 3 ) == 0 &&
-	isdigit((int) errStr[3]) && isdigit((int) errStr[4]) && isdigit((int) errStr[5]) )
-    {
-        int errnum = (errStr[3]-'0')*100 + (errStr[4]-'0')*10 + errStr[5]-'0';
-
-        if ( errnum <=0 || errnum > sizeof( pmacErrors ) ) result = badErrNum;
-        else result = pmacErrors[errnum];
-    }
-    else result = badErrString;
-
-    return result;
-}
diff --git a/pmacApp/src/pmacError.h b/pmacApp/src/pmacError.h
deleted file mode 100644
index 7e9fa94..0000000
--- a/pmacApp/src/pmacError.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- *  Implementation of the pmacError call 
- *
- *  Author: Nick Rees
- *  Date:   2 August 2006
- *
-*/
-
-#ifndef __INCpmacErrorH
-#define __INCpmacErrorH
-
-const char * pmacError( const char * errStr );
-
-#endif
diff --git a/pmacApp/src/pmacInclude.dbd b/pmacApp/src/pmacInclude.dbd
deleted file mode 100644
index 78d1ca9..0000000
--- a/pmacApp/src/pmacInclude.dbd
+++ /dev/null
@@ -1,6 +0,0 @@
-
-include "statusRecord.dbd"
-include "statusDevice.dbd"
-
-include "add_pmac.dbd"
-
diff --git a/pmacApp/src/pmacSerial.c b/pmacApp/src/pmacSerial.c
deleted file mode 100644
index 2013124..0000000
--- a/pmacApp/src/pmacSerial.c
+++ /dev/null
@@ -1,388 +0,0 @@
-/* @(#) pmacSerial.c 1.5 96/07/19 */
-
-/* pmacSerial.c -  PMAC Interactive via Serial Port */
-
-/*
- * Author:      Thomas A. Coleman
- * Date:        96/07/19
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
- 
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
- 
-Argonne National Laboratory (ANL), with facilities in the States of 
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods. 
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.  
-
-*****************************************************************
-LICENSING INQUIRIES MAY BE DIRECTED TO THE INDUSTRIAL TECHNOLOGY
-DEVELOPMENT CENTER AT ARGONNE NATIONAL LABORATORY (708-252-2000).
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  06-23-95        tac     initial
- */
-
-/*
- * DESCRIPTION:
- * ------------
- * This module provides interactive access to PMAC via a serial port.
- *
- * INCLUDE FILES:
- *	
- */
-
-/*
- * INCLUDES
- */
-
-/* VxWorks Includes */
-
-#include	<vxWorks.h>
-#include 	<stdlib.h>	/* Sergey */
-#include	<vxLib.h>
-#include	<ioLib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<selectLib.h>
-
-/* local includes */
-
-/*
- * DEFINES
- */
-
-#define PMAC_DIAGNOSTICS TRUE
-#define PMAC_PRIVATE FALSE
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-#if PMAC_DIAGNOSTICS
-#define PMAC_MESSAGE	printf
-#define PMAC_DEBUG(level,code)       { if (pmacSerialDebug >= (level)) { code } }
-#else
-#define PMAC_DEBUG(level,code)      ;
-#endif
-
-#define NO_ERR_STATUS	(-1)
-
-#define PMAC_DEFAULT_TTY	"/tyCo/1"
-#define PMAC_DEFAULT_BAUD	38400
-
-#define PMAC_MAX_COMMAND	(255)
-#define PMAC_MAX_RESPONSE	(1024)
-
-#define ACK	0x06
-#define BELL	0x07
-#define CR	0x0D
-#define CONTROL_X	0x18
-#define CONTROL_Z	0x1A
-
-/*
- * TYPEDEFS
- */
-
-
-/*
- * FORWARD DECLARATIONS
- */
-
-
-/*
- * GLOBALS
- */
-
-char * pmacSerialVersion = "@(#) pmacSerial.c 1.5 96/07/19";
-
-#if PMAC_DIAGNOSTICS
-volatile int pmacSerialDebug = 0;
-#endif
-
-/*
- * LOCALS
- */
-
-
-/*******************************************************************************
- *
- * pmacSerial - provide interative access to PMAC via serial port
- *
- */
-int pmacSerial
-(
-	char *	ttyDevice,
-	int	ttyBaud
-)
-{
-	char *	MyName	= "pmacSerial";
-	char *	ttyDefault = PMAC_DEFAULT_TTY;
-	int	i;
-	int	status;
-	int	bytesRead;
-	int	bytesUnread;
-	int	maxBytes;
-	int	fdPmac;
-	fd_set	fdset;
-	int	valid;
-	int	invalid;
-	int	errnum;
-	int	exitNow;
-	FILE *	fpInput;
-	FILE *	fpOutput;
-	char *	commandBuffer;
-	char *	responseBuffer;
-	
-	/* Open Standard Input */
-	fpInput = fdopen (0, "r");
-	if (fpInput == (FILE *) NULL)
-	{
-		printErr ("%s: Unable to open standard input\n", MyName);
-		exit (ERROR);
-	}
-
-	/* Open Standard Output */
-	fpOutput = fdopen (1, "a");
-	if (fpOutput == (FILE *) NULL)
-	{
-		printErr ("%s: Unable to open standard output\n", MyName);
-		exit (ERROR);
-	}
-
-	/* Open User-Specified or Default Serial Device */
-	if (ttyDevice != (char *) NULL)
-	{
-		fdPmac = open (ttyDevice, O_RDWR, (int)NULL);
-		if (fdPmac == ERROR)
-		{
-			printErr ("%s: Unable to open device %s\n",
-					MyName, ttyDevice);
-			exit (ERROR);
-		}
-	}
-	else
-	{
-		fdPmac = open (ttyDefault, O_RDWR, (int)NULL);
-		if (fdPmac == ERROR)
-		{
-			printErr ("%s: Unable to open default device %s\n",
-					MyName, ttyDefault);
-			exit (ERROR);
-		}
-	}
-	
-	/* Set Serial TTY Options */
-	status = ioctl (fdPmac, FIOSETOPTIONS, OPT_RAW);
-	if (status == ERROR)
-	{
-		printErr ("%s: Unable to set device options\n", MyName);
-		exit (status);
-	}
-
-	/* Set User-Specified or Default Baud Rate */
-	if (ttyBaud != 0)
-	{
-		status = ioctl (fdPmac, FIOBAUDRATE, ttyBaud);
-		if (status == ERROR)
-		{
-			printErr ("%s: Unable to set baudrate %d\n",
-					MyName, ttyBaud);
-			exit (status);
-		}
-	}
-	else
-	{
-		status = ioctl (fdPmac, FIOBAUDRATE, PMAC_DEFAULT_BAUD);
-		if (status == ERROR)
-		{
-			printErr ("%s: Unable to set default baudrate\n",
-					MyName, PMAC_DEFAULT_BAUD);
-			exit (status);
-		}
-	}
-	
-	/* Flush Input And Output Buffers */
-	status = ioctl (fdPmac, FIOFLUSH, 0);
-	if (status == ERROR)
-	{
-		printErr ("%s: Unable to flush buffers\n", MyName);
-		exit (status);
-	}
-
-	/* Allocate String Buffers */
-	commandBuffer = (char *) malloc (PMAC_MAX_COMMAND);
-	responseBuffer = (char *) malloc (PMAC_MAX_RESPONSE);
-	
-	exitNow = FALSE;
-
-	/* Get Command String */
-	status = (int) fgets (commandBuffer, PMAC_MAX_COMMAND, fpInput);
-	if (status == (int)NULL)
-	{
-		exitNow = TRUE;
-	}
-
-	/* Loop Until Exit */
-	while ( !exitNow )
-	{
-
-		/* Write String To PMAC Prefixed By Control-Z */
-		status = fdprintf (fdPmac, "%c%s\r", CONTROL_Z, commandBuffer);
-		if (status == ERROR)
-		{
-			printErr ("%s: Error during ouptut\n", MyName);
-			return (status);
-		}
-		
-		/* Loop Until Response Is Acknowledged */
-		valid = FALSE;
-		invalid = FALSE;
-		errnum = FALSE;
-		while ( !valid && !(invalid && errnum) )
-		{
-		
-			/* Clear File Descriptor Set */
-			FD_ZERO (&fdset);
-		
-			/* Loop Until We Have Data Available */
-			while ( !FD_ISSET (fdPmac, &fdset) )
-			{
-
-				/* Pend Until Device Has Data */
-				FD_SET (fdPmac, &fdset);
-				status = select (FD_SETSIZE, &fdset, NULL, NULL, NULL);
-		
-				if (status == ERROR)
-				{
-					printErr ("%s: Error occured during select\n", MyName);
-					return (status);
-				}
-				else if (status == 0)
-				{
-					printErr ("%s: Timed out\n", MyName);
-				}
-			}
-
-			/* Determine Number Of Unread Bytes */
-			status = ioctl (fdPmac, FIONREAD, (int) &bytesUnread);
-			if (status == ERROR)
-			{
-				printErr ("%s: Error determining number of bytes\n",
-					MyName);
-			}
-		
-			/* Read Bytes */
-			maxBytes = min (bytesUnread, PMAC_MAX_RESPONSE);
-			if (maxBytes == 0)
-			{
-				printErr ("%s: maxBytes = %d\n", MyName, maxBytes);
-			}
-			bytesRead = read (fdPmac, responseBuffer, maxBytes);
-			if (bytesRead == ERROR)
-			{
-				printErr ("%s: Error occured during read\n", MyName);
-				return (bytesRead);
-			}
-			else if (bytesRead == 0)
-			{
-				printErr ("%s: End of File\n", MyName);
-			}
-
-			/* Write Response To Standard Out */
-			for (i=0; i<bytesRead; i++)
-			{
-				if ( responseBuffer[i] == ACK )
-				{
-					valid = TRUE;
-				}
-				else if ( responseBuffer[i] == BELL )
-				{
-					fprintf (fpOutput, "[");
-					invalid = TRUE;
-				}
-				else if ( responseBuffer[i] == CR )
-				{
-					if (invalid)
-					{
-						fprintf (fpOutput, "]\n");
-						errnum = TRUE;
-					}
-					else
-					{
-						fprintf (fpOutput, "\n");
-					}
-				}
-				else
-				{
-					fprintf (fpOutput, "%c", responseBuffer[i]);
-				}
-			}
-		}
-		
-		/* Command Has Been Acknowledged */
-
-		/* Get Next Command */
-		status = (int) fgets (commandBuffer, PMAC_MAX_COMMAND, fpInput);
-		if (status == (int)NULL)
-		{
-			exitNow = TRUE;
-		}
-
-	}
-	
-	/* Stop On End Of File */
-	
-	status = fclose (fpInput);
-	status = fclose (fpOutput);
-	status = close (fdPmac);
-	if (status == ERROR)
-	{
-		printErr ("%s: Unable to close device\n", MyName);
-		exit (status);
-	}
-
-	return (0);
-}
diff --git a/pmacApp/src/pmacVme.c b/pmacApp/src/pmacVme.c
deleted file mode 100644
index d55d206..0000000
--- a/pmacApp/src/pmacVme.c
+++ /dev/null
@@ -1,1051 +0,0 @@
-/* pmacVme.c -  EPICS Device Driver Library for Turbo PMAC2-VME Ultralite
- *
- * Author       Oleg A. Makarov
- *              Thomas A. Coleman's PMAC-VME driver library was used as a prototype 
- * Date:        2003/08/19
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
- 
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
- 
-Argonne National Laboratory (ANL), with facilities in the States of 
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods. 
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.  
-
-*****************************************************************
-LICENSING INQUIRIES MAY BE DIRECTED TO THE INDUSTRIAL TECHNOLOGY
-DEVELOPMENT CENTER AT ARGONNE NATIONAL LABORATORY (630-252-2000).
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- * .02  8-19-03       oam     Turbo PMAC2-VME Ultralite initial
- * .03  26th May 2006 ajf     Add DPRAM ASCII semaphore and ISR.
- *                            Comment out vxMemProbe of mailbox registers
- *                            as this causes an MVME-5500 to hang.
- */
-
-/*
- * DESCRIPTION:
- * ------------
- * This module drives PMAC-VME.
- *
- */
-
-/*
- * INCLUDES
- */
-
-/* VxWorks Includes */
-
-#include	<vxWorks.h>
-#include	<vxLib.h>
-#include	<sysLib.h>
-#include	<taskLib.h>
-#include	<iv.h>
-#include	<math.h>
-#include	<stdio.h>	/* Sergey */
-#include	<string.h>	/* Sergey */
-#define __PROTOTYPE_5_0         /* Sergey */
-#include        <logLib.h>      /* Sergey */
-
-/* EPICS Includes */
-
-#include 	<devLib.h>
-#include 	<errMdef.h>
-
-#include <pmacVme.h>
-
-/*
- * DEFINES
- */
-
-#define PMAC_DIAGNOSTICS TRUE
-#define PMAC_PRIVATE FALSE
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-#if PMAC_DIAGNOSTICS
-#define PMAC_MESSAGE	logMsg
-#define PMAC_DEBUG(level,code)       { if (pmacVmeDebug >= (level)) { code } }
-#else
-#define PMAC_DEBUG(level,code)      ;
-#endif
-
-#define NO_ERR_STATUS	(-1)
-
-#define PMAC_BUFSIZE	(80)
-
-#define PMAC_MEM_SIZE_BASE	(0x200)		/* Size of base registers */
-#define PMAC_MEM_SIZE_DPRAM	(0x4000)	/* Size of DPRAM */
-
-#define PMAC_BASE_MBX_REGS_OUT	(15)
-#define PMAC_BASE_MBX_REGS_IN	(16)
-
-#define BYTESWAP(x) (MSB(x) | (LSB(x) << 8))
-
-/*
- * GLOBALS
- */
-
-char * pmacVmeVersion = "@(#) pmacVme.c 1.6 97/05/06";
-
-#if PMAC_DIAGNOSTICS
-volatile int	pmacVmeDebug = 0;		/* must be > 0 to see messages */
-#endif
-
-/*
- * LOCALS
- */
-
-           int          pmacVmeConfigLock = 0;
-PMAC_LOCAL int          pmacVmeNumCtlrs = 0;
-PMAC_LOCAL PMAC_CTLR    pmacVmeCtlr[PMAC_MAX_CTLRS];
-
-void pmacVmeReport( int card, int level )
-{
-    PMAC_CTLR	*pCtlr = &pmacVmeCtlr[card];
-
-    printf ("    vmebusBase = 0x%lX  hostBase = %p  vmebusDpram = 0x%lX  hostDpram = %p\n",
-	    pCtlr->vmebusBase, pCtlr->pBase,
-	    pCtlr->vmebusDpram, pCtlr->pDpramBase);
-    printf ("    irqVector = 0x%X  irqLevel = %d\n",
-	    pCtlr->irqVector, pCtlr->irqLevel);
-}
-
-/*******************************************************************************
- *
- * pmacVmeConfig - Configure PMAC-VME Controller Addresses and Interrupts
- *
- * This routine is to be called in the startup script in order to init the
- * controller addresses and the associated IRQ vectors and levels.
- *
- * By default there are no controllers configured.
- *
- */
-long pmacVmeConfig
-(
-	int		ctlrNumber,
-	unsigned long	addrBase,
-	unsigned long	addrDpram,
-	unsigned int	irqVector,
-	unsigned int	irqLevel
-)
-{
-	char *		MyName = "pmacVmeConfig";
-	int		i;
-	long		val;
-	char		block;
-	volatile char	*pBlock;
-	long		status;
-	PMAC_CTLR *	pPmacCtlr;
-	
-	if (pmacVmeConfigLock != 0)
-	{
-		printf ( "%s: Cannot change configuration after initialization -- request ignored.\n",
-			MyName);
-		return (ERROR);
-	}
-  
-	if ( pmacVmeNumCtlrs == 0 )
-	{
-		for (i=0; i < PMAC_MAX_CTLRS; i++ )
-		{
-			pmacVmeCtlr[i].configured = FALSE;
-		}
-	}
-	
-	if ( (ctlrNumber < 0) | (ctlrNumber >= PMAC_MAX_CTLRS) )
-	{
-		printf ("%s: Controller number %d invalid -- must be 0 to %d.\n",
-			MyName, ctlrNumber, PMAC_MAX_CTLRS - 1);
-		return(ERROR);
-	}
-  
-	if (pmacVmeCtlr[ctlrNumber].configured)
-	{
-		printf ("%s: Controller %d already configured -- request ignored.\n",
-			MyName, ctlrNumber);
-		return(ERROR);
-	}
-	
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: Initializing controller %d.\n", MyName, ctlrNumber);
-	)
-
-	pPmacCtlr = &pmacVmeCtlr[ctlrNumber];
-	pPmacCtlr->ctlr = ctlrNumber;
-	pPmacCtlr->vmebusBase = addrBase;
-	pPmacCtlr->irqVector = irqVector;
-	pPmacCtlr->irqLevel = irqLevel;
-	
-	pPmacCtlr->enabled = FALSE;
-	pPmacCtlr->present = FALSE;
-	pPmacCtlr->active = FALSE;
-	pPmacCtlr->enabledBase = TRUE;
-	pPmacCtlr->presentBase = FALSE;
-	pPmacCtlr->activeBase = FALSE;
-	pPmacCtlr->enabledDpram = TRUE;
-	pPmacCtlr->presentDpram = FALSE;
-	pPmacCtlr->activeDpram = FALSE;
-	pPmacCtlr->enabledGather = TRUE;
-	pPmacCtlr->activeGather = FALSE;
-
-	pPmacCtlr->vmebusDpram = addrDpram;
-	if ( addrDpram == 0 )
-	{
-		pPmacCtlr->enabledDpram = FALSE;
-	}
-			
-	status = devRegisterAddress ("PMAC BASE", atVMEA24,
-				pPmacCtlr->vmebusBase, PMAC_MEM_SIZE_BASE,
-				(void *) &(pPmacCtlr->pBase));
-	if (!RTN_SUCCESS(status))
-	{
-		printf ("%s: Failure registering controller %d base address A24 %#010x.\n",
-			MyName, pPmacCtlr->ctlr, (int)pPmacCtlr->vmebusBase);
-		return (status);
-	}
-	
-	/*Oleg: selecting lines A19-A14 for the DPRAM */
-	/* pPmacCtlr->pBase->mailbox.MB[144].data = 0x3F & (pPmacCtlr->vmebusBase>>14); */
-		
-#if 0
-  ajf: This line causes an MVME-5500 to hang.
-
-	status = vxMemProbe ((char*) &pPmacCtlr->pBase->mailbox.MB[0].data,
-				VX_READ, 1, (char*)&val);
-	if (status != OK)
-	{
-		printf ("%s: Failure probing for base address.\n",
-			MyName);
-		return (status);
-	}
-#endif
-
-	pPmacCtlr->presentBase = TRUE;
-
-	if ( pPmacCtlr->enabledDpram )
-	{
-		status = devRegisterAddress ("PMAC DPRAM", atVMEA24,
-					pPmacCtlr->vmebusDpram, PMAC_MEM_SIZE_DPRAM,
-					(void *) &(pPmacCtlr->pDpramBase));
-		if (!RTN_SUCCESS(status))
-		{
-			printf ("%s: Failure registering controller %d DPRAM address A24 %#010x.\n",
-				MyName, (int)pPmacCtlr->ctlr, (int)pPmacCtlr->vmebusDpram);
-			return (status);
-		}
-	
-		block = (char) ((pPmacCtlr->vmebusDpram & 0x000fc000) >> 14);
-		pBlock = ((char *) pPmacCtlr->pBase) + 0x121;
-
-		PMAC_DEBUG
-		(	1,
-			printf ("%s: Setting DPRAM mapping addr %#010lx val %d\n",
-				MyName, (long)pBlock, block);
-		)
-			
-		*pBlock = block;
-			
-		status = vxMemProbe ( (char *) pPmacCtlr->pDpramBase, VX_READ, 2, (char*)&val);
-		if (status != OK)
-		{
-			printf ("%s: Failure probing for DPRAM address: 0x%x\n",
-				MyName, (int) pPmacCtlr->pDpramBase);
-			return (status);
-		}
-		pPmacCtlr->presentDpram = TRUE;
-	}
-	
-	pPmacCtlr->ioMbxReceiptSem = semBCreate (SEM_Q_FIFO, SEM_EMPTY);
-	if ( pPmacCtlr->ioMbxReceiptSem == NULL)
-	{
-		status = S_dev_internal;
-		printf ("%s: Failure creating ioMbxReceiptSem binary semaphore.\n",
-			MyName);
-		return (status);
-	}
-
-	pPmacCtlr->ioMbxReadmeSem = semBCreate (SEM_Q_FIFO, SEM_EMPTY);
-	if ( pPmacCtlr->ioMbxReadmeSem == NULL)
-	{
-		status = S_dev_internal;
-		printf ("%s: Failure creating ioMbxReadmeSem binary semaphore.\n",
-			MyName);
-		return (status);
-	}
-
-	pPmacCtlr->ioMbxLockSem = semBCreate (SEM_Q_FIFO, SEM_EMPTY);
-	if ( pPmacCtlr->ioMbxLockSem == NULL)
-	{
-		status = S_dev_internal;
-		printf ("%s: Failure creating ioMbxLockSem binary semaphore.\n",
-			MyName);
-		return (status);
-	}
-			
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: Connecting to interrupt vector %d\n",
-				MyName, pPmacCtlr->irqVector - 1);
-	)
-
-	status = devConnectInterruptVME (pPmacCtlr->irqVector - 1,
-				(void *)pmacMbxReceiptISR, (void *) pPmacCtlr);
-	if (!RTN_SUCCESS(status))
-	{
-		printf ("%s: Failure to connect interrupt.\n",
-			MyName);
-		return (status);
-	}
-			
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: Connecting to interrupt vector %d\n",
-				MyName, pPmacCtlr->irqVector);
-	)
-
-	status = devConnectInterruptVME (pPmacCtlr->irqVector,
-				(void *)pmacMbxReadmeISR, (void *) pPmacCtlr);
-	if (!RTN_SUCCESS(status))
-	{
-		printf ("%s: Failure to connect interrupt.\n",
-			MyName);
-		return (status);
-	}
-
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: Enabling interrupt level %d\n",
-				MyName, pPmacCtlr->irqLevel);
-	)
-
-        status = devEnableInterruptLevel (intVME, pPmacCtlr->irqLevel);
-	if (!RTN_SUCCESS(status))
-	{
-		printf ("%s: Failure to enable interrupt level.\n",
-			MyName);
-		return (status);
-	}
-			
-	pPmacCtlr->present = pPmacCtlr->presentBase | pPmacCtlr->presentDpram;
-	pPmacCtlr->enabled = pPmacCtlr->enabledBase | pPmacCtlr->enabledDpram;
-	pPmacCtlr->configured = TRUE;
-	pmacVmeNumCtlrs++;
-	
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: presentbase = %d, presentDpram=%d, therfore present=%d\n",
-				MyName,
-			        pPmacCtlr->presentBase,
-			        pPmacCtlr->presentDpram,
-			        pPmacCtlr->present);
-	)
-
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: enabledBase = %d, enabledDpram=%d, therefore enabled=%d\n",
-				MyName,
-			        pPmacCtlr->enabledBase,
-			        pPmacCtlr->enabledDpram,
-			        pPmacCtlr->enabled);
-	)
-
-	PMAC_DEBUG
-	(	1,
-		printf ("%s: pmacVmeNumCtlrs =  %d and  PMAC_MAX_CTLRS = %d\n",
-			       	MyName,
-			       	pmacVmeNumCtlrs,
-			        PMAC_MAX_CTLRS);
-	)
-
-	return(0);
-}
-
-/*******************************************************************************
- *
- * pmacVmeInit - Initialize PMAC-VME Hardware Configuration
- *
- */
-PMAC_LOCAL long pmacVmeInit (void)
-{
-	/* char *	MyName = "pmacVmeInit"; */
-	int		i;
-	PMAC_CTLR	*pPmacCtlr;
-	STATUS		semStatus;
-	
-	pmacVmeConfigLock = 1;
-
-	if ( pmacVmeNumCtlrs == 0 )
-	{
-		return (0);
-	}
-	
-	for ( i=0; i < PMAC_MAX_CTLRS; i++)
-	{
-		pPmacCtlr = &pmacVmeCtlr[i];
-
-		if ( pPmacCtlr->configured )
-		{
-			if ( pPmacCtlr->presentBase & pPmacCtlr->enabledBase )
-			{
-				semStatus=semGive (pPmacCtlr->ioMbxLockSem);
-				printf ("pmacVmeInit: semStatus=%d, card=%d \n",semStatus, i);	
-				pPmacCtlr->activeBase = TRUE;
-			}
-			
-			if ( pPmacCtlr->presentDpram & pPmacCtlr->enabledDpram )
-			{
-				pPmacCtlr->activeDpram = TRUE;
-			}
-
-			if ( pPmacCtlr->activeDpram & pPmacCtlr->enabledGather )
-			{
-				pPmacCtlr->activeGather = TRUE;
-			}
-
-			pPmacCtlr->active = pPmacCtlr->activeBase | pPmacCtlr->activeDpram;
-		}
-	}	
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacMbxReceiptISR - interrupt service routine for mailbox receipt acknowledge
- *
- */
-PMAC_LOCAL void pmacMbxReceiptISR
-(
-	PMAC_CTLR	*pPmacCtlr
-)
-{
-	char *	MyName = "pmacMbxReceiptISR";
-	STATUS	semStatus;
-
-	PMAC_DEBUG
-	(	10,
-		PMAC_MESSAGE ("%s: PMAC IRQ MbxReceipt for ctlr %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	)
-	
-	semStatus=semGive (pPmacCtlr->ioMbxReceiptSem);
-	if ( semStatus ) {
-	   PMAC_MESSAGE ("%s: semStatus=%d card=%d\n", MyName, semStatus, pPmacCtlr->ctlr,0,0,0); 
-	}
-	
-	return;
-}
-
-/*******************************************************************************
- *
- * pmacMbxReadmeISR - interrupt service routine for mailbox message arrival
- *
- */
-PMAC_LOCAL void pmacMbxReadmeISR
-(
-	PMAC_CTLR	*pPmacCtlr
-)
-{
-	char *	MyName = "pmacMbxReadmeISR";
-
-	PMAC_DEBUG
-	(	10,
-		PMAC_MESSAGE ("%s: PMAC IRQ MbxReadme for ctlr %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	)
-	
-	semGive (pPmacCtlr->ioMbxReadmeSem);
-	
-	return;
-}
-
-/*******************************************************************************
- *
- * pmacMbxOut - put characters in PMAC mailbox
- *
- */
-PMAC_LOCAL char pmacMbxOut
-(
-	int	ctlr,
-	char	*writebuf
-)
-{
-    /* char *	MyName = "pmacMbxOut"; */
-    int		i;
-    int		length;
-    char	firstcharacter;
-    char	termination;
-    PMAC_CTLR	*pPmacCtlr;
-
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-    termination = 0;
-    length = strlen (writebuf);
-
-    firstcharacter = writebuf[0];
-
-    for (i = 1; (i < length) && (i < PMAC_BASE_MBX_REGS_OUT); i++)
-    {
-	pPmacCtlr->pBase->mailbox.MB[i+1].data = writebuf[i];
-    }
-
-    if ((i == length) && (i < PMAC_BASE_MBX_REGS_OUT))
-    {
-	termination = PMAC_TERM_CR;
-	pPmacCtlr->pBase->mailbox.MB[i+1].data = PMAC_TERM_CR;
-    }
-    else if (i > length)
-    {
-	termination = PMAC_TERM_CR;
-	firstcharacter = PMAC_TERM_CR;
-    }
-    pPmacCtlr->pBase->mailbox.MB[0].data = firstcharacter;
-
-    return (termination);
-
-}   
-
-/*******************************************************************************
- *
- * pmacMbxIn - get characters from PMAC mailbox
- *
- */
-PMAC_LOCAL char pmacMbxIn
-(
-	int	ctlr,
-	char	*readbuf,
-	char	*errmsg
-)
-{
-    /* char *	MyName = "pmacMbxIn"; */
-    int		i;
-    int		j;
-    char	chr;
-    char	terminator;
-    char	terminext;
-    PMAC_CTLR	*pPmacCtlr;
-
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-    
-    terminator = 0;
-    terminext = 0;
-    errmsg[0] = '\0';
-
-    for (i = 0; (i < PMAC_BASE_MBX_REGS_IN) && (terminator == 0); i++)
-    {
-	chr = pPmacCtlr->pBase->mailbox.MB[i].data;
-
-	if (chr == PMAC_TERM_CR || chr == PMAC_TERM_ACK || chr == PMAC_TERM_BELL)
-	{
-	    terminator = chr;
-	    readbuf[i] = '\0';
-	    if (terminator == PMAC_TERM_BELL)
-	    {
-		for (j=0, i++; (i < PMAC_BASE_MBX_REGS_IN) && (terminext == 0); j++, i++)
-		{
-		    chr = pPmacCtlr->pBase->mailbox.MB[i].data;
-		    if (chr == PMAC_TERM_CR)
-		    {
-			terminext = chr;
-			errmsg[j] = '\0';
-		    }
-		    else
-		    {
-			errmsg[j] = chr;
-		    }
-		}
-	    }
-	}
-	else
-	{
-	     readbuf[i] = chr;
-	}
-    }
-
-    return (terminator);
-}
-
-
-
-/*******************************************************************************
- *
- * pmacMbxRead - read response from PMAC mailbox
- *
- */
-PMAC_LOCAL char pmacMbxRead
-(
-	int	ctlr,
-	char	*readbuf,
-	char	*errmsg
-)
-{
-    char *	MyName = "pmacMbxRead";/*  */
-    int		i;
-    char	terminator;
-    PMAC_CTLR	*pPmacCtlr;
-    STATUS stat;
-    
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-    
-    i = 0;
-    terminator = 0;
-
-    while ( terminator == 0)
-    {
-	pPmacCtlr->pBase->mailbox.MB[1].data = 0;
-	stat = semTake( pPmacCtlr->ioMbxReadmeSem, WAIT_TIMEOUT);
-	if (stat == S_objLib_OBJ_TIMEOUT) PMAC_MESSAGE ("%s: PMAC MBX README FAILED, controller: %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	terminator = pmacMbxIn (ctlr, &readbuf[i], errmsg);
-	i += PMAC_BASE_MBX_REGS_IN;
-    }
-
-    return (terminator);
-}
-
-
-
-/*******************************************************************************
- *
- * pmacMbxWrite - write command to PMAC mailbox
- *
- */
-PMAC_LOCAL char pmacMbxWrite
-(
-	int	ctlr,
-	char	*writebuf
-)
-{
-    char *	MyName = "pmacMbxWrite";/*  */
-    int		i;
-    char	terminator;
-    PMAC_CTLR	*pPmacCtlr;
-    STATUS stat;
-    
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-
-    i = 0;
-    terminator = 0;
-
-    while ( terminator == 0 ) 
-    {
-	terminator = pmacMbxOut (ctlr, &writebuf[i]);
-	stat = semTake (pPmacCtlr->ioMbxReceiptSem, WAIT_TIMEOUT);
-	if (stat == S_objLib_OBJ_TIMEOUT) PMAC_MESSAGE ("%s: PMAC MBX RECEIPT FAILED, controller: %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	i += PMAC_BASE_MBX_REGS_OUT;
-    }
-
-    return (terminator);
-
-}   
-
-/*******************************************************************************
- *
- * pmacMbxLock - Lock PMAC mailbox for ctlr
- *
- */
-long pmacMbxLock
-(
-	int	ctlr
-)
-{
-    char *	MyName = "pmacMbxLock";
-    STATUS stat;
-    PMAC_CTLR	*pPmacCtlr;
-
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-	PMAC_DEBUG
-	(	7,
-		PMAC_MESSAGE ("%s: PMAC MBX LOCK %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	)
-    
-    stat = semTake (pPmacCtlr->ioMbxLockSem, WAIT_TIMEOUT);
-    if (stat == S_objLib_OBJ_TIMEOUT) PMAC_MESSAGE ("%s: PMAC MBX LOCK FAILED, controller: %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-    return (0);
-}
-
-/*******************************************************************************
- *
- * pmacMbxUnlock - Unlock PMAC mailbox for ctlr
- *
- */
-long pmacMbxUnlock
-(
-	int	ctlr
-)
-{
-    char *	MyName = "pmacMbxUnlock";
-    PMAC_CTLR	*pPmacCtlr;
-
-    pPmacCtlr = &pmacVmeCtlr[ctlr];
-	PMAC_DEBUG
-	(	7,
-		PMAC_MESSAGE ("%s: PMAC MBX UNLOCK %d\n", MyName, pPmacCtlr->ctlr,0,0,0,0);
-	)
-    
-    semGive (pPmacCtlr->ioMbxLockSem);
-    return (0);
-}
-
-/*******************************************************************************
- *
- * pmacVmeWriteC - write character
- *
- */
-char pmacVmeWriteC
-(
-	char *addr,
-	char val
-)
-{
-	*addr = val;
-	return 0;
-}
-
-/*******************************************************************************
- *
- * pmacVmeReadC - read character
- *
- */
-char pmacVmeReadC
-(
-	char *addr
-)
-{
-	return (*addr);
-}
-
-/*******************************************************************************
- *
- * pmacRamAddr - get DPRAM address
- *
- */
-PMAC_DPRAM * pmacRamAddr
-(
-	int	ctlr,
-	int	offset
-)
-{
-	PMAC_CTLR *	pCtlr = &pmacVmeCtlr[ctlr];
-	PMAC_DPRAM *	pDpram = (PMAC_DPRAM *) (pCtlr->pDpramBase + offset);
-	
-	PMAC_DEBUG
-	(	2,
-		PMAC_MESSAGE ("pmacRamAddr:  Controller #%d, at base %#X with offset %#X = address a24 %#010X \n",
-			      ctlr, pCtlr->pDpramBase, offset, pDpram,0,0);
-	)
-/* This is a workaround to restore PMAC clock synchronization in case of 2 PMACS -- Sergey, Oleg 2006.01.30 */
-/* (At the end of IOC startup script set pmacVmeDebug=1 for about 2s and 6s after booting IOC) */
-	PMAC_DEBUG
-	(	1,
-		PMAC_MESSAGE ("pmacRamAddr:  Controller #%d\n",ctlr,0,0,0,0,0);
-		/* PMAC_MESSAGE ("\n",0,0,0,0,0,0); */
-		/* printf ("pmacRamAddr:  Controller #%d\n",ctlr); */
-		/* printf ("pmacRamAddr:  Controller #%d, at base %#X with offset %#X = address a24 %#010X \n",
-			      ctlr, (int)pCtlr->pDpramBase, offset, (int)pDpram); */
-	)
-
-
-	return (pDpram);
-}
-	
-/*******************************************************************************
- *
- * pmacRamGet16 - get DPRAM 16 bits
- *
- */
-PMAC_LOCAL long pmacRamGet16
-(
-	PMAC_DPRAM *	pDpram,
-	long *		pVal
-)
-{
-	union {
-	      char	ram[4];
-	      long	val0;
-	} lval;
-	
-	/* Read PMAC DPRAM */
-	lval.ram[0] = (char)0;
-	lval.ram[1] = (char)0;
-	lval.ram[2] = pDpram[1];
-	lval.ram[3] = pDpram[0];
-	
-	/* Return value */
-	*pVal = lval.val0;
-	
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamPut16 - put DPRAM 16 bits
- *
- */
-PMAC_LOCAL long pmacRamPut16
-(
-	PMAC_DPRAM *	pDpram,
-	long 		val
-)
-{
-	union {
-	      char	ram[4];
-	      long	val0;
-	} lval;
-	
-	/* User value */
-	lval.val0 = val;
-	
-	/* Write PMAC DPRAM */
-	pDpram[1] = lval.ram[2];
-	pDpram[0] = lval.ram[3];
-	
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamGet24U - get DPRAM 24 bits unsigned
- *
- */
-PMAC_LOCAL long pmacRamGet24U
-(
-	PMAC_DPRAM *	pDpram,
-	long * 		pVal
-)
-{
-	union {
-	      char	ram[4];
-	      long	val0;
-	} lval;
-
-	/* Read PMAC DPRAM */
-	lval.ram[0] = (char)0;
-	lval.ram[1] = pDpram[2];
-	lval.ram[2] = pDpram[1];
-	lval.ram[3] = pDpram[0];
-		
-	/* Return value */
-	*pVal = lval.val0;
-	
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamGet24 - get DPRAM 24 bits
- *
- */
-PMAC_LOCAL long pmacRamGet24
-(
-	PMAC_DPRAM *	pDpram,
-	long *		pVal
-)
-{
-	long	val0;
-
-	/* Read PMAC DPRAM */
-	pmacRamGet24U (pDpram, &val0);
-
-	if (val0 & 0x800000) val0 |= 0xff000000;
-		
-	/* Return value */
-	*pVal = val0;
-	
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamPut32 - put DPRAM 32 bits
- *
- */
-PMAC_LOCAL long pmacRamPut32
-(
-	PMAC_DPRAM *	pDpram,
-	long 		val
-)
-{
-	union {
-	      char	ram[4];
-	      long	val0;
-	} lval;
-
-	/* User value */
-	lval.val0 = val;	
-
-	
-	/* Write PMAC DPRAM */
-	pDpram[3] = lval.ram[0];
-	pDpram[2] = lval.ram[1];
-	pDpram[1] = lval.ram[2];
-	pDpram[0] = lval.ram[3];
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamGetF - get DPRAM F word
- *
- */
-PMAC_LOCAL long pmacRamGetF
-(
-	PMAC_DPRAM *	pDpram,
-	double *	pVal
-)
-{
-	union {
-	      char	ram[4];
-	      float	valF;
-	} lval;
-
-	/* Read PMAC DPRAM */
-	lval.ram[0] = pDpram[3];
-	lval.ram[1] = pDpram[2];
-	lval.ram[2] = pDpram[1];
-	lval.ram[3] = pDpram[0];
-
-	/* Return value */
-	*pVal = (double) lval.valF;
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamPutF - put DPRAM F word
- *
- */
-PMAC_LOCAL long pmacRamPutF
-(
-	PMAC_DPRAM *	pDpram,
-	double		val
-)
-{
-	union {
-	      char	ram[4];
-	      float	valF;
-	} lval;
-
-	/* User value */
-	lval.valF = (float) val;
-	
-	/* Write PMAC DPRAM */
-	pDpram[3] = lval.ram[0];
-	pDpram[2] = lval.ram[1];
-	pDpram[1] = lval.ram[2];
-	pDpram[0] = lval.ram[3];
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamGetD - get DPRAM D word
- *
- */
-PMAC_LOCAL long pmacRamGetD
-(
-	PMAC_DPRAM *	pDpram,
-	double *	pVal
-)
-{
-
-	long	val0;
-	long	val1;
-	
-	pmacRamGet24U (pDpram, &val0);
-	pmacRamGet24 (&(pDpram[4]), &val1);
-
-	/* Convert 48 bit fixed-point format */
-	/* Return value */
-	*pVal = ((double)val1) * 0x1000000 + (double) val0;
-
-	return (0);
-}
-
-/*******************************************************************************
- *
- * pmacRamGetL - get DPRAM L word
- *
- * mantissa/2^35 * 2^(exp-$7ff)
- */
-PMAC_LOCAL long pmacRamGetL
-(
-	PMAC_DPRAM *	pDpram,
-	double *	pVal
-)
-{
-	long	val0;
-	long	val1;
-	double		mantissa	= 0.0;
-	long int	exponent	= 0;
-	double	valD;
-
-	/* Read PMAC DPRAM */
-	pmacRamGet24U (pDpram, &val0);
-	pmacRamGet24U (&(pDpram[4]), &val1);
-	
-	/* Convert 48 bit floating point format */
-	mantissa = ((double)(val1 & 0x00000fff)) * 0x1000000 + (double) val0;
-	exponent = ((val1 >> 12) & 0x00000fff) - 2082;  /* 0x7ff + 35 */
-	
-	if (mantissa == 0.0)
-	{
-		valD = 0.0;
-	}
-	else
-	{
-		valD = mantissa * pow (2.0, (double) exponent);
-	}
-
-	/* Return value */
-	*pVal = valD;
-
-	return (0);
-}
diff --git a/pmacApp/src/pmacVme.h b/pmacApp/src/pmacVme.h
deleted file mode 100644
index 9880303..0000000
--- a/pmacApp/src/pmacVme.h
+++ /dev/null
@@ -1,176 +0,0 @@
-/* @(#) pmacVme.h 1.5 97/05/06 */
-
-/* pmacVme.h -  Turbo PMAC2-VME Ultralite Device Driver */
-
-/*
- * Author:      Oleg A. Makarov
- * 		adapted from PMAC-VME device driver written by Thomas A. Coleman
- * Date:        2003/09/17
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- */
-
-/*
-*****************************************************************
-                          COPYRIGHT NOTIFICATION
-*****************************************************************
-
-THE FOLLOWING IS A NOTICE OF COPYRIGHT, AVAILABILITY OF THE CODE,
-AND DISCLAIMER WHICH MUST BE INCLUDED IN THE PROLOGUE OF THE CODE
-AND IN ALL SOURCE LISTINGS OF THE CODE.
-
-(C)  COPYRIGHT 1995 UNIVERSITY OF CHICAGO
-
-Argonne National Laboratory (ANL), with facilities in the States of
-Illinois and Idaho, is owned by the United States Government, and
-operated by the University of Chicago under provision of a contract
-with the Department of Energy.
-
-Portions of this material resulted from work developed under a U.S.
-Government contract and are subject to the following license:  For
-a period of five years from March 30, 1993, the Government is
-granted for itself and others acting on its behalf a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, and perform
-publicly and display publicly.  With the approval of DOE, this
-period may be renewed for two additional five year periods.
-Following the expiration of this period or periods, the Government
-is granted for itself and others acting on its behalf, a paid-up,
-nonexclusive, irrevocable worldwide license in this computer
-software to reproduce, prepare derivative works, distribute copies
-to the public, perform publicly and display publicly, and to permit
-others to do so.
-
-*****************************************************************
-                                DISCLAIMER
-*****************************************************************
-
-NEITHER THE UNITED STATES GOVERNMENT NOR ANY AGENCY THEREOF, NOR
-THE UNIVERSITY OF CHICAGO, NOR ANY OF THEIR EMPLOYEES OR OFFICERS,
-MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL
-LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
-USEFULNESS OF ANY INFORMATION, APPARATUS, PRODUCT, OR PROCESS
-DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY
-OWNED RIGHTS.
-
-*****************************************************************
-LICENSING INQUIRIES MAY BE DIRECTED TO THE INDUSTRIAL TECHNOLOGY
-DEVELOPMENT CENTER AT ARGONNE NATIONAL LABORATORY (708-252-2000).
-*/
-
-/*
- * Modification History:
- * ---------------------
- * .01  6-7-95        tac     initial
- */
-
-#ifndef __INCpmacVmeH
-#define __INCpmacVmeH
-
-/*
- * DEFINES
- */
-
-#define PMAC_PRIVATE FALSE
-
-#if PMAC_PRIVATE
-#define PMAC_LOCAL LOCAL
-#else
-#define PMAC_LOCAL
-#endif
-
-/* PMAC Hardware Constants */
-
-#define PMAC_TERM_ACK   0x06
-#define PMAC_TERM_BELL  0x07
-#define PMAC_TERM_CR    0x0D
-
-#define PMAC_MAX_CTLRS	(8)			/* Maximum # of PMAC controller cards */
-
-#define PMAC_MBX_OUT_BUFLEN	(80)
-#define PMAC_MBX_IN_BUFLEN	(80)
-#define PMAC_MBX_ERR_BUFLEN	(10)
-
-/* #define WAIT_TIMEOUT	60 */		/* timeout in ticks for semTake */
-#define WAIT_TIMEOUT	   3600		/* timeout in ticks for semTake -- changed 2005-05-09 */
-#define PMAC_BASE_MBX_REGS (16)
-#define PMAC_STRLEN_FWVER  (31)
-
-/*
- * TYPEDEFS
- */
-
-typedef volatile char	PMAC_DPRAM;
-typedef volatile char	PMAC_DPRAM_BASE;
-
-typedef struct  /* PMAC_MBX_BASE */
-{
-	struct pmacBaseMbxStruct
-	{
-		struct { unsigned char unused; unsigned char data; } MB[PMAC_BASE_MBX_REGS];
-		
-	} mailbox;
-} PMAC_MBX_BASE;
-
-typedef struct  /* PMAC_CTLR */
-{
-	int		ctlr;
-	int		configured;
-	int		present;
-	int		enabled;
-	int		active;
-	int		presentBase;
-	int		enabledBase;
-	int		activeBase;
-	int		presentDpram;
-	int		enabledDpram;
-	int		activeDpram;
-	int		enabledGather;
-	int		activeGather;
-	PMAC_MBX_BASE   *pBase;
-	PMAC_DPRAM_BASE *pDpramBase;
-	unsigned	irqVector;
-	unsigned	irqLevel;
-	unsigned long	vmebusBase;
-	unsigned long	vmebusDpram;
-	SEM_ID		ioMbxLockSem;
-	SEM_ID		ioMbxReceiptSem;
-	SEM_ID		ioMbxReadmeSem;
-	char		firmwareVersion[PMAC_STRLEN_FWVER];
-} PMAC_CTLR;
-
-
-/*
- * FORWARD DECLARATIONS
- */
-
-
-void pmacVmeReport( int, int );
-           long pmacVmeConfig( int, unsigned long, unsigned long, unsigned int, unsigned int );
-PMAC_LOCAL long pmacVmeInit (void);
-PMAC_LOCAL char pmacMbxWrite(int, char *);
-PMAC_LOCAL char pmacMbxRead(int, char *, char *);
-PMAC_LOCAL void pmacMbxReceiptISR (PMAC_CTLR * pPmacCtlr);
-PMAC_LOCAL void pmacMbxReadmeISR (PMAC_CTLR * pPmacCtlr);
-
-long pmacMbxLock (int ctlr);
-long pmacMbxUnlock (int	ctlr);
-
-char pmacVmeWriteC (char * addr, char val);
-char pmacVmeReadC (char * addr);
-
-PMAC_DPRAM * pmacRamAddr (int ctlr, int offset);
-
-PMAC_LOCAL long pmacRamGet16 (PMAC_DPRAM * pRam, long * pVal);
-PMAC_LOCAL long pmacRamPut16 (PMAC_DPRAM * pRam, long val);
-PMAC_LOCAL long pmacRamGet24U (PMAC_DPRAM * pRam, long * pVal);
-PMAC_LOCAL long pmacRamGet24 (PMAC_DPRAM * pRam, long * pVal);
-PMAC_LOCAL long pmacRamPut32 (PMAC_DPRAM * pRam, long val);
-PMAC_LOCAL long pmacRamGetF (PMAC_DPRAM * pRam, double * pVal);
-PMAC_LOCAL long pmacRamPutF (PMAC_DPRAM * pRam, double val);
-PMAC_LOCAL long pmacRamGetD (PMAC_DPRAM * pRam, double * pVal);
-PMAC_LOCAL long pmacRamGetL (PMAC_DPRAM * pRam, double * pVal);
-
-PMAC_LOCAL void pmacGatBufferSem (int ctlr);
-
-#endif /* __INCpmacVmeH */
diff --git a/pmacApp/src/statusDevice.dbd b/pmacApp/src/statusDevice.dbd
deleted file mode 100644
index d8f0901..0000000
--- a/pmacApp/src/statusDevice.dbd
+++ /dev/null
@@ -1 +0,0 @@
-device(status,CONSTANT,devStatusSoft,"Soft Channel")
diff --git a/pmacApp/src/statusRecord.c b/pmacApp/src/statusRecord.c
deleted file mode 100644
index d973cd4..0000000
--- a/pmacApp/src/statusRecord.c
+++ /dev/null
@@ -1,760 +0,0 @@
-/* statusRecord.c - Record Support Routines for Status records */
-/*
- *      Author: 	Thomas Coleman
- *      Date:   	96/02/27
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- *
- *      Copyright 1991, the Regents of the University of California,
- *      and the University of Chicago Board of Governors.
- *
- *      This software was produced under  U.S. Government contracts:
- *      (W-7405-ENG-36) at the Los Alamos National Laboratory,
- *      and (W-31-109-ENG-38) at Argonne National Laboratory.
- *
- *      Initial development by:
- *              The Controls and Automation Group (AT-8)
- *              Ground Test Accelerator
- *              Accelerator Technology Division
- *              Los Alamos National Laboratory
- *
- *      Co-developed with
- *              The Controls and Computing Group
- *              Accelerator Systems Division
- *              Advanced Photon Source
- *              Argonne National Laboratory
- *
- * Modification Log:
- * -----------------
- * .01  11-11-91        jba     Moved set and reset of alarm stat and sevr to macros
- * .02  02-05-92	jba	Changed function arguments from paddr to precord
- * .03  02-28-92        jba     Changed get_precision,get_graphic_double,get_control_double
- * .04  02-28-92	jba	ANSI C changes
- * .05  04-10-92        jba     pact now used to test for asyn processing, not status
- * .06  04-18-92        jba     removed process from dev init_record parms
- * .07  06-02-92        jba     changed graphic/control limits for hihi,high,low,lolo
- * .08  07-15-92        jba     changed VALID_ALARM to INVALID alarm
- * .09  07-16-92        jba     added invalid alarm fwd link test and chngd fwd lnk to macro
- * .10  07-21-92        jba     changed alarm limits for non val related fields
- * .11  08-06-92        jba     New algorithm for calculating analog alarms
- * .12  08-13-92        jba     Added simulation processing
- * .13  05-30-92	vong	Convert recLongin to recStatus
- * .14	06-18-95	tac	fixed bug in bit16 & bit24 - bit31
- * .15  02-26-96	tac	Process links on change of stat and sevr;
- *				Decode bits before processing links; fixed bug in bit 24
- *
- *  History
- *  -------
- *  Version 1.0  21/10/97  ajf  Changes for 3.13.
- *  Version 1.1  31/10/97  ajf  Added get_precision function for VERS field.
- */
-
-#define VERSION 1.1
-
-#include        <vxWorks.h>
-#include        <stdlib.h>
-#include        <stdio.h>
-#include        <string.h>
-#include        <lstLib.h>
-
-#include        <alarm.h>
-#include        <dbDefs.h>
-#include        <dbEvent.h>
-#include        <dbAccess.h>
-#include        <dbFldTypes.h>
-#include        <errMdef.h>
-#include        <recSup.h>
-#include        <devSup.h>
-
-#define GEN_SIZE_OFFSET
-#include	<statusRecord.h>
-#undef GEN_SIZE_OFFSET
-#include "tsDefs.h"
-#include "recGbl.h"
-#include "epicsExport.h"
-
-/* Create RSET - Record Support Entry Table*/
-static long init_record();
-static long process();
-static long get_units();
-static long get_graphic_double();
-static long get_control_double();
-static long get_alarm_double();
-static long get_precision();
-#define report          NULL
-#define initialize      NULL
-#define special         NULL
-#define cvt_dbaddr      NULL
-#define get_value       NULL
-#define get_array_info  NULL
-#define put_array_info  NULL
-static long get_enum_str();
-#define get_enum_strs   NULL
-#define put_enum_str    NULL
-/* Changed for EPICS-3.14.11 where YES/NO are no longer defined in EPICS includes */
-#if !defined(YES) || !defined(NO)
-#define YES 1
-#define NO 0
-#endif
-
-rset statusRSET={
-	RSETNUMBER,
-	report,
-	initialize,
-	init_record,
-	process,
-	special,
-	get_value,
-	cvt_dbaddr,
-	get_array_info,
-	put_array_info,
-	get_units,
-	get_precision,
-	get_enum_str,
-	get_enum_strs,
-	put_enum_str,
-	get_graphic_double,
-	get_control_double,
-	get_alarm_double };
-epicsExportAddress(rset,statusRSET);
-
-struct statusdset { /* status input dset */
-	long		number;
-	DEVSUPFUN	dev_report;
-	DEVSUPFUN	init;
-	DEVSUPFUN	init_record; /*returns: (-1,0)=>(failure,success)*/
-	DEVSUPFUN	get_ioint_info;
-	DEVSUPFUN	read_status; /*returns: (-1,0)=>(failure,success)*/
-};
-static void alarm();
-static void monitor();
-static long readValue();
-static void decodeBits();
-static void activateAllLink();
-static void activateNewLink();
-
-static long get_enum_str(paddr,pstring)
-    struct dbAddr *paddr;
-    char	  *pstring;
-{
-    int                 index;
-    unsigned short      *pfield = (unsigned short *)paddr->pfield;
-    index = dbGetFieldIndex(paddr);
-    if(index >= statusRecordBI00 && index <= statusRecordBI31) {
-      if(*pfield==0) {
-	strcpy(pstring,"OFF");
-      } else {
-	strcpy(pstring,"ON");
-      }
-    } else {
-	strcpy(pstring,"Illegal_Value");
-    }
-    return(0);
-}
-
-static long init_record(pstatus,pass)
-    struct statusRecord	*pstatus;
-    int pass;
-{
-    struct statusdset *pdset;
-    long status;
-
-    if (pass==0)
-    {
-      pstatus->vers = VERSION;
-      return(0);
-    }
-
-    if( pstatus->siml.type == CONSTANT )
-      recGblInitConstantLink(&pstatus->siml, DBF_ENUM, &pstatus->simm);
-
-    if( pstatus->siol.type == CONSTANT )
-      recGblInitConstantLink(&pstatus->siol, DBF_LONG, &pstatus->sval);
-
-    if(!(pdset = (struct statusdset *)(pstatus->dset))) {
-	recGblRecordError(S_dev_noDSET,(void *)pstatus,"statusRecord: init_record");
-	return(S_dev_noDSET);
-    }
-    /* must have read_status function defined */
-    if( (pdset->number < 5) || (pdset->read_status == NULL) ) {
-	recGblRecordError(S_dev_missingSup,(void *)pstatus,"statusRecord: init_record");
-	return(S_dev_missingSup);
-    }
-    if( pdset->init_record ) {
-	if((status=(*pdset->init_record)(pstatus))) return(status);
-    }
-    return(0);
-}
-
-static long process(pstatus)
-	struct statusRecord     *pstatus;
-{
-	struct statusdset	*pdset = (struct statusdset *)(pstatus->dset);
-	long		 status;
-	unsigned char    pact=pstatus->pact;
-
-	if( (pdset==NULL) || (pdset->read_status==NULL) ) {
-		pstatus->pact=TRUE;
-		recGblRecordError(S_dev_missingSup,(void *)pstatus,"statusRecord: read_status");
-		return(S_dev_missingSup);
-	}
-
-	status=readValue(pstatus); /* read the new value */
-	/* check if device support set pact */
-	if ( !pact && pstatus->pact ) return(0);
-	pstatus->pact = TRUE;
-
-	tsLocalTime(&pstatus->time);
-
-	/* check for alarms */
-	alarm(pstatus);
-	/* check event list */
-	monitor(pstatus);
-	/* decode the bits */
-        decodeBits(pstatus);
-	/* activate links for changed bits */
-        activateNewLink(pstatus);
-	/* process the forward scan link record */
-	recGblFwdLink(pstatus);
-
-	pstatus->pact=FALSE;
-	return(status);
-}
-
-
-static long get_units(paddr,units)
-    struct dbAddr *paddr;
-    char	  *units;
-{
-    struct statusRecord	*pstatus=(struct statusRecord *)paddr->precord;
-
-    strncpy(units,pstatus->egu,sizeof(pstatus->egu));
-    return(0);
-}
-
-
-static long get_graphic_double(paddr,pgd)
-    struct dbAddr *paddr;
-    struct dbr_grDouble	*pgd;
-{
-    struct statusRecord	*pstatus=(struct statusRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&pstatus->val
-    || paddr->pfield==(void *)&pstatus->hihi
-    || paddr->pfield==(void *)&pstatus->high
-    || paddr->pfield==(void *)&pstatus->low
-    || paddr->pfield==(void *)&pstatus->lolo){
-        pgd->upper_disp_limit = pstatus->hopr;
-        pgd->lower_disp_limit = pstatus->lopr;
-    } else recGblGetGraphicDouble(paddr,pgd);
-    return(0);
-}
-
-static long get_control_double(paddr,pcd)
-    struct dbAddr *paddr;
-    struct dbr_ctrlDouble *pcd;
-{
-    struct statusRecord	*pstatus=(struct statusRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&pstatus->val
-    || paddr->pfield==(void *)&pstatus->hihi
-    || paddr->pfield==(void *)&pstatus->high
-    || paddr->pfield==(void *)&pstatus->low
-    || paddr->pfield==(void *)&pstatus->lolo){
-        pcd->upper_ctrl_limit = pstatus->hopr;
-        pcd->lower_ctrl_limit = pstatus->lopr;
-    } else recGblGetControlDouble(paddr,pcd);
-    return(0);
-}
-
-static long get_alarm_double(paddr,pad)
-    struct dbAddr *paddr;
-    struct dbr_alDouble	*pad;
-{
-    struct statusRecord	*pstatus=(struct statusRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&pstatus->val){
-         pad->upper_alarm_limit = pstatus->hihi;
-         pad->upper_warning_limit = pstatus->high;
-         pad->lower_warning_limit = pstatus->low;
-         pad->lower_alarm_limit = pstatus->lolo;
-    } else recGblGetAlarmDouble(paddr,pad);
-    return(0);
-}
-
-static void alarm(pstatus)
-    struct statusRecord	*pstatus;
-{
-	double		val;
-	float		hyst, lalm, hihi, high, low, lolo;
-	unsigned short	hhsv, llsv, hsv, lsv;
-
-	if(pstatus->udf == TRUE ){
- 		recGblSetSevr(pstatus,UDF_ALARM,INVALID_ALARM);
-		return;
-	}
-	hihi = pstatus->hihi; lolo = pstatus->lolo; high = pstatus->high; low = pstatus->low;
-	hhsv = pstatus->hhsv; llsv = pstatus->llsv; hsv = pstatus->hsv; lsv = pstatus->lsv;
-	val = pstatus->val; hyst = pstatus->hyst; lalm = pstatus->lalm;
-
-	/* alarm condition hihi */
-	if (hhsv && (val >= hihi || ((lalm==hihi) && (val >= hihi-hyst)))){
-	        if (recGblSetSevr(pstatus,HIHI_ALARM,pstatus->hhsv)) pstatus->lalm = hihi;
-		return;
-	}
-
-	/* alarm condition lolo */
-	if (llsv && (val <= lolo || ((lalm==lolo) && (val <= lolo+hyst)))){
-	        if (recGblSetSevr(pstatus,LOLO_ALARM,pstatus->llsv)) pstatus->lalm = lolo;
-		return;
-	}
-
-	/* alarm condition high */
-	if (hsv && (val >= high || ((lalm==high) && (val >= high-hyst)))){
-	        if (recGblSetSevr(pstatus,HIGH_ALARM,pstatus->hsv)) pstatus->lalm = high;
-		return;
-	}
-
-	/* alarm condition low */
-	if (lsv && (val <= low || ((lalm==low) && (val <= low+hyst)))){
-	        if (recGblSetSevr(pstatus,LOW_ALARM,pstatus->lsv)) pstatus->lalm = low;
-		return;
-	}
-
-	/* we get here only if val is out of alarm by at least hyst */
-	pstatus->lalm = val;
-	return;
-}
-
-static void monitor(pstatus)
-    struct statusRecord	*pstatus;
-{
-	unsigned short	monitor_mask;
-	long		delta;
-	int		linkActivation = FALSE;
-
-	/* get previous stat and sevr  and new stat and sevr*/
-        monitor_mask = recGblResetAlarms(pstatus);
-        /* notice any change of stat and sevr */
-        if (monitor_mask != 0) linkActivation = TRUE;
-
-	/* check for value change */
-	delta = pstatus->mlst - pstatus->val;
-	if(delta<0) delta = -delta;
-	if (delta > pstatus->mdel) {
-		/* post events for value change */
-		monitor_mask |= DBE_VALUE;
-		/* update last value monitored */
-		pstatus->mlst = pstatus->val;
-	}
-
-	/* check for archive change */
-	delta = pstatus->alst - pstatus->val;
-	if(delta<0) delta = -delta;
-	if (delta > pstatus->adel) {
-		/* post events on value field for archive change */
-		monitor_mask |= DBE_LOG;
-		/* update last archive value monitored */
-		pstatus->alst = pstatus->val;
-	}
-
-	/* send out monitors connected to the value field */
-	if (monitor_mask){
-		db_post_events(pstatus,&pstatus->val,monitor_mask);
-	}
-	
-	/* decode and activate all links if stat or sevr changed */
-        if (linkActivation) {
-        	decodeBits(pstatus);
-       		activateAllLink(pstatus);
-       	}
-	
-	return;
-}
-
-static long readValue(pstatus)
-	struct statusRecord	*pstatus;
-{
-	long		status;
-        struct statusdset 	*pdset = (struct statusdset *) (pstatus->dset);
-	long            nRequest=1;
-	long            options=0;
-
-	if (pstatus->pact == TRUE){
-		status=(*pdset->read_status)(pstatus);
-		return(status);
-	}
-
-	status = dbGetLink( &(pstatus->siml), DBR_ENUM, &(pstatus->simm),
-                            &options, &nRequest );
-	if (status)
-		return(status);
-
-	if (pstatus->simm == NO){
-		status=(*pdset->read_status)(pstatus);
-		return(status);
-	}
-	if (pstatus->simm == YES){
-		status = dbGetLink( &(pstatus->siol), DBR_LONG, &(pstatus->sval),
-                                    &options, &nRequest );
-		if (status==0){
-			pstatus->val=pstatus->sval;
-			pstatus->udf=FALSE;
-		}
-	} else {
-		status=-1;
-		recGblSetSevr(pstatus,SOFT_ALARM,INVALID_ALARM);
-		return(status);
-	}
-        recGblSetSevr(pstatus,SIMM_ALARM,pstatus->sims);
-
-	return(status);
-}
-
-static void decodeBits(pstatus)
-	struct statusRecord    *pstatus;
-{
-  if (pstatus->lval != pstatus->val) {
-    if ((pstatus->lval & 0x0000ffff) != (pstatus->val & 0x0000ffff)) {
-	if ((pstatus->lval & 0x0000000f) != (pstatus->val & 0x0000000f)) {
-	  pstatus->bi00 = (pstatus->val & 0x00000001) ? 1 : 0;
-	  pstatus->bi01 = (pstatus->val & 0x00000002) ? 1 : 0;
-	  pstatus->bi02 = (pstatus->val & 0x00000004) ? 1 : 0;
-	  pstatus->bi03 = (pstatus->val & 0x00000008) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0x000000f0) != (pstatus->val & 0x000000f0)) {
-	  pstatus->bi04 = (pstatus->val & 0x00000010) ? 1 : 0;
-	  pstatus->bi05 = (pstatus->val & 0x00000020) ? 1 : 0;
-	  pstatus->bi06 = (pstatus->val & 0x00000040) ? 1 : 0;
-	  pstatus->bi07 = (pstatus->val & 0x00000080) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0x00000f00) != (pstatus->val & 0x00000f00)) {
-	  pstatus->bi08 = (pstatus->val & 0x00000100) ? 1 : 0;
-	  pstatus->bi09 = (pstatus->val & 0x00000200) ? 1 : 0;
-	  pstatus->bi10 = (pstatus->val & 0x00000400) ? 1 : 0;
-	  pstatus->bi11 = (pstatus->val & 0x00000800) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0x0000f000) != (pstatus->val & 0x0000f000)) {
-	  pstatus->bi12 = (pstatus->val & 0x00001000) ? 1 : 0;
-	  pstatus->bi13 = (pstatus->val & 0x00002000) ? 1 : 0;
-	  pstatus->bi14 = (pstatus->val & 0x00004000) ? 1 : 0;
-	  pstatus->bi15 = (pstatus->val & 0x00008000) ? 1 : 0;
-	}
-    }
-    if ((pstatus->lval & 0xffff0000) != (pstatus->val & 0xffff0000)) {
-	if ((pstatus->lval & 0x000f0000) != (pstatus->val & 0x000f0000)) {
-	  pstatus->bi16 = (pstatus->val & 0x00010000) ? 1 : 0;
-	  pstatus->bi17 = (pstatus->val & 0x00020000) ? 1 : 0;
-	  pstatus->bi18 = (pstatus->val & 0x00040000) ? 1 : 0;
-	  pstatus->bi19 = (pstatus->val & 0x00080000) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0x00f00000) != (pstatus->val & 0x00f00000)) {
-	  pstatus->bi20 = (pstatus->val & 0x00100000) ? 1 : 0;
-	  pstatus->bi21 = (pstatus->val & 0x00200000) ? 1 : 0;
-	  pstatus->bi22 = (pstatus->val & 0x00400000) ? 1 : 0;
-	  pstatus->bi23 = (pstatus->val & 0x00800000) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0x0f000000) != (pstatus->val & 0x0f000000)) {
-	  pstatus->bi24 = (pstatus->val & 0x01000000) ? 1 : 0;
-	  pstatus->bi25 = (pstatus->val & 0x02000000) ? 1 : 0;
-	  pstatus->bi26 = (pstatus->val & 0x04000000) ? 1 : 0;
-	  pstatus->bi27 = (pstatus->val & 0x08000000) ? 1 : 0;
-	}
-	if ((pstatus->lval & 0xf0000000) != (pstatus->val & 0xf0000000)) {
-	  pstatus->bi28 = (pstatus->val & 0x10000000) ? 1 : 0;
-	  pstatus->bi29 = (pstatus->val & 0x20000000) ? 1 : 0;
-	  pstatus->bi30 = (pstatus->val & 0x40000000) ? 1 : 0;
-	  pstatus->bi31 = (pstatus->val & 0x80000000) ? 1 : 0;
-	}
-    }
-  }
-}
-
-static void activateNewLink(pstatus)
-	struct statusRecord    *pstatus;
-{
-  if (pstatus->lval != pstatus->val) {
-    if ((pstatus->lval & 0x0000ffff) != (pstatus->val & 0x0000ffff)) {
-      if ((pstatus->lval & 0x000000ff) != (pstatus->val & 0x000000ff)) {
-	if ((pstatus->lval & 0x00000001) != (pstatus->val & 0x00000001)) {
-	  if (pstatus->lk00.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk00) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000002) != (pstatus->val & 0x00000002)) {
-	  if (pstatus->lk01.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk01) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000004) != (pstatus->val & 0x00000004)) {
-	  if (pstatus->lk02.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk02) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000008) != (pstatus->val & 0x00000008)) {
-	  if (pstatus->lk03.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk03) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000010) != (pstatus->val & 0x00000010)) {
-	  if (pstatus->lk04.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk04) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000020) != (pstatus->val & 0x00000020)) {
-	  if (pstatus->lk05.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk05) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000040) != (pstatus->val & 0x00000040)) {
-	  if (pstatus->lk06.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk06) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000080) != (pstatus->val & 0x00000080)) {
-	  if (pstatus->lk07.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk07) );
-	  }
-	}
-      }
-      if ((pstatus->lval & 0x0000ff00) != (pstatus->val & 0x0000ff00)) {
-	if ((pstatus->lval & 0x00000100) != (pstatus->val & 0x00000100)) {
-	  if (pstatus->lk08.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk08) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000200) != (pstatus->val & 0x00000200)) {
-	  if (pstatus->lk09.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk09) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000400) != (pstatus->val & 0x00000400)) {
-	  if (pstatus->lk10.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk10) );
-	  }
-	}
-	if ((pstatus->lval & 0x00000800) != (pstatus->val & 0x00000800)) {
-	  if (pstatus->lk11.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk11) );
-	  }
-	}
-	if ((pstatus->lval & 0x00001000) != (pstatus->val & 0x00001000)) {
-	  if (pstatus->lk12.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk12) );
-	  }
-	}
-	if ((pstatus->lval & 0x00002000) != (pstatus->val & 0x00002000)) {
-	  if (pstatus->lk13.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk13) );
-	  }
-	}
-	if ((pstatus->lval & 0x00004000) != (pstatus->val & 0x00004000)) {
-	  if (pstatus->lk14.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk14) );
-	  }
-	}
-	if ((pstatus->lval & 0x00008000) != (pstatus->val & 0x00008000)) {
-	  if (pstatus->lk15.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk15) );
-	  }
-	}
-      }
-    }
-    if ((pstatus->lval & 0xffff0000) != (pstatus->val & 0xffff0000)) {
-      if ((pstatus->lval & 0x00ff0000) != (pstatus->val & 0x00ff0000)) {
-	if ((pstatus->lval & 0x00010000) != (pstatus->val & 0x00010000)) {
-	  if (pstatus->lk16.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk16) );
-	  }
-	}
-	if ((pstatus->lval & 0x00020000) != (pstatus->val & 0x00020000)) {
-	  if (pstatus->lk17.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk17) );
-	  }
-	}
-	if ((pstatus->lval & 0x00040000) != (pstatus->val & 0x00040000)) {
-	  if (pstatus->lk18.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk18) );
-	  }
-	}
-	if ((pstatus->lval & 0x00080000) != (pstatus->val & 0x00080000)) {
-	  if (pstatus->lk19.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk19) );
-	  }
-	}
-	if ((pstatus->lval & 0x00100000) != (pstatus->val & 0x00100000)) {
-	  if (pstatus->lk20.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk20) );
-	  }
-	}
-	if ((pstatus->lval & 0x00200000) != (pstatus->val & 0x00200000)) {
-	  if (pstatus->lk21.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk21) );
-	  }
-	}
-	if ((pstatus->lval & 0x00400000) != (pstatus->val & 0x00400000)) {
-	  if (pstatus->lk22.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk22) );
-	  }
-	}
-	if ((pstatus->lval & 0x00800000) != (pstatus->val & 0x00800000)) {
-	  if (pstatus->lk23.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk23) );
-	  }
-	}
-      }
-      if ((pstatus->lval & 0xff000000) != (pstatus->val & 0xff000000)) {
-	if ((pstatus->lval & 0x01000000) != (pstatus->val & 0x01000000)) {
-	  if (pstatus->lk24.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk24) );
-	  }
-	}
-	if ((pstatus->lval & 0x02000000) != (pstatus->val & 0x02000000)) {
-	  if (pstatus->lk25.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk25) );
-	  }
-	}
-	if ((pstatus->lval & 0x04000000) != (pstatus->val & 0x04000000)) {
-	  if (pstatus->lk26.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk26) );
-	  }
-	}
-	if ((pstatus->lval & 0x08000000) != (pstatus->val & 0x08000000)) {
-	  if (pstatus->lk27.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk27) );
-	  }
-	}
-	if ((pstatus->lval & 0x10000000) != (pstatus->val & 0x10000000)) {
-	  if (pstatus->lk28.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk28) );
-	  }
-	}
-	if ((pstatus->lval & 0x20000000) != (pstatus->val & 0x20000000)) {
-	  if (pstatus->lk29.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk29) );
-	  }
-	}
-	if ((pstatus->lval & 0x40000000) != (pstatus->val & 0x40000000)) {
-	  if (pstatus->lk30.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk30) );
-	  }
-	}
-	if ((pstatus->lval & 0x80000000) != (pstatus->val & 0x80000000)) {
-	  if (pstatus->lk31.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk31) );
-	  }
-	}
-      }
-    }
-    pstatus->lval = pstatus->val;
-  }
-}
-
-static void activateAllLink(pstatus)
-	struct statusRecord    *pstatus;
-{
-	  if (pstatus->lk00.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk00) );
-	  }
-	  if (pstatus->lk01.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk01) );
-	  }
-	  if (pstatus->lk02.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk02) );
-	  }
-	  if (pstatus->lk03.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk03) );
-	  }
-	  if (pstatus->lk04.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk04) );
-	  }
-	  if (pstatus->lk05.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk05) );
-	  }
-	  if (pstatus->lk06.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk06) );
-	  }
-	  if (pstatus->lk07.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk07) );
-	  }
-	  if (pstatus->lk08.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk08) );
-	  }
-	  if (pstatus->lk09.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk09) );
-	  }
-	  if (pstatus->lk10.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk10) );
-	  }
-	  if (pstatus->lk11.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk11) );
-	  }
-	  if (pstatus->lk12.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk12) );
-	  }
-	  if (pstatus->lk13.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk13) );
-	  }
-	  if (pstatus->lk14.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk14) );
-	  }
-	  if (pstatus->lk15.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk15) );
-	  }
-	  if (pstatus->lk16.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk16) );
-	  }
-	  if (pstatus->lk17.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk17) );
-	  }
-	  if (pstatus->lk18.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk18) );
-	  }
-	  if (pstatus->lk19.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk19) );
-	  }
-	  if (pstatus->lk20.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk20) );
-	  }
-	  if (pstatus->lk21.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk21) );
-	  }
-	  if (pstatus->lk22.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk22) );
-	  }
-	  if (pstatus->lk23.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk23) );
-	  }
-	  if (pstatus->lk24.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk24) );
-	  }
-	  if (pstatus->lk25.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk25) );
-	  }
-	  if (pstatus->lk26.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk26) );
-	  }
-	  if (pstatus->lk27.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk27) );
-	  }
-	  if (pstatus->lk28.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk28) );
-	  }
-	  if (pstatus->lk29.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk29) );
-	  }
-	  if (pstatus->lk30.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk30) );
-	  }
-	  if (pstatus->lk31.type == DB_LINK) {
-	    dbScanFwdLink( &(pstatus->lk31) );
-	  }
-    pstatus->lval = pstatus->val;
-}
-
-
-static long get_precision( struct dbAddr *paddr, long *pprecision )
-{
-  *pprecision = 1;
-  return 0;
-}
diff --git a/pmacApp/src/statusRecord.dbd b/pmacApp/src/statusRecord.dbd
deleted file mode 100644
index 22b0ca2..0000000
--- a/pmacApp/src/statusRecord.dbd
+++ /dev/null
@@ -1,468 +0,0 @@
-recordtype(status) {
-	include "dbCommon.dbd" 
-        field(VERS,DBF_DOUBLE) {
-                prompt("Version Number")
-                promptgroup(GUI_DISPLAY)
-                special(SPC_NOMOD)
-                interest(1)
-        }
-	field(VAL,DBF_LONG) {
-		prompt("Current value")
-		asl(ASL0)
-		pp(TRUE)
-	}
-	field(INP,DBF_INLINK) {
-		prompt("Input Specification")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(EGU,DBF_STRING) {
-		prompt("Units name")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-		size(16)
-	}
-	field(HOPR,DBF_LONG) {
-		prompt("High Operating Range")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(LOPR,DBF_LONG) {
-		prompt("Low Operating Range")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(LVAL,DBF_LONG) {
-		prompt("Last value")
-		pp(TRUE)
-	}
-	field(BI00,DBF_ENUM) {
-		prompt("bit 0 Value")
-		pp(TRUE)
-	}
-	field(BI01,DBF_ENUM) {
-		prompt("bit 1 Value")
-		pp(TRUE)
-	}
-	field(BI02,DBF_ENUM) {
-		prompt("bit 2 Value")
-		pp(TRUE)
-	}
-	field(BI03,DBF_ENUM) {
-		prompt("bit 3 Value")
-		pp(TRUE)
-	}
-	field(BI04,DBF_ENUM) {
-		prompt("bit 4 Value")
-		pp(TRUE)
-	}
-	field(BI05,DBF_ENUM) {
-		prompt("bit 5 Value")
-		pp(TRUE)
-	}
-	field(BI06,DBF_ENUM) {
-		prompt("bit 6 Value")
-		pp(TRUE)
-	}
-	field(BI07,DBF_ENUM) {
-		prompt("bit 7 Value")
-		pp(TRUE)
-	}
-	field(BI08,DBF_ENUM) {
-		prompt("bit 8 Value")
-		pp(TRUE)
-	}
-	field(BI09,DBF_ENUM) {
-		prompt("bit 9 Value")
-		pp(TRUE)
-	}
-	field(BI10,DBF_ENUM) {
-		prompt("bit 10 Value")
-		pp(TRUE)
-	}
-	field(BI11,DBF_ENUM) {
-		prompt("bit 11 Value")
-		pp(TRUE)
-	}
-	field(BI12,DBF_ENUM) {
-		prompt("bit 12 Value")
-		pp(TRUE)
-	}
-	field(BI13,DBF_ENUM) {
-		prompt("bit 13 Value")
-		pp(TRUE)
-	}
-	field(BI14,DBF_ENUM) {
-		prompt("bit 14 Value")
-		pp(TRUE)
-	}
-	field(BI15,DBF_ENUM) {
-		prompt("bit 15 Value")
-		pp(TRUE)
-	}
-	field(BI16,DBF_ENUM) {
-		prompt("bit 16 Value")
-		pp(TRUE)
-	}
-	field(BI17,DBF_ENUM) {
-		prompt("bit 17 Value")
-		pp(TRUE)
-	}
-	field(BI18,DBF_ENUM) {
-		prompt("bit 18 Value")
-		pp(TRUE)
-	}
-	field(BI19,DBF_ENUM) {
-		prompt("bit 19 Value")
-		pp(TRUE)
-	}
-	field(BI20,DBF_ENUM) {
-		prompt("bit 20 Value")
-		pp(TRUE)
-	}
-	field(BI21,DBF_ENUM) {
-		prompt("bit 20 Value")
-		pp(TRUE)
-	}
-	field(BI22,DBF_ENUM) {
-		prompt("bit 22 Value")
-		pp(TRUE)
-	}
-	field(BI23,DBF_ENUM) {
-		prompt("bit 23 Value")
-		pp(TRUE)
-	}
-	field(BI24,DBF_ENUM) {
-		prompt("bit 24 Value")
-		pp(TRUE)
-	}
-	field(BI25,DBF_ENUM) {
-		prompt("bit 25 Value")
-		pp(TRUE)
-	}
-	field(BI26,DBF_ENUM) {
-		prompt("bit 26 Value")
-		pp(TRUE)
-	}
-	field(BI27,DBF_ENUM) {
-		prompt("bit 27 Value")
-		pp(TRUE)
-	}
-	field(BI28,DBF_ENUM) {
-		prompt("bit 28 Value")
-		pp(TRUE)
-	}
-	field(BI29,DBF_ENUM) {
-		prompt("bit 29 Value")
-		pp(TRUE)
-	}
-	field(BI30,DBF_ENUM) {
-		prompt("bit 30 Value")
-		pp(TRUE)
-	}
-	field(BI31,DBF_ENUM) {
-		prompt("bit 31 Value")
-		pp(TRUE)
-	}
-	field(LK00,DBF_FWDLINK) {
-		prompt("Forward Link 0")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK01,DBF_FWDLINK) {
-		prompt("Forward Link 1")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK02,DBF_FWDLINK) {
-		prompt("Forward Link 2")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK03,DBF_FWDLINK) {
-		prompt("Forward Link 3")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK04,DBF_FWDLINK) {
-		prompt("Forward Link 4")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK05,DBF_FWDLINK) {
-		prompt("Forward Link 5")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK06,DBF_FWDLINK) {
-		prompt("Forward Link 6")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK07,DBF_FWDLINK) {
-		prompt("Forward Link 7")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK08,DBF_FWDLINK) {
-		prompt("Forward Link 8")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK09,DBF_FWDLINK) {
-		prompt("Forward Link 9")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK10,DBF_FWDLINK) {
-		prompt("Forward Link 10")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK11,DBF_FWDLINK) {
-		prompt("Forward Link 11")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK12,DBF_FWDLINK) {
-		prompt("Forward Link 12")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK13,DBF_FWDLINK) {
-		prompt("Forward Link 13")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK14,DBF_FWDLINK) {
-		prompt("Forward Link 14")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK15,DBF_FWDLINK) {
-		prompt("Forward Link 15")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK16,DBF_FWDLINK) {
-		prompt("Forward Link 16")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK17,DBF_FWDLINK) {
-		prompt("Forward Link 17")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK18,DBF_FWDLINK) {
-		prompt("Forward Link 18")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK19,DBF_FWDLINK) {
-		prompt("Forward Link 19")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK20,DBF_FWDLINK) {
-		prompt("Forward Link 20")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK21,DBF_FWDLINK) {
-		prompt("Forward Link 21")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK22,DBF_FWDLINK) {
-		prompt("Forward Link 22")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK23,DBF_FWDLINK) {
-		prompt("Forward Link 23")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK24,DBF_FWDLINK) {
-		prompt("Forward Link 24")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK25,DBF_FWDLINK) {
-		prompt("Forward Link 25")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK26,DBF_FWDLINK) {
-		prompt("Forward Link 26")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK27,DBF_FWDLINK) {
-		prompt("Forward Link 27")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK28,DBF_FWDLINK) {
-		prompt("Forward Link 28")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK29,DBF_FWDLINK) {
-		prompt("Forward Link 29")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK30,DBF_FWDLINK) {
-		prompt("Forward Link 30")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(LK31,DBF_FWDLINK) {
-		prompt("Forward Link 31")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(HIHI,DBF_LONG) {
-		prompt("Hihi Alarm Limit")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOLO,DBF_LONG) {
-		prompt("Lolo Alarm Limit")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-	}
-	field(HIGH,DBF_LONG) {
-		prompt("High Alarm Limit")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOW,DBF_LONG) {
-		prompt("Low Alarm Limit")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-	}
-	field(HHSV,DBF_MENU) {
-		prompt("Hihi Severity")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LLSV,DBF_MENU) {
-		prompt("Lolo Severity")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HSV,DBF_MENU) {
-		prompt("High Severity")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LSV,DBF_MENU) {
-		prompt("Low Severity")
-		promptgroup(GUI_ALARMS)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HYST,DBF_LONG) {
-		prompt("Alarm Deadband")
-		promptgroup(GUI_ALARMS)
-		interest(1)
-	}
-	field(ADEL,DBF_LONG) {
-		prompt("Archive Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(MDEL,DBF_LONG) {
-		prompt("Monitor Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(LALM,DBF_LONG) {
-		prompt("Last Value Alarmed")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(ALST,DBF_LONG) {
-		prompt("Last Value Archived")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(MLST,DBF_LONG) {
-		prompt("Last Val Monitored")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(SIOL,DBF_INLINK) {
-		prompt("Sim Input Specifctn")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(SVAL,DBF_LONG) {
-		prompt("Simulation Value")
-	}
-	field(SIML,DBF_INLINK) {
-		prompt("Sim Mode Location")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(SIMM,DBF_MENU) {
-		prompt("Simulation Mode")
-		interest(1)
-		menu(menuYesNo)
-	}
-	field(SIMS,DBF_MENU) {
-		prompt("Sim mode Alarm Svrty")
-		promptgroup(GUI_INPUTS)
-		interest(2)
-		menu(menuAlarmSevr)
-	}
-}
diff --git a/pmacApp/src/tpmacLIBOBJS b/pmacApp/src/tpmacLIBOBJS
deleted file mode 100644
index 463a99d..0000000
--- a/pmacApp/src/tpmacLIBOBJS
+++ /dev/null
@@ -1,3 +0,0 @@
-# PMAC library
-TPMACLIBOBJS += $(TPMAC_BIN)/tpmacLib
-
diff --git a/pmacApp/src/tsubRecord.c b/pmacApp/src/tsubRecord.c
deleted file mode 100644
index 02b3f0c..0000000
--- a/pmacApp/src/tsubRecord.c
+++ /dev/null
@@ -1,487 +0,0 @@
-/* recTsub.c */
-/* share/src/rec @(#)recTsub.c	1.19     6/4/93 */
-
-/* recTsub.c - Record Support Routines for Subroutine records */
-/*
- *      Original Author: Bob Dalesio
- *      Current Author:  Marty Kraimer
- *      Date:            01-25-90
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- *
- *      Copyright 1991, the Regents of the University of California,
- *      and the University of Chicago Board of Governors.
- *
- *      This software was produced under  U.S. Government contracts:
- *      (W-7405-ENG-36) at the Los Alamos National Laboratory,
- *      and (W-31-109-ENG-38) at Argonne National Laboratory.
- *
- *      Initial development by:
- *              The Controls and Automation Group (AT-8)
- *              Ground Test Accelerator
- *              Accelerator Technology Division
- *              Los Alamos National Laboratory
- *
- *      Co-developed with
- *              The Controls and Computing Group
- *              Accelerator Systems Division
- *              Advanced Photon Source
- *              Argonne National Laboratory
- *
- * Modification Log:
- * -----------------
- * .01  10-10-90	mrk	Made changes for new record support
- * .02  11-11-91        jba     Moved set and reset of alarm stat and sevr to macros
- * .03  01-08-92        jba     Added casts in symFindByName to avoid compile warning messages
- * .04  02-05-92	jba	Changed function arguments from paddr to precord
- * .05  02-28-92        jba     Changed get_precision,get_graphic_double,get_control_double
- * .06  02-28-92	jba	ANSI C changes
- * .07  04-10-92        jba     pact now used to test for asyn processing, not status
- * .08  06-02-92        jba     changed graphic/control limits for hihi,high,low,lolo
- * .09  07-15-92        jba     changed VALID_ALARM to INVALID alarm
- * .10  07-16-92        jba     added invalid alarm fwd link test and chngd fwd lnk to macro
- * .11  07-21-92        jba     changed alarm limits for non val related fields
- * .12  08-06-92        jba     New algorithm for calculating analog alarms
- * .13  08-06-92        jba     monitor now posts events for changes in a-l
- * .14  10-10-92        jba     replaced code with recGblGetLinkValue call
- * .15  10-18-93        mhb     Built big subroutine record from sub record
- * .16  02-05-95	jt	use update to r3.12
- */
-
-#include	<vxWorks.h>
-#include	<types.h>
-#include	<stdioLib.h>
-#include	<lstLib.h>
-#include	<string.h>
-#include	<symLib.h>
-#include	<sysSymTbl.h>   /* for sysSymTbl*/
-#include	<a_out.h>       /* for N_TEXT */
-
-#include	<alarm.h>
-#include	<dbDefs.h>
-#include	<dbAccess.h>
-#include	<dbFldTypes.h>
-#include	<errMdef.h>
-#include	<recSup.h>
-#include	<dbEvent.h>		/* Sergey */
-#include	<epicsDynLink.h>	/* Sergey */
-
-#define GEN_SIZE_OFFSET
-#include	<tsubRecord.h>
-#undef  GEN_SIZE_OFFSET
-#include "recGbl.h"
-#include "epicsExport.h"
-
-/* Create RSET - Record Support Entry Table*/
-#define report NULL
-#define initialize NULL
-static long init_record();
-static long process();
-#define special NULL
-static long get_value();
-#define cvt_dbaddr NULL
-#define get_array_info NULL
-#define put_array_info NULL
-static long get_units();
-static long get_precision();
-#define get_enum_str NULL
-#define get_enum_strs NULL
-#define put_enum_str NULL
-static long get_graphic_double();
-static long get_control_double();
-static long get_alarm_double();
-
-rset tsubRSET={
-	RSETNUMBER,
-	report,
-	initialize,
-	init_record,
-	process,
-	special,
-	get_value,
-	cvt_dbaddr,
-	get_array_info,
-	put_array_info,
-	get_units,
-	get_precision,
-	get_enum_str,
-	get_enum_strs,
-	put_enum_str,
-	get_graphic_double,
-	get_control_double,
-	get_alarm_double };
-epicsExportAddress(rset,tsubRSET);
-
-static void set_alarms();
-static long do_sub();
-static long fetch_values();
-static long push_values();
-static void monitor();
-
-#define IN_ARG_MAX 20
-#define INP_ARG_MAX 80
-#define OUT_ARG_MAX 70
-/* Fldnames should have as many as INP_ARG_MAX */
-
-
-static long init_record(ptsub,pass)
-    struct tsubRecord	*ptsub;
-    int pass;
-{
-    FUNCPTR	psubroutine;
-    char	sub_type;
-    char	temp[40];
-    long	status;
-    STATUS	ret;
-    struct link *plink;
-    int i;
-    double *pvalue;
-
-    if (pass==0) {
-      return(0);
-    }
-
-    plink = &ptsub->inpa;
-    pvalue = &ptsub->a;
-    for(i=0; i<INP_ARG_MAX; i++, plink++, pvalue++) {
-        if(plink->type==CONSTANT){
-           recGblInitConstantLink(plink,DBF_DOUBLE,pvalue);
-	   /* *pvalue = plink->value.value; */
-	}
-    }
-
-    /* convert the initialization subroutine name  */
-    temp[0] = 0;			/* all global variables start with _ */
-    if (ptsub->inam[0] != '_'){
-	strcpy(temp,"_");
-    }
-    strcat(temp,ptsub->inam);
-	/* Sergey (symFindByName - > symFindByNameEPICS) */
-	ret = symFindByNameEPICS(sysSymTbl,temp,(void *)&ptsub->sadr,(void *)&sub_type);
-    if ((ret !=OK) || ((sub_type & N_TEXT) == 0)){
-	recGblRecordError(S_db_BadSub,(void *)ptsub,"recTsub(init_record)");
-	return(S_db_BadSub);
-    }
-
-    /* invoke the initialization subroutine */
-    psubroutine = (FUNCPTR)(ptsub->sadr);
-    status = psubroutine(ptsub,process);
-
-    /* convert the subroutine name to an address and type */
-    /* convert the processing subroutine name  */
-    temp[0] = 0;			/* all global variables start with _ */
-    if (ptsub->snam[0] != '_'){
-    	strcpy(temp,"_");
-    }
-    strcat(temp,ptsub->snam);
-	/* Sergey (symFindByName - > symFindByNameEPICS) */
-    ret = symFindByNameEPICS(sysSymTbl, temp, (void *)&ptsub->sadr, (void *)&sub_type);
-    if ((ret < 0) || ((sub_type & N_TEXT) == 0)){
-	recGblRecordError(S_db_BadSub,(void *)ptsub,"recTsub(init_record)");
-	return(S_db_BadSub);
-    }
-    ptsub->styp = sub_type;
-    return(0);
-}
-
-static long process(ptsub)
-	struct tsubRecord *ptsub;
-{
-	long		 status=0;
-	unsigned char	 pact=ptsub->pact;
-
-        if(!ptsub->pact){
-		ptsub->pact = TRUE;
-		status = fetch_values(ptsub);
-		ptsub->pact = FALSE;
-	}
-        if(status==0) status = do_sub(ptsub);
-	if(!pact && ptsub->pact) {
-	  return(0);
-	}
-        ptsub->pact = TRUE;
-	if(status==1) {
-	  return(0);
-	}
-	recGblGetTimeStamp(ptsub);
-        /* check for alarms */
-        set_alarms(ptsub);
-        /* check event list */
-        monitor(ptsub);
-
-	/* Push out the output link data values */
-	status = push_values(ptsub);
-
-        /* process the forward scan link record */
-        recGblFwdLink(ptsub);
-
-        ptsub->pact = FALSE;
-        return(status);
-}
-
-static long get_value(ptsub,pvdes)
-    struct tsubRecord		*ptsub;
-    struct valueDes	*pvdes;
-{
-    pvdes->field_type = DBF_DOUBLE;
-    pvdes->no_elements=1;
-/*  (double *)(pvdes->pvalue) = &ptsub->val; */
-/* Sergey */
-    pvdes->pvalue = (double *)(&ptsub->val);
-    return(0);
-}
-
-static long get_units(paddr,units)
-    struct dbAddr *paddr;
-    char	  *units;
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    strncpy(units,ptsub->egu,sizeof(ptsub->egu));
-    return(0);
-}
-
-static long get_precision(paddr,precision)
-    struct dbAddr *paddr;
-    long	  *precision;
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    *precision = ptsub->prec;
-    if(paddr->pfield==(void *)&ptsub->val) return(0);
-    recGblGetPrec(paddr,precision);
-    return(0);
-}
-
-
-static long get_graphic_double(paddr,pgd)
-    struct dbAddr *paddr;
-    struct dbr_grDouble	*pgd;
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val
-    || paddr->pfield==(void *)&ptsub->hihi
-    || paddr->pfield==(void *)&ptsub->high
-    || paddr->pfield==(void *)&ptsub->low
-    || paddr->pfield==(void *)&ptsub->lolo){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-
-    if(paddr->pfield>=(void *)&ptsub->a && paddr->pfield<=(void *)&ptsub->t){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-    if(paddr->pfield>=(void *)&ptsub->la && paddr->pfield<=(void *)&ptsub->lt){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-    return(0);
-}
-
-static long get_control_double(paddr,pcd)
-    struct dbAddr *paddr;
-    struct dbr_ctrlDouble *pcd;
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val
-    || paddr->pfield==(void *)&ptsub->hihi
-    || paddr->pfield==(void *)&ptsub->high
-    || paddr->pfield==(void *)&ptsub->low
-    || paddr->pfield==(void *)&ptsub->lolo){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-       return(0);
-    }
-
-    if(paddr->pfield>=(void *)&ptsub->a && paddr->pfield<=(void *)&ptsub->t){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-        return(0);
-    }
-    if(paddr->pfield>=(void *)&ptsub->la && paddr->pfield<=(void *)&ptsub->lt){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-        return(0);
-    }
-    return(0);
-}
-
-static long get_alarm_double(paddr,pad)
-    struct dbAddr *paddr;
-    struct dbr_alDouble	*pad;
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val){
-         pad->upper_alarm_limit = ptsub->hihi;
-         pad->upper_warning_limit = ptsub->high;
-         pad->lower_warning_limit = ptsub->low;
-         pad->lower_alarm_limit = ptsub->lolo;
-    } else recGblGetAlarmDouble(paddr,pad);
-    return(0);
-}
-
-static void set_alarms(ptsub)
-    struct tsubRecord	*ptsub;
-{
-	double		val;
-	float		hyst, lalm, hihi, high, low, lolo;
-	unsigned short	hhsv, llsv, hsv, lsv;
-
-	if(ptsub->udf == TRUE ){
- 		recGblSetSevr(ptsub,UDF_ALARM,INVALID_ALARM);
-		return;
-	}
-	hihi = ptsub->hihi; lolo = ptsub->lolo; high = ptsub->high; low = ptsub->low;
-	hhsv = ptsub->hhsv; llsv = ptsub->llsv; hsv = ptsub->hsv; lsv = ptsub->lsv;
-	val = ptsub->val; hyst = ptsub->hyst; lalm = ptsub->lalm;
-
-	/* alarm condition hihi */
-	if (hhsv && (val >= hihi || ((lalm==hihi) && (val >= hihi-hyst)))){
-	        if (recGblSetSevr(ptsub,HIHI_ALARM,ptsub->hhsv)) ptsub->lalm = hihi;
-		return;
-	}
-
-	/* alarm condition lolo */
-	if (llsv && (val <= lolo || ((lalm==lolo) && (val <= lolo+hyst)))){
-	        if (recGblSetSevr(ptsub,LOLO_ALARM,ptsub->llsv)) ptsub->lalm = lolo;
-		return;
-	}
-
-	/* alarm condition high */
-	if (hsv && (val >= high || ((lalm==high) && (val >= high-hyst)))){
-	        if (recGblSetSevr(ptsub,HIGH_ALARM,ptsub->hsv)) ptsub->lalm = high;
-		return;
-	}
-
-	/* alarm condition low */
-	if (lsv && (val <= low || ((lalm==low) && (val <= low+hyst)))){
-	        if (recGblSetSevr(ptsub,LOW_ALARM,ptsub->lsv)) ptsub->lalm = low;
-		return;
-	}
-
-	/* we get here only if val is out of alarm by at least hyst */
-	ptsub->lalm = val;
-	return;
-}
-
-static void monitor(ptsub)
-    struct tsubRecord	*ptsub;
-{
-	unsigned short	monitor_mask;
-	double		delta;
-	double           *pnew;
-	double           *pprev;
-	int             i;
-
-        monitor_mask = recGblResetAlarms(ptsub);
-        monitor_mask |= (DBE_LOG|DBE_VALUE);
-        if(monitor_mask)
-        db_post_events(ptsub,(void *)&(ptsub->val),monitor_mask);
-        /* check for value change */
-        delta = ptsub->mlst - ptsub->val;
-        if(delta<0.0) delta = -delta;
-        if (delta > ptsub->mdel) {
-                /* post events for value change */
-                monitor_mask |= DBE_VALUE;
-                /* update last value monitored */
-                ptsub->mlst = ptsub->val;
-        }
-        /* check for archive change */
-        delta = ptsub->alst - ptsub->val;
-        if(delta<0.0) delta = -delta;
-        if (delta > ptsub->adel) {
-                /* post events on value field for archive change */
-                monitor_mask |= DBE_LOG;
-                /* update last archive value monitored */
-                ptsub->alst = ptsub->val;
-        }
-        /* send out monitors connected to the value field */
-        if (monitor_mask){
-                db_post_events(ptsub,&ptsub->val,monitor_mask);
-        }
-	/* check all link input fields for changes */
-	for(i=0, pnew=&ptsub->a, pprev=&ptsub->la; i<INP_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-	/* check all non-link input fields for changes */
-	for(i=0, pnew=&ptsub->nla, pprev=&ptsub->lnla; i<IN_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-	/* check all output fields for changes */
-	for(i=0, pnew=&ptsub->oa, pprev=&ptsub->loa; i<OUT_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-        return;
-}
-
-static long fetch_values(ptsub)
-struct tsubRecord *ptsub;
-{
-        struct link     *plink; /* structure of the link field  */
-        double           *pvalue;
-        int             i;
-	long		status;
-
-        for(i=0, plink=&ptsub->inpa, pvalue=&ptsub->a;
-        		i<INP_ARG_MAX; i++, plink++, pvalue++)
-        {
-		status=dbGetLink(plink,DBR_DOUBLE, pvalue,0,0);
-		/*status=recGblGetFastLink(plink,(void *)ptsub,pvalue);*/
-		if (!RTN_SUCCESS(status)) return(-1);
-        }
-        return(0);
-}
-
-static long push_values(ptsub)
-struct tsubRecord *ptsub;
-{
-        struct link     *plink; /* structure of the link field  */
-        double           *pvalue;
-        int             i;
-	long		status;
-
-        for(i=0, plink=&ptsub->outa, pvalue=&ptsub->oa;
-        		i<OUT_ARG_MAX; i++, plink++, pvalue++)
-        {
-		status=dbPutLink(plink,DBR_DOUBLE, pvalue,0);
-		/*status=recGblPutFastLink(plink,(void *)ptsub,pvalue);*/
-		if (!RTN_SUCCESS(status)) return(-1);
-        }
-        return(0);
-}
-
-static long do_sub(ptsub)
-struct tsubRecord *ptsub;  /* pointer to subroutine record  */
-{
-	long	status;
-	FUNCPTR	psubroutine;
-
-
-	/* call the subroutine */
-	psubroutine = (FUNCPTR)(ptsub->sadr);
-	if(psubroutine==NULL) {
-               	recGblSetSevr(ptsub,BAD_SUB_ALARM,INVALID_ALARM);
-		return(0);
-	}
-	status = psubroutine(ptsub);
-	if(status < 0){
-               	recGblSetSevr(ptsub,SOFT_ALARM,ptsub->brsv);
-	} else ptsub->udf = FALSE;
-	return(status);
-}
diff --git a/pmacApp/src/tsubRecord.dbd b/pmacApp/src/tsubRecord.dbd
deleted file mode 100644
index 5b7f59d..0000000
--- a/pmacApp/src/tsubRecord.dbd
+++ /dev/null
@@ -1,2694 +0,0 @@
-recordtype(tsub) {
-	include "dbCommon.dbd" 
-	field(VAL,DBF_DOUBLE) {
-		prompt("Result")
-		asl(ASL0)
-		pp(TRUE)
-	}
-	field(INAM,DBF_STRING) {
-		prompt("Init Routine Name")
-		promptgroup(GUI_COMMON)
-		special(SPC_NOMOD)
-		interest(1)
-		size(16)
-	}
-	field(SNAM,DBF_STRING) {
-		prompt("Subroutine Name")
-		promptgroup(GUI_ALARMS)
-		special(SPC_NOMOD)
-		interest(1)
-		size(16)
-	}
-	field(SADR,DBF_NOACCESS) {
-		prompt("Subroutine Address")
-		special(SPC_NOMOD)
-		interest(4)
-		size(4)
-		extra("void *		sadr")
-	}
-	field(STYP,DBF_SHORT) {
-		prompt("Subr symbol type")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(EGU,DBF_STRING) {
-		prompt("Units Name")
-		promptgroup(GUI_TIMER)
-		interest(1)
-		size(16)
-	}
-	field(HOPR,DBF_FLOAT) {
-		prompt("High Operating Rng")
-		promptgroup(GUI_WAVE)
-		interest(1)
-	}
-	field(LOPR,DBF_FLOAT) {
-		prompt("Low Operating Range")
-		promptgroup(GUI_SCAN)
-		interest(1)
-	}
-	field(HIHI,DBF_FLOAT) {
-		prompt("Hihi Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOLO,DBF_FLOAT) {
-		prompt("Lolo Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(HIGH,DBF_FLOAT) {
-		prompt("High Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOW,DBF_FLOAT) {
-		prompt("Low Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(PREC,DBF_SHORT) {
-		prompt("Display Precision")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(BRSV,DBF_MENU) {
-		prompt("Bad Return Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HHSV,DBF_MENU) {
-		prompt("Hihi Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LLSV,DBF_MENU) {
-		prompt("Lolo Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HSV,DBF_MENU) {
-		prompt("High Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LSV,DBF_MENU) {
-		prompt("Low Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HYST,DBF_DOUBLE) {
-		prompt("Alarm Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(ADEL,DBF_DOUBLE) {
-		prompt("Archive Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(MDEL,DBF_DOUBLE) {
-		prompt("Monitor Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(LALM,DBF_DOUBLE) {
-		prompt("Last Value Alarmed")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(ALST,DBF_DOUBLE) {
-		prompt("Last Value Archived")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(MLST,DBF_DOUBLE) {
-		prompt("Last Value Monitored")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(OUTA,DBF_OUTLINK) {
-		prompt("Output Link A")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTB,DBF_OUTLINK) {
-		prompt("Output Link B")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTC,DBF_OUTLINK) {
-		prompt("Output Link C")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTD,DBF_OUTLINK) {
-		prompt("Output Link D")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTE,DBF_OUTLINK) {
-		prompt("Output Link E")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTF,DBF_OUTLINK) {
-		prompt("Output Link F")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTG,DBF_OUTLINK) {
-		prompt("Output Link G")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTH,DBF_OUTLINK) {
-		prompt("Output Link H")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTI,DBF_OUTLINK) {
-		prompt("Output Link I")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTJ,DBF_OUTLINK) {
-		prompt("Output Link J")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA0,DBF_OUTLINK) {
-		prompt("Output Link A0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA1,DBF_OUTLINK) {
-		prompt("Output Link A1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA2,DBF_OUTLINK) {
-		prompt("Output Link A2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA3,DBF_OUTLINK) {
-		prompt("Output Link A3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA4,DBF_OUTLINK) {
-		prompt("Output Link A4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA5,DBF_OUTLINK) {
-		prompt("Output Link A5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA6,DBF_OUTLINK) {
-		prompt("Output Link A6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA7,DBF_OUTLINK) {
-		prompt("Output Link A7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA8,DBF_OUTLINK) {
-		prompt("Output Link A8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA9,DBF_OUTLINK) {
-		prompt("Output Link A9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB0,DBF_OUTLINK) {
-		prompt("Output Link B0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB1,DBF_OUTLINK) {
-		prompt("Output Link B1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB2,DBF_OUTLINK) {
-		prompt("Output Link B2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB3,DBF_OUTLINK) {
-		prompt("Output Link B3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB4,DBF_OUTLINK) {
-		prompt("Output Link B4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB5,DBF_OUTLINK) {
-		prompt("Output Link B5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB6,DBF_OUTLINK) {
-		prompt("Output Link B6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB7,DBF_OUTLINK) {
-		prompt("Output Link B7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB8,DBF_OUTLINK) {
-		prompt("Output Link B8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB9,DBF_OUTLINK) {
-		prompt("Output Link B9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC0,DBF_OUTLINK) {
-		prompt("Output Link C0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC1,DBF_OUTLINK) {
-		prompt("Output Link C1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC2,DBF_OUTLINK) {
-		prompt("Output Link C2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC3,DBF_OUTLINK) {
-		prompt("Output Link C3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC4,DBF_OUTLINK) {
-		prompt("Output Link C4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC5,DBF_OUTLINK) {
-		prompt("Output Link C5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC6,DBF_OUTLINK) {
-		prompt("Output Link C6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC7,DBF_OUTLINK) {
-		prompt("Output Link C7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC8,DBF_OUTLINK) {
-		prompt("Output Link C8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC9,DBF_OUTLINK) {
-		prompt("Output Link C9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD0,DBF_OUTLINK) {
-		prompt("Output Link D0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD1,DBF_OUTLINK) {
-		prompt("Output Link D1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD2,DBF_OUTLINK) {
-		prompt("Output Link D2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD3,DBF_OUTLINK) {
-		prompt("Output Link D3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD4,DBF_OUTLINK) {
-		prompt("Output Link D4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD5,DBF_OUTLINK) {
-		prompt("Output Link D5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD6,DBF_OUTLINK) {
-		prompt("Output Link D6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD7,DBF_OUTLINK) {
-		prompt("Output Link D7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD8,DBF_OUTLINK) {
-		prompt("Output Link D8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD9,DBF_OUTLINK) {
-		prompt("Output Link D9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE0,DBF_OUTLINK) {
-		prompt("Output Link E0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE1,DBF_OUTLINK) {
-		prompt("Output Link E1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE2,DBF_OUTLINK) {
-		prompt("Output Link E2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE3,DBF_OUTLINK) {
-		prompt("Output Link E3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE4,DBF_OUTLINK) {
-		prompt("Output Link E4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE5,DBF_OUTLINK) {
-		prompt("Output Link E5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE6,DBF_OUTLINK) {
-		prompt("Output Link E6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE7,DBF_OUTLINK) {
-		prompt("Output Link E7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE8,DBF_OUTLINK) {
-		prompt("Output Link E8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE9,DBF_OUTLINK) {
-		prompt("Output Link E9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF0,DBF_OUTLINK) {
-		prompt("Output Link F0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF1,DBF_OUTLINK) {
-		prompt("Output Link F1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF2,DBF_OUTLINK) {
-		prompt("Output Link F2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF3,DBF_OUTLINK) {
-		prompt("Output Link F3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF4,DBF_OUTLINK) {
-		prompt("Output Link F4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF5,DBF_OUTLINK) {
-		prompt("Output Link F5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF6,DBF_OUTLINK) {
-		prompt("Output Link F6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF7,DBF_OUTLINK) {
-		prompt("Output Link F7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF8,DBF_OUTLINK) {
-		prompt("Output Link F8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF9,DBF_OUTLINK) {
-		prompt("Output Link F9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OA,DBF_DOUBLE) {
-		prompt("Output Value A")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB,DBF_DOUBLE) {
-		prompt("Output Value B")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC,DBF_DOUBLE) {
-		prompt("Output Value C")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD,DBF_DOUBLE) {
-		prompt("Output Value D")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE,DBF_DOUBLE) {
-		prompt("Output Value E")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF,DBF_DOUBLE) {
-		prompt("Output Value F")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OG,DBF_DOUBLE) {
-		prompt("Output Value G")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OH,DBF_DOUBLE) {
-		prompt("Output Value H")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OI,DBF_DOUBLE) {
-		prompt("Output Value I")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OJ,DBF_DOUBLE) {
-		prompt("Output Value J")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA0,DBF_DOUBLE) {
-		prompt("Output Value A0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA1,DBF_DOUBLE) {
-		prompt("Output Value A1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA2,DBF_DOUBLE) {
-		prompt("Output Value A2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA3,DBF_DOUBLE) {
-		prompt("Output Value A3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA4,DBF_DOUBLE) {
-		prompt("Output Value A4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA5,DBF_DOUBLE) {
-		prompt("Output Value A5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA6,DBF_DOUBLE) {
-		prompt("Output Value A6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA7,DBF_DOUBLE) {
-		prompt("Output Value A7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA8,DBF_DOUBLE) {
-		prompt("Output Value A8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA9,DBF_DOUBLE) {
-		prompt("Output Value A9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB0,DBF_DOUBLE) {
-		prompt("Output Value B0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB1,DBF_DOUBLE) {
-		prompt("Output Value B1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB2,DBF_DOUBLE) {
-		prompt("Output Value B2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB3,DBF_DOUBLE) {
-		prompt("Output Value B3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB4,DBF_DOUBLE) {
-		prompt("Output Value B4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB5,DBF_DOUBLE) {
-		prompt("Output Value B5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB6,DBF_DOUBLE) {
-		prompt("Output Value B6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB7,DBF_DOUBLE) {
-		prompt("Output Value B7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB8,DBF_DOUBLE) {
-		prompt("Output Value B8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB9,DBF_DOUBLE) {
-		prompt("Output Value B9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC0,DBF_DOUBLE) {
-		prompt("Output Value C0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC1,DBF_DOUBLE) {
-		prompt("Output Value C1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC2,DBF_DOUBLE) {
-		prompt("Output Value C2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC3,DBF_DOUBLE) {
-		prompt("Output Value C3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC4,DBF_DOUBLE) {
-		prompt("Output Value C4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC5,DBF_DOUBLE) {
-		prompt("Output Value C5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC6,DBF_DOUBLE) {
-		prompt("Output Value C6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC7,DBF_DOUBLE) {
-		prompt("Output Value C7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC8,DBF_DOUBLE) {
-		prompt("Output Value C8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC9,DBF_DOUBLE) {
-		prompt("Output Value C9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD0,DBF_DOUBLE) {
-		prompt("Output Value D0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD1,DBF_DOUBLE) {
-		prompt("Output Value D1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD2,DBF_DOUBLE) {
-		prompt("Output Value D2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD3,DBF_DOUBLE) {
-		prompt("Output Value D3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD4,DBF_DOUBLE) {
-		prompt("Output Value D4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD5,DBF_DOUBLE) {
-		prompt("Output Value D5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD6,DBF_DOUBLE) {
-		prompt("Output Value D6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD7,DBF_DOUBLE) {
-		prompt("Output Value D7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD8,DBF_DOUBLE) {
-		prompt("Output Value D8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD9,DBF_DOUBLE) {
-		prompt("Output Value D9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE0,DBF_DOUBLE) {
-		prompt("Output Value E0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE1,DBF_DOUBLE) {
-		prompt("Output Value E1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE2,DBF_DOUBLE) {
-		prompt("Output Value E2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE3,DBF_DOUBLE) {
-		prompt("Output Value E3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE4,DBF_DOUBLE) {
-		prompt("Output Value E4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE5,DBF_DOUBLE) {
-		prompt("Output Value E5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE6,DBF_DOUBLE) {
-		prompt("Output Value E6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE7,DBF_DOUBLE) {
-		prompt("Output Value E7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE8,DBF_DOUBLE) {
-		prompt("Output Value E8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE9,DBF_DOUBLE) {
-		prompt("Output Value E9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF0,DBF_DOUBLE) {
-		prompt("Output Value F0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF1,DBF_DOUBLE) {
-		prompt("Output Value F1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF2,DBF_DOUBLE) {
-		prompt("Output Value F2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF3,DBF_DOUBLE) {
-		prompt("Output Value F3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF4,DBF_DOUBLE) {
-		prompt("Output Value F4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF5,DBF_DOUBLE) {
-		prompt("Output Value F5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF6,DBF_DOUBLE) {
-		prompt("Output Value F6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF7,DBF_DOUBLE) {
-		prompt("Output Value F7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF8,DBF_DOUBLE) {
-		prompt("Output Value F8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF9,DBF_DOUBLE) {
-		prompt("Output Value F9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(LOA,DBF_DOUBLE) {
-		prompt("Prev Value of OA")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB,DBF_DOUBLE) {
-		prompt("Prev Value of OB")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC,DBF_DOUBLE) {
-		prompt("Prev Value of OC")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD,DBF_DOUBLE) {
-		prompt("Prev Value of OD")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE,DBF_DOUBLE) {
-		prompt("Prev Value of OE")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF,DBF_DOUBLE) {
-		prompt("Prev Value of OF")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOG,DBF_DOUBLE) {
-		prompt("Prev Value of OG")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOH,DBF_DOUBLE) {
-		prompt("Prev Value of OH")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOI,DBF_DOUBLE) {
-		prompt("Prev Value of OI")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOJ,DBF_DOUBLE) {
-		prompt("Prev Value of OJ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA0,DBF_DOUBLE) {
-		prompt("Prev Value of OA0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA1,DBF_DOUBLE) {
-		prompt("Prev Value of OA1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA2,DBF_DOUBLE) {
-		prompt("Prev Value of OA2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA3,DBF_DOUBLE) {
-		prompt("Prev Value of OA3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA4,DBF_DOUBLE) {
-		prompt("Prev Value of OA4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA5,DBF_DOUBLE) {
-		prompt("Prev Value of OA5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA6,DBF_DOUBLE) {
-		prompt("Prev Value of OA6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA7,DBF_DOUBLE) {
-		prompt("Prev Value of OA7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA8,DBF_DOUBLE) {
-		prompt("Prev Value of OA8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA9,DBF_DOUBLE) {
-		prompt("Prev Value of OA9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB0,DBF_DOUBLE) {
-		prompt("Prev Value of OB0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB1,DBF_DOUBLE) {
-		prompt("Prev Value of OB1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB2,DBF_DOUBLE) {
-		prompt("Prev Value of OB2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB3,DBF_DOUBLE) {
-		prompt("Prev Value of OB3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB4,DBF_DOUBLE) {
-		prompt("Prev Value of OB4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB5,DBF_DOUBLE) {
-		prompt("Prev Value of OB5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB6,DBF_DOUBLE) {
-		prompt("Prev Value of OB6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB7,DBF_DOUBLE) {
-		prompt("Prev Value of OB7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB8,DBF_DOUBLE) {
-		prompt("Prev Value of OB8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB9,DBF_DOUBLE) {
-		prompt("Prev Value of OB9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC0,DBF_DOUBLE) {
-		prompt("Prev Value of OC0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC1,DBF_DOUBLE) {
-		prompt("Prev Value of OC1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC2,DBF_DOUBLE) {
-		prompt("Prev Value of OC2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC3,DBF_DOUBLE) {
-		prompt("Prev Value of OC3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC4,DBF_DOUBLE) {
-		prompt("Prev Value of OC4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC5,DBF_DOUBLE) {
-		prompt("Prev Value of OC5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC6,DBF_DOUBLE) {
-		prompt("Prev Value of OC6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC7,DBF_DOUBLE) {
-		prompt("Prev Value of OC7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC8,DBF_DOUBLE) {
-		prompt("Prev Value of OC8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC9,DBF_DOUBLE) {
-		prompt("Prev Value of OC9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD0,DBF_DOUBLE) {
-		prompt("Prev Value of OD0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD1,DBF_DOUBLE) {
-		prompt("Prev Value of OD1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD2,DBF_DOUBLE) {
-		prompt("Prev Value of OD2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD3,DBF_DOUBLE) {
-		prompt("Prev Value of OD3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD4,DBF_DOUBLE) {
-		prompt("Prev Value of OD4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD5,DBF_DOUBLE) {
-		prompt("Prev Value of OD5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD6,DBF_DOUBLE) {
-		prompt("Prev Value of OD6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD7,DBF_DOUBLE) {
-		prompt("Prev Value of OD7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD8,DBF_DOUBLE) {
-		prompt("Prev Value of OD8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD9,DBF_DOUBLE) {
-		prompt("Prev Value of OD9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE0,DBF_DOUBLE) {
-		prompt("Prev Value of OE0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE1,DBF_DOUBLE) {
-		prompt("Prev Value of OE1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE2,DBF_DOUBLE) {
-		prompt("Prev Value of OE2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE3,DBF_DOUBLE) {
-		prompt("Prev Value of OE3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE4,DBF_DOUBLE) {
-		prompt("Prev Value of OE4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE5,DBF_DOUBLE) {
-		prompt("Prev Value of OE5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE6,DBF_DOUBLE) {
-		prompt("Prev Value of OE6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE7,DBF_DOUBLE) {
-		prompt("Prev Value of OE7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE8,DBF_DOUBLE) {
-		prompt("Prev Value of OE8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE9,DBF_DOUBLE) {
-		prompt("Prev Value of OE9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF0,DBF_DOUBLE) {
-		prompt("Prev Value of OF0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF1,DBF_DOUBLE) {
-		prompt("Prev Value of OF1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF2,DBF_DOUBLE) {
-		prompt("Prev Value of OF2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF3,DBF_DOUBLE) {
-		prompt("Prev Value of OF3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF4,DBF_DOUBLE) {
-		prompt("Prev Value of OF4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF5,DBF_DOUBLE) {
-		prompt("Prev Value of OF5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF6,DBF_DOUBLE) {
-		prompt("Prev Value of OF6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF7,DBF_DOUBLE) {
-		prompt("Prev Value of OF7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF8,DBF_DOUBLE) {
-		prompt("Prev Value of OF8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF9,DBF_DOUBLE) {
-		prompt("Prev Value of OF9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(INPA,DBF_INLINK) {
-		prompt("Input A")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPB,DBF_INLINK) {
-		prompt("Input B")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPC,DBF_INLINK) {
-		prompt("Input C")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPD,DBF_INLINK) {
-		prompt("Input D")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPE,DBF_INLINK) {
-		prompt("Input E")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPF,DBF_INLINK) {
-		prompt("Input F")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPG,DBF_INLINK) {
-		prompt("Input G")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPH,DBF_INLINK) {
-		prompt("Input H")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPI,DBF_INLINK) {
-		prompt("Input I")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPJ,DBF_INLINK) {
-		prompt("Input J")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPK,DBF_INLINK) {
-		prompt("Input K")
-		promptgroup(GUI_MBB)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPL,DBF_INLINK) {
-		prompt("Input L")
-		promptgroup(GUI_MOTOR)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPM,DBF_INLINK) {
-		prompt("Input M")
-		promptgroup(GUI_OUTPUT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPN,DBF_INLINK) {
-		prompt("Input N")
-		promptgroup(GUI_PID)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPO,DBF_INLINK) {
-		prompt("Input O")
-		promptgroup(GUI_PULSE)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPP,DBF_INLINK) {
-		prompt("Input P")
-		promptgroup(GUI_SELECT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPQ,DBF_INLINK) {
-		prompt("Input Q")
-		promptgroup(GUI_SEQ1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPR,DBF_INLINK) {
-		prompt("Input R")
-		promptgroup(GUI_SEQ2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPS,DBF_INLINK) {
-		prompt("Input S")
-		promptgroup(GUI_SEQ3)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPT,DBF_INLINK) {
-		prompt("Input T")
-		promptgroup(GUI_SUB)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA0,DBF_INLINK) {
-		prompt("Input A0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA1,DBF_INLINK) {
-		prompt("Input A1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA2,DBF_INLINK) {
-		prompt("Input A2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA3,DBF_INLINK) {
-		prompt("Input A3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA4,DBF_INLINK) {
-		prompt("Input A4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA5,DBF_INLINK) {
-		prompt("Input A5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA6,DBF_INLINK) {
-		prompt("Input A6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA7,DBF_INLINK) {
-		prompt("Input A7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA8,DBF_INLINK) {
-		prompt("Input A8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA9,DBF_INLINK) {
-		prompt("Input A9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB0,DBF_INLINK) {
-		prompt("Input B0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB1,DBF_INLINK) {
-		prompt("Input B1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB2,DBF_INLINK) {
-		prompt("Input B2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB3,DBF_INLINK) {
-		prompt("Input B3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB4,DBF_INLINK) {
-		prompt("Input B4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB5,DBF_INLINK) {
-		prompt("Input B5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB6,DBF_INLINK) {
-		prompt("Input B6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB7,DBF_INLINK) {
-		prompt("Input B7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB8,DBF_INLINK) {
-		prompt("Input B8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB9,DBF_INLINK) {
-		prompt("Input B9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC0,DBF_INLINK) {
-		prompt("Input C0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC1,DBF_INLINK) {
-		prompt("Input C1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC2,DBF_INLINK) {
-		prompt("Input C2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC3,DBF_INLINK) {
-		prompt("Input C3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC4,DBF_INLINK) {
-		prompt("Input C4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC5,DBF_INLINK) {
-		prompt("Input C5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC6,DBF_INLINK) {
-		prompt("Input C6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC7,DBF_INLINK) {
-		prompt("Input C7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC8,DBF_INLINK) {
-		prompt("Input C8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC9,DBF_INLINK) {
-		prompt("Input C9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD0,DBF_INLINK) {
-		prompt("Input D0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD1,DBF_INLINK) {
-		prompt("Input D1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD2,DBF_INLINK) {
-		prompt("Input D2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD3,DBF_INLINK) {
-		prompt("Input D3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD4,DBF_INLINK) {
-		prompt("Input D4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD5,DBF_INLINK) {
-		prompt("Input D5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD6,DBF_INLINK) {
-		prompt("Input D6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD7,DBF_INLINK) {
-		prompt("Input D7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD8,DBF_INLINK) {
-		prompt("Input D8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD9,DBF_INLINK) {
-		prompt("Input D9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE0,DBF_INLINK) {
-		prompt("Input E0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE1,DBF_INLINK) {
-		prompt("Input E1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE2,DBF_INLINK) {
-		prompt("Input E2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE3,DBF_INLINK) {
-		prompt("Input E3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE4,DBF_INLINK) {
-		prompt("Input E4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE5,DBF_INLINK) {
-		prompt("Input E5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE6,DBF_INLINK) {
-		prompt("Input E6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE7,DBF_INLINK) {
-		prompt("Input E7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE8,DBF_INLINK) {
-		prompt("Input E8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE9,DBF_INLINK) {
-		prompt("Input E9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF0,DBF_INLINK) {
-		prompt("Input F0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF1,DBF_INLINK) {
-		prompt("Input F1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF2,DBF_INLINK) {
-		prompt("Input F2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF3,DBF_INLINK) {
-		prompt("Input F3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF4,DBF_INLINK) {
-		prompt("Input F4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF5,DBF_INLINK) {
-		prompt("Input F5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF6,DBF_INLINK) {
-		prompt("Input F6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF7,DBF_INLINK) {
-		prompt("Input F7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF8,DBF_INLINK) {
-		prompt("Input F8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF9,DBF_INLINK) {
-		prompt("Input F9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(A,DBF_DOUBLE) {
-		prompt("Value of Input A")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B,DBF_DOUBLE) {
-		prompt("Value of Input B")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C,DBF_DOUBLE) {
-		prompt("Value of Input C")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D,DBF_DOUBLE) {
-		prompt("Value of Input D")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E,DBF_DOUBLE) {
-		prompt("Value of Input E")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F,DBF_DOUBLE) {
-		prompt("Value of Input F")
-		pp(TRUE)
-		interest(1)
-	}
-	field(G,DBF_DOUBLE) {
-		prompt("Value of Input G")
-		pp(TRUE)
-		interest(1)
-	}
-	field(H,DBF_DOUBLE) {
-		prompt("Value of Input H")
-		pp(TRUE)
-		interest(1)
-	}
-	field(I,DBF_DOUBLE) {
-		prompt("Value of Input I")
-		pp(TRUE)
-		interest(1)
-	}
-	field(J,DBF_DOUBLE) {
-		prompt("Value of Input J")
-		pp(TRUE)
-		interest(1)
-	}
-	field(K,DBF_DOUBLE) {
-		prompt("Value of Input K")
-		pp(TRUE)
-		interest(1)
-	}
-	field(L,DBF_DOUBLE) {
-		prompt("Value of Input L")
-		pp(TRUE)
-		interest(1)
-	}
-	field(M,DBF_DOUBLE) {
-		prompt("Value of Input M")
-		pp(TRUE)
-		interest(1)
-	}
-	field(N,DBF_DOUBLE) {
-		prompt("Value of Input N")
-		pp(TRUE)
-		interest(1)
-	}
-	field(O,DBF_DOUBLE) {
-		prompt("Value of Input O")
-		pp(TRUE)
-		interest(1)
-	}
-	field(P,DBF_DOUBLE) {
-		prompt("Value of Input P")
-		pp(TRUE)
-		interest(1)
-	}
-	field(Q,DBF_DOUBLE) {
-		prompt("Value of Input Q")
-		pp(TRUE)
-		interest(1)
-	}
-	field(R,DBF_DOUBLE) {
-		prompt("Value of Input R")
-		pp(TRUE)
-		interest(1)
-	}
-	field(S,DBF_DOUBLE) {
-		prompt("Value of Input S")
-		pp(TRUE)
-		interest(1)
-	}
-	field(T,DBF_DOUBLE) {
-		prompt("Value of Input T")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A0,DBF_DOUBLE) {
-		prompt("Value of Input A0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A1,DBF_DOUBLE) {
-		prompt("Value of Input A1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A2,DBF_DOUBLE) {
-		prompt("Value of Input A2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A3,DBF_DOUBLE) {
-		prompt("Value of Input A3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A4,DBF_DOUBLE) {
-		prompt("Value of Input A4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A5,DBF_DOUBLE) {
-		prompt("Value of Input A5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A6,DBF_DOUBLE) {
-		prompt("Value of Input A6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A7,DBF_DOUBLE) {
-		prompt("Value of Input A7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A8,DBF_DOUBLE) {
-		prompt("Value of Input A8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A9,DBF_DOUBLE) {
-		prompt("Value of Input A9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B0,DBF_DOUBLE) {
-		prompt("Value of Input B0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B1,DBF_DOUBLE) {
-		prompt("Value of Input B1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B2,DBF_DOUBLE) {
-		prompt("Value of Input B2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B3,DBF_DOUBLE) {
-		prompt("Value of Input B3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B4,DBF_DOUBLE) {
-		prompt("Value of Input B4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B5,DBF_DOUBLE) {
-		prompt("Value of Input B5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B6,DBF_DOUBLE) {
-		prompt("Value of Input B6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B7,DBF_DOUBLE) {
-		prompt("Value of Input B7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B8,DBF_DOUBLE) {
-		prompt("Value of Input B8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B9,DBF_DOUBLE) {
-		prompt("Value of Input B9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C0,DBF_DOUBLE) {
-		prompt("Value of Input C0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C1,DBF_DOUBLE) {
-		prompt("Value of Input C1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C2,DBF_DOUBLE) {
-		prompt("Value of Input C2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C3,DBF_DOUBLE) {
-		prompt("Value of Input C3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C4,DBF_DOUBLE) {
-		prompt("Value of Input C4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C5,DBF_DOUBLE) {
-		prompt("Value of Input C5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C6,DBF_DOUBLE) {
-		prompt("Value of Input C6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C7,DBF_DOUBLE) {
-		prompt("Value of Input C7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C8,DBF_DOUBLE) {
-		prompt("Value of Input C8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C9,DBF_DOUBLE) {
-		prompt("Value of Input C9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D0,DBF_DOUBLE) {
-		prompt("Value of Input D0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D1,DBF_DOUBLE) {
-		prompt("Value of Input D1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D2,DBF_DOUBLE) {
-		prompt("Value of Input D2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D3,DBF_DOUBLE) {
-		prompt("Value of Input D3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D4,DBF_DOUBLE) {
-		prompt("Value of Input D4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D5,DBF_DOUBLE) {
-		prompt("Value of Input D5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D6,DBF_DOUBLE) {
-		prompt("Value of Input D6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D7,DBF_DOUBLE) {
-		prompt("Value of Input D7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D8,DBF_DOUBLE) {
-		prompt("Value of Input D8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D9,DBF_DOUBLE) {
-		prompt("Value of Input D9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E0,DBF_DOUBLE) {
-		prompt("Value of Input E0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E1,DBF_DOUBLE) {
-		prompt("Value of Input E1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E2,DBF_DOUBLE) {
-		prompt("Value of Input E2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E3,DBF_DOUBLE) {
-		prompt("Value of Input E3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E4,DBF_DOUBLE) {
-		prompt("Value of Input E4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E5,DBF_DOUBLE) {
-		prompt("Value of Input E5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E6,DBF_DOUBLE) {
-		prompt("Value of Input E6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E7,DBF_DOUBLE) {
-		prompt("Value of Input E7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E8,DBF_DOUBLE) {
-		prompt("Value of Input E8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E9,DBF_DOUBLE) {
-		prompt("Value of Input E9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F0,DBF_DOUBLE) {
-		prompt("Value of Input F0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F1,DBF_DOUBLE) {
-		prompt("Value of Input F1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F2,DBF_DOUBLE) {
-		prompt("Value of Input F2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F3,DBF_DOUBLE) {
-		prompt("Value of Input F3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F4,DBF_DOUBLE) {
-		prompt("Value of Input F4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F5,DBF_DOUBLE) {
-		prompt("Value of Input F5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F6,DBF_DOUBLE) {
-		prompt("Value of Input F6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F7,DBF_DOUBLE) {
-		prompt("Value of Input F7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F8,DBF_DOUBLE) {
-		prompt("Value of Input F8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F9,DBF_DOUBLE) {
-		prompt("Value of Input F9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(LA,DBF_DOUBLE) {
-		prompt("Prev Value of A")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB,DBF_DOUBLE) {
-		prompt("Prev Value of B")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC,DBF_DOUBLE) {
-		prompt("Prev Value of C")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD,DBF_DOUBLE) {
-		prompt("Prev Value of D")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE,DBF_DOUBLE) {
-		prompt("Prev Value of E")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF,DBF_DOUBLE) {
-		prompt("Prev Value of F")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LG,DBF_DOUBLE) {
-		prompt("Prev Value of G")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LH,DBF_DOUBLE) {
-		prompt("Prev Value of H")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LI,DBF_DOUBLE) {
-		prompt("Prev Value of I")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LJ,DBF_DOUBLE) {
-		prompt("Prev Value of J")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LK,DBF_DOUBLE) {
-		prompt("Prev Value of K")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LL,DBF_DOUBLE) {
-		prompt("Prev Value of L")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LM,DBF_DOUBLE) {
-		prompt("Prev Value of M")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LN,DBF_DOUBLE) {
-		prompt("Prev Value of N")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LO,DBF_DOUBLE) {
-		prompt("Prev Value of O")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LP,DBF_DOUBLE) {
-		prompt("Prev Value of P")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LQ,DBF_DOUBLE) {
-		prompt("Prev Value of Q")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LR,DBF_DOUBLE) {
-		prompt("Prev Value of R")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LS,DBF_DOUBLE) {
-		prompt("Prev Value of S")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LT,DBF_DOUBLE) {
-		prompt("Prev Value of T")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA0,DBF_DOUBLE) {
-		prompt("Prev Value of A0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA1,DBF_DOUBLE) {
-		prompt("Prev Value of A1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA2,DBF_DOUBLE) {
-		prompt("Prev Value of A2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA3,DBF_DOUBLE) {
-		prompt("Prev Value of A3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA4,DBF_DOUBLE) {
-		prompt("Prev Value of A4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA5,DBF_DOUBLE) {
-		prompt("Prev Value of A5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA6,DBF_DOUBLE) {
-		prompt("Prev Value of A6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA7,DBF_DOUBLE) {
-		prompt("Prev Value of A7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA8,DBF_DOUBLE) {
-		prompt("Prev Value of A8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA9,DBF_DOUBLE) {
-		prompt("Prev Value of A9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB0,DBF_DOUBLE) {
-		prompt("Prev Value of B0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB1,DBF_DOUBLE) {
-		prompt("Prev Value of B1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB2,DBF_DOUBLE) {
-		prompt("Prev Value of B2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB3,DBF_DOUBLE) {
-		prompt("Prev Value of B3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB4,DBF_DOUBLE) {
-		prompt("Prev Value of B4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB5,DBF_DOUBLE) {
-		prompt("Prev Value of B5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB6,DBF_DOUBLE) {
-		prompt("Prev Value of B6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB7,DBF_DOUBLE) {
-		prompt("Prev Value of B7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB8,DBF_DOUBLE) {
-		prompt("Prev Value of B8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB9,DBF_DOUBLE) {
-		prompt("Prev Value of B9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC0,DBF_DOUBLE) {
-		prompt("Prev Value of C0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC1,DBF_DOUBLE) {
-		prompt("Prev Value of C1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC2,DBF_DOUBLE) {
-		prompt("Prev Value of C2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC3,DBF_DOUBLE) {
-		prompt("Prev Value of C3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC4,DBF_DOUBLE) {
-		prompt("Prev Value of C4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC5,DBF_DOUBLE) {
-		prompt("Prev Value of C5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC6,DBF_DOUBLE) {
-		prompt("Prev Value of C6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC7,DBF_DOUBLE) {
-		prompt("Prev Value of C7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC8,DBF_DOUBLE) {
-		prompt("Prev Value of C8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC9,DBF_DOUBLE) {
-		prompt("Prev Value of C9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD0,DBF_DOUBLE) {
-		prompt("Prev Value of D0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD1,DBF_DOUBLE) {
-		prompt("Prev Value of D1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD2,DBF_DOUBLE) {
-		prompt("Prev Value of D2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD3,DBF_DOUBLE) {
-		prompt("Prev Value of D3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD4,DBF_DOUBLE) {
-		prompt("Prev Value of D4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD5,DBF_DOUBLE) {
-		prompt("Prev Value of D5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD6,DBF_DOUBLE) {
-		prompt("Prev Value of D6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD7,DBF_DOUBLE) {
-		prompt("Prev Value of D7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD8,DBF_DOUBLE) {
-		prompt("Prev Value of D8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD9,DBF_DOUBLE) {
-		prompt("Prev Value of D9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE0,DBF_DOUBLE) {
-		prompt("Prev Value of E0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE1,DBF_DOUBLE) {
-		prompt("Prev Value of E1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE2,DBF_DOUBLE) {
-		prompt("Prev Value of E2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE3,DBF_DOUBLE) {
-		prompt("Prev Value of E3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE4,DBF_DOUBLE) {
-		prompt("Prev Value of E4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE5,DBF_DOUBLE) {
-		prompt("Prev Value of E5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE6,DBF_DOUBLE) {
-		prompt("Prev Value of E6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE7,DBF_DOUBLE) {
-		prompt("Prev Value of E7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE8,DBF_DOUBLE) {
-		prompt("Prev Value of E8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE9,DBF_DOUBLE) {
-		prompt("Prev Value of E9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF0,DBF_DOUBLE) {
-		prompt("Prev Value of F0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF1,DBF_DOUBLE) {
-		prompt("Prev Value of F1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF2,DBF_DOUBLE) {
-		prompt("Prev Value of F2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF3,DBF_DOUBLE) {
-		prompt("Prev Value of F3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF4,DBF_DOUBLE) {
-		prompt("Prev Value of F4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF5,DBF_DOUBLE) {
-		prompt("Prev Value of F5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF6,DBF_DOUBLE) {
-		prompt("Prev Value of F6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF7,DBF_DOUBLE) {
-		prompt("Prev Value of F7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF8,DBF_DOUBLE) {
-		prompt("Prev Value of F8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF9,DBF_DOUBLE) {
-		prompt("Prev Value of F9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(NLA,DBF_DOUBLE) {
-		prompt("Non-link input A")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLB,DBF_DOUBLE) {
-		prompt("Non-link input B")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLC,DBF_DOUBLE) {
-		prompt("Non-link input C")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLD,DBF_DOUBLE) {
-		prompt("Non-link input D")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLE,DBF_DOUBLE) {
-		prompt("Non-link input E")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLF,DBF_DOUBLE) {
-		prompt("Non-link input F")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLG,DBF_DOUBLE) {
-		prompt("Non-link input G")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLH,DBF_DOUBLE) {
-		prompt("Non-link input H")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLI,DBF_DOUBLE) {
-		prompt("Non-link input I")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLJ,DBF_DOUBLE) {
-		prompt("Non-link input J")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLK,DBF_DOUBLE) {
-		prompt("Non-link input K")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLL,DBF_DOUBLE) {
-		prompt("Non-link input L")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLM,DBF_DOUBLE) {
-		prompt("Non-link input M")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLN,DBF_DOUBLE) {
-		prompt("Non-link input N")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLO,DBF_DOUBLE) {
-		prompt("Non-link input O")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLP,DBF_DOUBLE) {
-		prompt("Non-link input P")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLQ,DBF_DOUBLE) {
-		prompt("Non-link input Q")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLR,DBF_DOUBLE) {
-		prompt("Non-link input R")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLS,DBF_DOUBLE) {
-		prompt("Non-link input S")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLT,DBF_DOUBLE) {
-		prompt("Non-link input T")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LNLA,DBF_DOUBLE) {
-		prompt("Prev Value of NLA")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLB,DBF_DOUBLE) {
-		prompt("Prev Value of NLB")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLC,DBF_DOUBLE) {
-		prompt("Prev Value of NLC")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLD,DBF_DOUBLE) {
-		prompt("Prev Value of NLD")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLE,DBF_DOUBLE) {
-		prompt("Prev Value of NLE")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLF,DBF_DOUBLE) {
-		prompt("Prev Value of NLF")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLG,DBF_DOUBLE) {
-		prompt("Prev Value of NLG")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLH,DBF_DOUBLE) {
-		prompt("Prev Value of NLH")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLI,DBF_DOUBLE) {
-		prompt("Prev Value of NLI")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLJ,DBF_DOUBLE) {
-		prompt("Prev Value of NLJ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLK,DBF_DOUBLE) {
-		prompt("Prev Value of NLK")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLL,DBF_DOUBLE) {
-		prompt("Prev Value of NLL")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLM,DBF_DOUBLE) {
-		prompt("Prev Value of NLM")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLN,DBF_DOUBLE) {
-		prompt("Prev Value of NLN")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLO,DBF_DOUBLE) {
-		prompt("Prev Value of NLO")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLP,DBF_DOUBLE) {
-		prompt("Prev Value of NLP")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLQ,DBF_DOUBLE) {
-		prompt("Prev Value of NLQ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLR,DBF_DOUBLE) {
-		prompt("Prev Value of NLR")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLS,DBF_DOUBLE) {
-		prompt("Prev Value of NLS")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLT,DBF_DOUBLE) {
-		prompt("Prev Value of NLT")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-}
diff --git a/pmacApp/tsubSrc/Makefile b/pmacApp/tsubSrc/Makefile
deleted file mode 100644
index 2f182d4..0000000
--- a/pmacApp/tsubSrc/Makefile
+++ /dev/null
@@ -1,51 +0,0 @@
-TOP = ../..
-
-include $(TOP)/configure/CONFIG
-#----------------------------------------
-#  ADD MACRO DEFINITIONS AFTER THIS LINE
-#=============================
-USR_CFLAGS += -DDEBUG
-
-### build a support library
-LIBRARY_IOC += tsub
-
-### tsub record
-OBJLIB_SRCS  += tsubRecord.c
-
-### tsubRecord.h will be created from tsubRecord.dbd
-DBDINC += tsubRecord
-
-### install <name>.dbd into <top>/dbd
-DBD += tsubInclude.dbd
-
-### Tsub functions sources
-OBJLIB_SRCS  += tsubSeq.c
-OBJLIB_SRCS  += tsubBD.c
-OBJLIB_SRCS  += tsubBD3.c
-OBJLIB_SRCS  += tsubCCD2009.c
-# OBJLIB_SRCS  += tsubCCD.c
-# OBJLIB_SRCS  += tsubCCD_bm_no_extern_offset.c
-OBJLIB_SRCS  += tsubCS.c
-# OBJLIB_SRCS  += tsubDN.c
-OBJLIB_SRCS  += tsubHS.c
-OBJLIB_SRCS  += tsubMD.c
-OBJLIB_SRCS  += tsubMI.c
-OBJLIB_SRCS  += tsubMO_2mtr_cry2down.c
-# OBJLIB_SRCS  += tsubMO_3mtr_cry2up.c
-# OBJLIB_SRCS  += tsubMO_3mtr_cry2down.c
-OBJLIB_SRCS  += tsubSH.c
-OBJLIB_SRCS  += tsubTB.c
-# OBJLIB_SRCS  += tsubA.c
-OBJLIB_SRCS  += tsubX.c
-# OBJLIB_SRCS  += tsubX_bm_extern_offset.c
-OBJLIB_SRCS  += tsubXY.c
-OBJLIB_SRCS  += tsubXYZ.c
-OBJLIB_SRCS  += tsubXYZ_frac.c
-OBJLIB_SRCS  += tsubAcc65e.c
-OBJLIB_SRCS  += tsubCollimator.c
-
-tsub_SRCS += $(OBJLIB_SRCS)
-
-include $(TOP)/configure/RULES
-#----------------------------------------
-#  ADD RULES AFTER THIS LINE
diff --git a/pmacApp/tsubSrc/Makefile.Vx b/pmacApp/tsubSrc/Makefile.Vx
deleted file mode 100644
index 17ee550..0000000
--- a/pmacApp/tsubSrc/Makefile.Vx
+++ /dev/null
@@ -1,40 +0,0 @@
-# Makefile.Vx
-TOP = ../../../..
-include $(TOP)/config/CONFIG_APP
-#----------------------------------------
-#  ADD MACRO DEFINITIONS AFTER THIS LINE
-
-USR_CFLAGS += -DDEBUG
-
-# Tsub sources
-SRCS.c  += ../tsubSeq.c
-SRCS.c  += ../tsubBD.c
-SRCS.c  += ../tsubCCD.c
-# SRCS.c  += ../tsubCCD_bm_no_extern_offset.c
-SRCS.c  += ../tsubCS.c
-# SRCS.c  += ../tsubDN.c
-SRCS.c  += ../tsubHS.c
-SRCS.c  += ../tsubMD.c
-SRCS.c  += ../tsubMI.c
-SRCS.c  += ../tsubMO_2mtr_cry2down.c
-# SRCS.c  += ../tsubMO_3mtr_cry2up.c
-SRCS.c  += ../tsubSH.c
-SRCS.c  += ../tsubTB.c
-SRCS.c  += ../tsubX.c
-# SRCS.c  += ../tsubX_bm_extern_offset.c
-SRCS.c  += ../tsubXY.c
-SRCS.c  += ../tsubXYZ.c
-SRCS.c  += ../tsubAcc65e.c
-
-LIBOBJS = $(SRCS.c:../%.c=%.o)
-LIBNAME = tsubLib
-
-PMAC_TSUB = .
-include ../tsubLIBOBJS		#defines TSUBLIBOBJS
-PROD += $(TSUBLIBOBJS)
-
-
-include $(TOP)/config/RULES.Vx
-#----------------------------------------
-#  ADD RULES AFTER THIS LINE
-
diff --git a/pmacApp/tsubSrc/Makefile_3.13 b/pmacApp/tsubSrc/Makefile_3.13
deleted file mode 100644
index 86d7ae0..0000000
--- a/pmacApp/tsubSrc/Makefile_3.13
+++ /dev/null
@@ -1,3 +0,0 @@
-TOP=../../..
-include $(TOP)/config/CONFIG_APP
-include $(TOP)/config/RULES_ARCHS
diff --git a/pmacApp/tsubSrc/Makefile_3.14 b/pmacApp/tsubSrc/Makefile_3.14
deleted file mode 100644
index 581c948..0000000
--- a/pmacApp/tsubSrc/Makefile_3.14
+++ /dev/null
@@ -1,35 +0,0 @@
-TOP = ../..
-
-include $(TOP)/configure/CONFIG
-#----------------------------------------
-#  ADD MACRO DEFINITIONS AFTER THIS LINE
-#=============================
-USR_CFLAGS += -DDEBUG
-
-# build a support library
-OBJLIB_vxWorks += tsub
-
-# Tsub sources
-OBJLIB_SRCS  += tsubSeq.c
-OBJLIB_SRCS  += tsubBD.c
-OBJLIB_SRCS  += tsubCCD.c
-# OBJLIB_SRCS  += tsubCCD_bm_no_extern_offset.c
-OBJLIB_SRCS  += tsubCS.c
-# OBJLIB_SRCS  += tsubDN.c
-OBJLIB_SRCS  += tsubHS.c
-OBJLIB_SRCS  += tsubMD.c
-OBJLIB_SRCS  += tsubMI.c
-OBJLIB_SRCS  += tsubMO_2mtr_cry2down.c
-# OBJLIB_SRCS  += tsubMO_3mtr_cry2up.c
-# OBJLIB_SRCS  += tsubMO_3mtr_cry2down.c
-OBJLIB_SRCS  += tsubSH.c
-OBJLIB_SRCS  += tsubTB.c
-OBJLIB_SRCS  += tsubX.c
-# OBJLIB_SRCS  += tsubX_bm_extern_offset.c
-OBJLIB_SRCS  += tsubXY.c
-OBJLIB_SRCS  += tsubXYZ.c
-OBJLIB_SRCS  += tsubAcc65e.c
-
-include $(TOP)/configure/RULES
-#----------------------------------------
-#  ADD RULES AFTER THIS LINE
diff --git a/pmacApp/tsubSrc/README b/pmacApp/tsubSrc/README
deleted file mode 100644
index ed16d13..0000000
--- a/pmacApp/tsubSrc/README
+++ /dev/null
@@ -1,37 +0,0 @@
-This directory contains a TSUB Record (Transformation Subroutine) source code
-and a collection of associated transformation subroutines for PMAC working
-through this TSUB record.
-
-TSUB is a general-purpose EPICS record providing a way to run user-written
-transformations in the IOC. The aim of TSUB is to fetch some input values
-through TSUB record "input" DB links, to perfom a transformation according
-to respective transformation subroutine (a user-supplied C-program) and to
-push the output values into the "output" DB links. The name of user-supplied
-subroutine is specified in the TSUB record SNAM field. TSUB record provides
-80 input DB links and 70 output DB links, which should be sufficient for most
-needs. By its versatility, it stands between EPICS Sub (subroutine) Record
-and aSub (Array Subroutine) records included into EPICS Base, although it was
-developed well before aSub. In principle, aSub can be used anywhere instead
-of TSUB, privided one converts respective subroutines written for TSUB and
-replaces the TSUB DB fields with aSub fields.
-
-A typical use of TSUB records with PMAC is to map from e.g. actual motors
-positions into axis positions or from requested axis mosition into requested
-motor position. For example, when one specifies desired monochromator energy,
-a TSUB record and the associated subroutine tsubMOEnAxs (see tsubMO.c) are
-used to map the value into desired monochromator rotary and monochromator
-second crystal translation positions.
-
-The transformation routines in this directory are grouped as one file per
-assembly type. So, when one adds a new PMAC motors assembly type (e.g. an
-XYZ translation stage), he has to write a new tsubXYZ.c file by analogy
-with other assemblies.
-
-As  TSUB is a soft record, it is independent of PMAC and VxWorks and can be
-compiled for e.g. Linux IOC (since the 07/2011 version) and deployed for
-other types of calculations.
-
-
--- Sergey
-
-
diff --git a/pmacApp/tsubSrc/tsubA.c b/pmacApp/tsubSrc/tsubA.c
deleted file mode 100644
index c9d9f9c..0000000
--- a/pmacApp/tsubSrc/tsubA.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/* @(#) tsubA.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubA.c - Transformation Subroutines for A-positioners          */
-/*           i.e. one-axis rotation stages, i.e. any modular drives  */
-/*           This is for 1-motor assemblies -- Stepanov            */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubADebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubADebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubAPs - Assembly-A Initialization
- */
-static long tsubAPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubAPsSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubAPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubAPsMtr - Assembly-A Motors
- *	oa1 = d1
- *	a = m1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	a2 = m1:rollover
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubAPsMtr (struct tsubRecord *pRec) {
-	double fraction;
-	if (pRec->nla == 0.0)
-	{
-		fraction = pRec->a - pRec->a2 * floor(pRec->a/pRec->a2);
-		pRec->oa1 = fraction * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubAPsDrv - Assembly-A Drives
- *	oa0 = m1
- *	a = d1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubAPsDrv (struct tsubRecord *pRec) {
-	if ( pRec->a1 == 0.0 )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubAPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubAPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubADebug > 1) printf ("tsubAPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   printf ("tsubAPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubAPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-  	if (tsubADebug > 1) printf ("tsubAPsSpeed: m1=%5.2f\n",m1);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubAPsRef[] = {
-    {"tsubAPs",      (REGISTRYFUNCTION)tsubAPs},
-    {"tsubAPsSync",  (REGISTRYFUNCTION)tsubAPsSync},
-    {"tsubAPsMtr",   (REGISTRYFUNCTION)tsubAPsMtr},
-    {"tsubAPsDrv",   (REGISTRYFUNCTION)tsubAPsDrv},
-    {"tsubAPsSpeed", (REGISTRYFUNCTION)tsubAPsSpeed}
-};
-
-static void tsubAPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubAPsRef,NELEMENTS(tsubAPsRef));
-}
-epicsExportRegistrar(tsubAPsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubAcc65e.c b/pmacApp/tsubSrc/tsubAcc65e.c
deleted file mode 100644
index b5933d2..0000000
--- a/pmacApp/tsubSrc/tsubAcc65e.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/* @(#) tsubACC65E.c 102 2005/03/26 */
-
-/* tsubACC65E.c - Transformation Subroutines for PMAC Accessory-65E */
-/*                Digital Output -- Sergey Stepanov    */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define TSUB_DIAGNOSTIC tsubAcc65eDebug
-
-#if TSUB_DIAGNOSTIC
-volatile int TSUB_DIAGNOSTIC = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code)       { if ( (pRec->tpro == (level)) || (TSUB_DIAGNOSTIC == (level)) ) { code } }
-#else
-#define TSUB_TRACE(level,code)      ;
-#endif
-
-/*===========================================
- * tsubAcc65eIni - Accessory-65E Initialization
- */
-static long tsubAcc65eIni (struct tsubRecord *pRec) {
-	return (0);
-}
-
-/*===========================================
- * tsubAcc65eOut - Accessory-65E Digital Out word composition
- *	a0,...a9,b0,..b9,c1,...c3 = inputs
- *	oa = output
- */
-static long tsubAcc65eOut (struct tsubRecord *	pRec) {
-	long acc65e_out_long = 0;
-
-	if ( pRec->a0 ) acc65e_out_long += 0x00000001;      /* IPA0 = bit0  */
-	if ( pRec->a1 ) acc65e_out_long += 0x00000002;      /* IPA1 = bit1  */
-	if ( pRec->a2 ) acc65e_out_long += 0x00000004;      /* IPA2 = bit2  */
-	if ( pRec->a3 ) acc65e_out_long += 0x00000008;      /* IPA3 = bit3  */
-	if ( pRec->a4 ) acc65e_out_long += 0x00000010;      /* IPA4 = bit4  */
-	if ( pRec->a5 ) acc65e_out_long += 0x00000020;      /* IPA5 = bit5  */
-	if ( pRec->a6 ) acc65e_out_long += 0x00000040;      /* IPA6 = bit6  */
-	if ( pRec->a7 ) acc65e_out_long += 0x00000080;      /* IPA7 = bit7  */
-	if ( pRec->a8 ) acc65e_out_long += 0x00000100;      /* IPA8 = bit8  */
-	if ( pRec->a9 ) acc65e_out_long += 0x00000200;      /* IPA9 = bit9  */
-	if ( pRec->b0 ) acc65e_out_long += 0x00000400;      /* IPB0 = bit10 */
-	if ( pRec->b1 ) acc65e_out_long += 0x00000800;      /* IPB1 = bit11 */
-	if ( pRec->b2 ) acc65e_out_long += 0x00001000;      /* IPB2 = bit12 */
-	if ( pRec->b3 ) acc65e_out_long += 0x00002000;      /* IPB3 = bit13 */
-	if ( pRec->b4 ) acc65e_out_long += 0x00004000;      /* IPB4 = bit14 */
-	if ( pRec->b5 ) acc65e_out_long += 0x00008000;      /* IPB5 = bit15 */
-	if ( pRec->b6 ) acc65e_out_long += 0x00010000;      /* IPB6 = bit16 */
-	if ( pRec->b7 ) acc65e_out_long += 0x00020000;      /* IPB7 = bit17 */
-	if ( pRec->b8 ) acc65e_out_long += 0x00040000;      /* IPB8 = bit18 */
-	if ( pRec->b9 ) acc65e_out_long += 0x00080000;      /* IPB9 = bit19 */
-	if ( pRec->c0 ) acc65e_out_long += 0x00100000;      /* IPC0 = bit20 */
-	if ( pRec->c1 ) acc65e_out_long += 0x00200000;      /* IPC1 = bit21 */
-	if ( pRec->c2 ) acc65e_out_long += 0x00400000;      /* IPC2 = bit22 */
-	if ( pRec->c3 ) acc65e_out_long += 0x00800000;      /* IPC3 = bit23 */
-	pRec->oa = acc65e_out_long;
-	return (0);
-}
-
-/*===========================================
- * tsubAcc65eRbk - Accessory-65E Digital Out word decomposition
- *	a = input
- *	oa0,...oa9,ob0,..ob9,oc1,...oc3 = outputs
- */
-static long tsubAcc65eRbk (struct tsubRecord *pRec) {
-	long          acc65e_rbk_long = 0;
-	unsigned long tmp = 0;
-	char 	      binstr[32];
-	short         i=0;
-
-	acc65e_rbk_long = (long)pRec->a;
-
-	for(i=31; i>=0; i--) {
-/*
- *  "<<n" Left shift n places,
- *  ">>n" Right shift n places
-*/
-          tmp = acc65e_rbk_long/(1<<i);  		/* tmp=value/pow(2,i)*/
-	  if(tmp > 0) {
-   	    binstr[i] = '1';
-            acc65e_rbk_long = acc65e_rbk_long%(1<<i);	/* value=value%pow(2,i) */
-  	  } else {
-   	    binstr[i] = '0';
-	  }
- 	}
-	if ( binstr[0]  == '1' ) {pRec->oa0=1;} else {pRec->oa0=0;}      /* bit0  = OTA0 */
-	if ( binstr[1]  == '1' ) {pRec->oa1=1;} else {pRec->oa1=0;}      /* bit1  = OTA1 */
-	if ( binstr[2]  == '1' ) {pRec->oa2=1;} else {pRec->oa2=0;}      /* bit2  = OTA2 */
-	if ( binstr[3]  == '1' ) {pRec->oa3=1;} else {pRec->oa3=0;}      /* bit3  = OTA3 */
-	if ( binstr[4]  == '1' ) {pRec->oa4=1;} else {pRec->oa4=0;}      /* bit4  = OTA4 */
-	if ( binstr[5]  == '1' ) {pRec->oa5=1;} else {pRec->oa5=0;}      /* bit5  = OTA5 */
-	if ( binstr[6]  == '1' ) {pRec->oa6=1;} else {pRec->oa6=0;}      /* bit6  = OTA6 */
-	if ( binstr[7]  == '1' ) {pRec->oa7=1;} else {pRec->oa7=0;}      /* bit7  = OTA7 */
-	if ( binstr[8]  == '1' ) {pRec->oa8=1;} else {pRec->oa8=0;}      /* bit8  = OTA8 */
-	if ( binstr[9]  == '1' ) {pRec->oa9=1;} else {pRec->oa9=0;}      /* bit9  = OTA9 */
-	if ( binstr[10] == '1' ) {pRec->ob0=1;} else {pRec->ob0=0;}      /* bit10 = OTB0 */
-	if ( binstr[11] == '1' ) {pRec->ob1=1;} else {pRec->ob1=0;}      /* bit11 = OTB1 */
-	if ( binstr[12] == '1' ) {pRec->ob2=1;} else {pRec->ob2=0;}      /* bit12 = OTB2 */
-	if ( binstr[13] == '1' ) {pRec->ob3=1;} else {pRec->ob3=0;}      /* bit13 = OTB3 */
-	if ( binstr[14] == '1' ) {pRec->ob4=1;} else {pRec->ob4=0;}      /* bit14 = OTB4 */
-	if ( binstr[15] == '1' ) {pRec->ob5=1;} else {pRec->ob5=0;}      /* bit15 = OTB5 */
-	if ( binstr[16] == '1' ) {pRec->ob6=1;} else {pRec->ob6=0;}      /* bit16 = OTB6 */
-	if ( binstr[17] == '1' ) {pRec->ob7=1;} else {pRec->ob7=0;}      /* bit17 = OTB7 */
-	if ( binstr[18] == '1' ) {pRec->ob8=1;} else {pRec->ob8=0;}      /* bit18 = OTB8 */
-	if ( binstr[19] == '1' ) {pRec->ob9=1;} else {pRec->ob9=0;}      /* bit19 = OTB9 */
-	if ( binstr[20] == '1' ) {pRec->oc0=1;} else {pRec->oc0=0;}      /* bit20 = OTC0 */
-	if ( binstr[21] == '1' ) {pRec->oc1=1;} else {pRec->oc1=0;}      /* bit21 = OTC1 */
-	if ( binstr[22] == '1' ) {pRec->oc2=1;} else {pRec->oc2=0;}      /* bit22 = OTC2 */
-	if ( binstr[23] == '1' ) {pRec->oc3=1;} else {pRec->oc3=0;}      /* bit23 = OTC3 */
-	return (0);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubAcc65eRef[] = {
-    {"tsubAcc65eIni", (REGISTRYFUNCTION)tsubAcc65eIni},
-    {"tsubAcc65eOut", (REGISTRYFUNCTION)tsubAcc65eOut},
-    {"tsubAcc65eRbk", (REGISTRYFUNCTION)tsubAcc65eRbk}
-};
-
-static void tsubAcc65eFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubAcc65eRef,NELEMENTS(tsubAcc65eRef));
-}
-epicsExportRegistrar(tsubAcc65eFunc);
-
diff --git a/pmacApp/tsubSrc/tsubBD.c b/pmacApp/tsubSrc/tsubBD.c
deleted file mode 100644
index e7896d4..0000000
--- a/pmacApp/tsubSrc/tsubBD.c
+++ /dev/null
@@ -1,313 +0,0 @@
-/* @(#) tsubBD.c 1.4 97/04/03 */
-
-/* tsubBD.c - Transformation Subroutines For Beam Delivery Pipe */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubBDDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubBDDebug == (level)) ) { code } }
-
-/* if x1=mm, x2=mrad, base=m (BioCAT), then FCBD=1; if base=mm, then FCBD=1000. */
-double FCBD = 1.0;
-
-/* ===========================================
- * tsubBDSt - Support Initialization
- */
-static long tsubBDSt (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBDStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubBDStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBDStMtr - Support Motors
- *	oa = x1
- *	ob = x2
- *	oa1 = d1
- *	ob1 = d2
- *	a = m1
- *	b = m2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubBDStMtr (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-	}
-	pRec->ob = FCBD * (pRec->oa1 - pRec->ob1) / pRec->k;       /* x2=(d1-d2)/BaseLength */
-	pRec->oa = pRec->ob1 - (pRec->ob * pRec->l / FCBD);        /* x1=d2-x2*RotOrigin */
-	return (0);
-}
-
-/* ===========================================
- * tsubBDStDrv - Support Drives
- *	oa = x1
- *	ob = x2
- *	oa0 = m1
- *	ob0 = m2
- *	a = d1
- *	b = d2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubBDStDrv (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) ||
-	     (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                  /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                  /* m2=d2/scale2 */
-	}
-	pRec->ob = FCBD * (pRec->a - pRec->b) / pRec->k;           /* x2=(d1-d2)/BaseLength */
-	pRec->oa = pRec->b - (pRec->ob * pRec->l / FCBD);          /* x1=d2-x2*RotOrigin    */
-	return (0);
-
-}
-
-/* ===========================================
- * tsubBDStAxs - Support Axes
- *	oa0 = m1
- *	oa1 = d1
- *	ob0 = m2
- *	ob1 = d2
- *	a = x1
- *	b = x2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubBDStAxs (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	pRec->ob1 = pRec->a   + pRec->b * (pRec->l / FCBD);        /* d2=x1+x2*RotOrigin     */
-	pRec->oa1 = pRec->ob1 + pRec->b * (pRec->k / FCBD);        /* d1=d2+x2*BaseLength    */
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;     /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                /* m2=d2/scale2 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBDStSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oa1 = d1
- *	ob1 = d2
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	k = BaseLength
- *	l = RotOrigin
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubBDStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2, orig, base, x2a, x2b;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                   /* sdis=1 */
-
-	orig = fabs(pRec->l);				/* RotOrigin */
-	base = fabs(pRec->k);				/* BaseLength */
-
-  	if (tsubBDDebug > 1) printf ("+++tsubBDStSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ||
-             orig == 0.0 ) {
-	   printf ("tsubBDStSpeed: exit on zero calc parameters\n");
-	   printf ("tsubBDStSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubBDStSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubBDStSpeed: BaseLength=%g RotOrigin=%g\n",base,orig);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of center is the average of the speeds of individual drives */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      x1 = 0.5*(d2 + d1);
-	      if ( x1 != 0.0 ) prcn = fabs( pRec->a2 / x1 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max     */
-	   else {
-/* Speed of angle is the slowest of the speed of 2nd motor divided by base+rotorigin    */
-/* and the speed of 1st motor divided by rotorigin. The matter is that when one changes */
-/* the angle, the 2nd (downstream) motor will always have to run a larger distance and  */
-/* therefore PMAC will slow the other (upstream) motor down in proportion:              */
-/* (base+origin)/origin)                                                                */
-/* The approach like for mirror that the speed of angle is the sum of the speeds */
-/* of each motor divided by base does not apply here -- SS 2006/01/05            */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-/*	      x2 = FCBD*fmin(d2/(orig+base),d1/orig); */
-/* fmin causes task crash; so we use workaround:      */
-	      x2a = FCBD*d2/(orig+base);
-	      x2b = FCBD*d1/orig;
-	      if (x2a < x2b) x2=x2a;
-  	      else           x2=x2b;
-	      if ( x2 != 0.0 ) prcn = fabs( pRec->b2 / x2 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             	/* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             	/* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            	/* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            	/* d2=m2*scale2 */
-	x1 = 0.5*(d2 + d1);	                         	/* x1=0.5*(d2+d1) */
-/*	x2 = FCBD*fmin(d2/(orig+base),d1/orig);  */		/* x2=min(d2/(RotOrigin+BaseLength),d1/RotOrigin) */
-/* fmin causes task crash; so we use workaround: */
-	x2a = FCBD*d2/(orig+base);
-	x2b = FCBD*d1/orig;
-	if (x2a < x2b) x2=x2a;
-	else           x2=x2b;
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubBDDebug > 1) printf ("+++tsubBDStSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubBDStRef[] = {
-    {"tsubBDSt",      (REGISTRYFUNCTION)tsubBDSt},
-    {"tsubBDStSync",  (REGISTRYFUNCTION)tsubBDStSync},
-    {"tsubBDStMtr",   (REGISTRYFUNCTION)tsubBDStMtr},
-    {"tsubBDStDrv",   (REGISTRYFUNCTION)tsubBDStDrv},
-    {"tsubBDStAxs",   (REGISTRYFUNCTION)tsubBDStAxs},
-    {"tsubBDStSpeed", (REGISTRYFUNCTION)tsubBDStSpeed}
-};
-
-static void tsubBDStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubBDStRef,NELEMENTS(tsubBDStRef));
-}
-epicsExportRegistrar(tsubBDStFunc);
-
diff --git a/pmacApp/tsubSrc/tsubBD3.c b/pmacApp/tsubSrc/tsubBD3.c
deleted file mode 100644
index 897c8fd..0000000
--- a/pmacApp/tsubSrc/tsubBD3.c
+++ /dev/null
@@ -1,367 +0,0 @@
-/* @(#) tsubBD3.c, version 1.0 2010/09/28 */
-
-/* tsubBD3St.c - Transformation Subroutines for GM/CA-CAT two-segment beam delivery pipe *
- *              supported by three in-line motors. For additional information see the    *
- *              files README, CalibdsSt_help.gif, and downstream3_equations.ppt in       *
- *              the bd3Db folder                                                         */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubBD3Debug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubBD3Debug == (level)) ) { code } }
-
-/* Distances are measured in mm and the pipe angles is mrad */
-/* if x1=mm, x2=mrad, base=m (BioCAT), then FCDS=1; */
-/* if x1=mm, x2=mrad, base=mm (GMCA), then FCDS=1000. */
-double FCDS = 1000.0;
-
-/* ===========================================
- * tsubBD3St - BD3 support
- */
-static long tsubBD3St (struct tsubRecord *pRec) {
-        return (0);
-}
-
-
-/* ===========================================
- * tsubBD3StSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubBD3StSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBD3StMtr - BD3 support Motors
- *	oa  = x1	(sample height)
- *	ob  = x2        (gonio support angle)
- *	oa1 = d1	(upstream support slide)
- *	ob1 = d2	(midstream support slide [upstream of gonio platform])
- *	oc1 = d3	(downstream support slide [downstream of gonio platform])
- *	oh  = ANGLE	(overall pipe angle from mirror to sample)
- *	a  = m1
- *	b  = m2
- *	c  = m3
- *	d  = Lm1
- *      e  = L12
- *      f  = L23
- *	g  = Ls3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubBD3StMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)  { /* ------- Absolute motion --------- */
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;                    /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;                    /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;                    /* d3=m3*scale3+offset3 */
-	}
-	else {                  /* ------- Relative motion --------- */
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3 */
-	}
-	if ( pRec->f == 0.0) {
-	   if (tsubBD3Debug > 0) printf("***tsub=%s (nla=%1.0f): L23=0 -- exit!\n",pRec->name,pRec->nla);
-           return (-1);
-	}
-	pRec->ob = FCDS * (pRec->oc1 - pRec->ob1) / pRec->f;		      /* x2=(d3-d2)/L23 */
-	pRec->oa = pRec->oc1 + pRec->ob * (pRec->g / FCDS);		      /* x1=d3+Ls3*x2 */
-
-	if (pRec->nla == 0.0) {  /* ------- Absolute motion --------- */
-	   pRec->oh = FCDS * pRec->oa / ( pRec->d +  pRec->e +  pRec->f +  pRec->g);  /* ANGLE = x1/(Lm1+L12+L23+Ls3) */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBD3StDrv - BD3 support Drives
- *	oa  = x1	(sample height)
- *	ob  = x2        (gonio support angle)
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1		(upstream support slide)
- *	b = d2          (midstream support slide [upstream of gonio platform])
- *	c = d3          (downstream support slide [downstream of gonio platform])
- *	d  = Lm1
- *      e  = L12
- *      f  = L23
- *	g  = Ls3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubBD3StDrv (struct tsubRecord *pRec) {
-	if (pRec->a1 == 0.0 || pRec->b1 == 0.0 || pRec->c1 == 0.0) return (-1);
-
-	if (pRec->nla == 0.0) {  /* ------- Absolute motion --------- */
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;                  /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;                  /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;                  /* m3=(d3-offset3)/scale3 */
-	}
-	else {                   /* ------- Relative motion --------- */
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3 */
-	}
-	if ( pRec->f == 0.0) {
-	   if (tsubBD3Debug > 0) printf("***tsub=%s (nla=%1.0f): L23=0 -- exit!\n",pRec->name,pRec->nla);
-           return (-1);
-	}
-	pRec->ob = FCDS * (pRec->c - pRec->b) / pRec->f;		      /* x2=(d3-d2)/L23 */
-	pRec->oa = pRec->c + pRec->ob * (pRec->g / FCDS);		      /* x1=d3+Ls3*x2 */
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBD3StAxs - BD3 support Axes
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1        (upstream support slide)
- *	ob1 = d2	(midstream support slide [upstream of gonio platform])
- *	oc1 = d3	(downstream support slide [downstream of gonio platform])
- *	a = x1		(sample height)
- *	b = x2          (gonio support angle)
- *	d  = Lm1
- *      e  = L12
- *      f  = L23
- *	g  = Ls3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubBD3StAxs (struct tsubRecord *pRec) {
-	if (pRec->a1 == 0.0 || pRec->b1 == 0.0 || pRec->c1 == 0.0) return (-1);
-
-	pRec->oc1 = pRec->a - pRec->b * (pRec->g)           / FCDS;	      /* d3=x1-x2*Ls3       */
-	pRec->ob1 = pRec->a - pRec->b * (pRec->g + pRec->f) / FCDS;	      /* d2=x1-x2*(Ls3+L23) */
-	pRec->oa1 = pRec->a * pRec->d / (pRec->d + pRec->e + pRec->f + pRec->g); /* d1= x1*Lm1/(Lm1+L12+L23+Ls3) */
-
-	if (pRec->nla == 0.0) {  /* ------- Absolute motion --------- */
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;                /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;                /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->oc1 - pRec->c0) / pRec->c1;                /* m3=(d3-offset3)/scale3 */
-	}
-	else {                   /* ------- Relative motion --------- */
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                           /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                           /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->oc1) / pRec->c1;                           /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubBD3StSpeed - BD3 Support speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	d  = Lm1
- *      e  = L12
- *      f  = L23
- *	g  = Ls3
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubBD3StSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubBD3Debug > 1) printf ("+++tsub=%s: called with n=%1.0f \n",pRec->name,pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ) {
-	   if (tsubBD3Debug > 0) {
-	      printf ("***tsub=%s: exit on zero calc parameters\n", pRec->name);
-	      printf ("***tsub=%s: max1=%5.2f sca1=%g\n", pRec->name,pRec->a,pRec->a3);
-	      printf ("***tsub=%s: max2=%5.2f sca2=%g\n", pRec->name,pRec->b,pRec->b3);
-	      printf ("***tsub=%s: max3=%5.2f sca3=%g\n", pRec->name,pRec->c,pRec->c3);
-	   }
-           return (-1);
-	}
-	if      (pRec->nla ==  1.0)  /* -------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);                              /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* -------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);                              /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* -------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);                              /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* --------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* --------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* --------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) /* --------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x2 = (d3-d2)/pRec->f;                                           /* x2=(d3-d2)/L23 */
-	      x1 = d3+x2*pRec->g;                                             /* x1=d3+x2*Ls3 */
-	      if (x1 != 0.0) {
-                  prcn = fabs( pRec->a2 / x1 );
-	      }
-	      else {
-	          if (tsubBD3Debug > 0) printf ("***tsub=%s(nla=%1.0f): x1=0\n",
-                                                          pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else if (pRec->nla == 22.0) /* --------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x2 = (d3+d2)/pRec->f;                                           /* x2=(d3-d2)/L23 */
-	      if (x2 != 0.0) {
-                  prcn = fabs( pRec->b2 / x2 );
-	      }
-	      else {
-	          if (tsubBD3Debug > 0) printf ("***tsub=%s(nla=%1.0f): x2=0\n",
-                                                          pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else
-	{
-           if (tsubBD3Debug > 0) printf ("***tsub=%s: incorrect nla=%1.0f -- exit!\n",
-                                                          pRec->name,pRec->nla);
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          if (tsubBD3Debug > 0) printf ("***tsub=%s(nla=%1.0f): prcn=%g not in 0-1 range\n",
-                                                          pRec->name,pRec->nla,prcn);
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                                  /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                                  /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                                  /* m3=prcn*m3_max */
-	d1 = 1000.0*m1*(pRec->a3);                                            /* d1=m1*scale1   */
-	d2 = 1000.0*m2*(pRec->b3);                                            /* d2=m2*scale2   */
-	d3 = 1000.0*m3*(pRec->c3);                                            /* d3=m3*scale3   */
-	x2 = (d3+d2)/pRec->f;                                                 /* x2=(d3-d2)/L23 */
-	x1 = d3+x2*pRec->g;                                                   /* x1=d3+x2*Ls3 */
-	x2 = FCDS*x2;                                                         /* rad -> mrad */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = fabs(d1);
-	pRec->ob1 = fabs(d2);
-	pRec->oc1 = fabs(d3);
-	pRec->oa2 = fabs(x1);
-	pRec->ob2 = fabs(x2);
-        if (tsubBD3Debug > 1) printf ("+++tsub=%s(nla=%1.0f):  m1=%5.2f  m2=%5.2f  m3=%5.2f\n",
-                                                          pRec->name,pRec->nla,m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubBD3StRef[] = {
-    {"tsubBD3St",      (REGISTRYFUNCTION)tsubBD3St},
-    {"tsubBD3StSync",  (REGISTRYFUNCTION)tsubBD3StSync},
-    {"tsubBD3StMtr",   (REGISTRYFUNCTION)tsubBD3StMtr},
-    {"tsubBD3StDrv",   (REGISTRYFUNCTION)tsubBD3StDrv},
-    {"tsubBD3StAxs",   (REGISTRYFUNCTION)tsubBD3StAxs},
-    {"tsubBD3StSpeed", (REGISTRYFUNCTION)tsubBD3StSpeed}
-};
-
-static void tsubBD3StFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubBD3StRef,NELEMENTS(tsubBD3StRef));
-}
-epicsExportRegistrar(tsubBD3StFunc);
-
diff --git a/pmacApp/tsubSrc/tsubCCD.c b/pmacApp/tsubSrc/tsubCCD.c
deleted file mode 100644
index 88e5aea..0000000
--- a/pmacApp/tsubSrc/tsubCCD.c
+++ /dev/null
@@ -1,775 +0,0 @@
-/* @(#) tsubCCD.c, version 2.0 2004/04/27 -- speed propagation; support axis sign and start changed */
-
-/* tsubCCDSt.c - Transformation Subroutines for CCD detector 2*Theta and distance      *
- *               (GM/CA CAT detector mounted on A-frame and supported by 3 motors)     *
- * tsubCCDLp.c - Transformation Subroutines for CCD detector lateral position          *
- *		 with respect to x-ray beam deflected by Horiz.Focusing Mirror (HFM)   *
- *               (GM/CA CAT detector mounted on A-frame with 1 motor for latera shift) */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360       ((double) 1.7453292e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)      sin(DEG2RAD(deg))
-#define		COSD(deg)      cos(DEG2RAD(deg))
-#define		TAND(deg)      tan(DEG2RAD(deg))
-
-volatile int tsubCCDDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubCCDDebug == (level)) ) { code } }
-
-/* Distances are measured in mm, detector angle is degr., and mirror angles are in mrad */
-
-
-/* ===========================================
- * tsubCCDSt - CCD support
- */
-static long tsubCCDSt (struct tsubRecord *pRec) {
-        return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubCCDStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStMtr - CCD support Motors
- *	oa  = x1	(detector distance)
- *	ob  = x2        (detector 2*theta)
- *	oa1 = d1	(DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	oh  = S 	(vertical beam shift at sample due to mirror angle)
- *	a  = m1
- *	b  = m2
- *	c  = m3
- *	d  = Dms
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStMtr (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       S=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	S = pRec->d * tan(TwoAlpha);                    		      /* S=Dms*tan(2*angleVFM) */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVFM)=%g\n",pRec->name,S);
-	pRec->oh = S;
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;                    /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0 - S;                /* d2=m2*scale2+offset2-S*/
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0 - S;                /* d3=m3*scale3+offset3-S*/
-
-		Du = (pRec->oa1+pRec->k)*(pRec->oa1+pRec->k)                  /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->ob1+pRec->j)*(pRec->ob1+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->ob1)*Du+(pRec->j)*(D-pRec->oa1))	              /* sin(2Q+2a)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si)-TwoAlpha);                        /* 2Q = asin(sin(2Q+2a)) - 2*angleVFM */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q+2a)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1.0-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->oa1)*(pRec->p+pRec->k)                      /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->ob1)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->oa1)                  /* d(2Q)=[d(D)*cos(2Q+2a)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStDrv - CCD support Drives
- *	oa = x1		(detector distance)
- *	ob = x2         (detector 2*theta)
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1		(DD  - detector X-slide)
- *	b = d2          (VUS - detector vertical Upstream slide)
- *	c = d3          (VDS - detector vertical Downstream slide)
- *	d  = Dms
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStDrv (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       S=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-                return (-1);
-	}
-
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	S = pRec->d * tan(TwoAlpha);                    		      /* S=Dms*tan(2*angleVFM) */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVFM)=%g\n",pRec->name,S);
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;                  /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0 + S) / pRec->b1;              /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0 + S) / pRec->c1;              /* m3=(d3-offset3)/scale3 */
-
-		Du = (pRec->a+pRec->k)*(pRec->a+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->b+pRec->j)*(pRec->b+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->b)*Du+(pRec->j)*(D-pRec->a))	              /* sin(2Q+2a)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si)-TwoAlpha);                        /* 2Q = asin(sin(2Q+2a)) - 2*angleVFM */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q+2a)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->a)*(pRec->p+pRec->k)                        /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->b)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->a)                   /* d(2Q)=[d(D)*cos(2Q+2a)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStAxs - CCD support Axes
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1        (DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	a = x1		(detector distance)
- *	b = x2		(detector 2*theta)
- *	d  = Dms
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *      o  = dH (offset between Hu and Hd)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStAxs (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       S=0.0,
-	       QQ=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               Tg=0.0,
-               TwoAlpha=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-		return (-1);
-	}
-
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	S = pRec->d * tan(TwoAlpha);                    		      /* S=Dms*tan(2*angleVFM) */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVFM)=%g\n",pRec->name,S);
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		Du  = pRec->a + pRec->k;                                      /* Du=D+Lh */
-		QQ = DEG2RAD(pRec->b) + TwoAlpha;                             /* 2Q'=2Q+2*angleVFM */
-		Si = sin(QQ);
-		Co = cos(QQ);
-		Tg = tan(QQ);
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q+2VFM=%g rad\n" ,pRec->name,pRec->nla,QQ);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = Du*Co - (pRec->j)*Si - pRec->k;                   /* X =(D+Lh)*cos(2Q+2a)-Lv*sin(2Q+2a)-Lh */
-		pRec->ob1 = Du*Si + (pRec->j)*Co - pRec->j;                   /* Hu=(D+Lh)*sin(2Q+2a)+Lv*cos(2Q+2a)-Lv */
-		pRec->oc1 = pRec->ob1 + (pRec->l)*Tg + pRec->o/Co - pRec->o;  /* Hd=Hu+L*tan(2Q+2a)+dH/cos(2Q+2a)-dH */
-
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;                /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0 + S) / pRec->b1;            /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->oc1 - pRec->c0 + S) / pRec->c1;            /* m3=(d3-offset3)/scale3 */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		Du = pRec->r + pRec->k;                                       /* Du=D+Lh */
-		QQ = DEG2RAD(pRec->t) + TwoAlpha;                             /* 2Q'=2Q+2*angleVFM */
-		Si = sin(QQ);
-		Co = cos(QQ);
-		if ( Co == 0.0 ) {
-			if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g=0 -- exit!\n",
-                                                                                  pRec->name,pRec->nla,Co);
-        		return (-1);
-		}
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q+2VFM=%g rad\n" ,pRec->name,pRec->nla,QQ);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = (pRec->a)*Co-DEG2RAD(pRec->b)*(Du*Si+(pRec->j)*Co);       /*  d(X)=d(D)*cos(2Q+2a)-d(2Q)*(Du*sin(2Q+2a)+Lv*sin(2Q+2a)) */
-		pRec->ob1 = (pRec->a)*Si+DEG2RAD(pRec->b)*(Du*Co-(pRec->j)*Si);       /* d(Hu)=d(D)*sin(2Q+2a)+d(2Q)(Du*cos(2Q+2a)-Lv*sin(2Q+2a)) */
-		pRec->oc1 = pRec->ob1+DEG2RAD(pRec->b)*(pRec->l+pRec->o*Si)/(Co*Co);  /* d(Hd)=d(Hu)+d(2Q)*[L+dH*sin(2Q+2a)]/cos^2(2Q+2a) */
-
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                           /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                           /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->oc1) / pRec->c1;                           /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSpeed - CCD Support speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	d  = Dms
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *      o  = dH (offset between Hu and Hd)
- *	p  = d1_ActPos (X-slide actual)
- *	q  = d2_ActPos (VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubCCDStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	double Du=0.0,
-	       S=0.0,
-	       QQ=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubCCDDebug > 1) printf ("+++tsub=%s: called with n=%1.0f \n",pRec->name,pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ) {
-	   if (tsubCCDDebug > 0) {
-	      printf ("***tsub=%s: exit on zero calc parameters\n", pRec->name);
-	      printf ("***tsub=%s: max1=%5.2f sca1=%g\n", pRec->name,pRec->a,pRec->a3);
-	      printf ("***tsub=%s: max2=%5.2f sca2=%g\n", pRec->name,pRec->b,pRec->b3);
-	      printf ("***tsub=%s: max3=%5.2f sca3=%g\n", pRec->name,pRec->c,pRec->c3);
-	   }
-           return (-1);
-	}
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	S = pRec->d * tan(TwoAlpha);					      /* S=Dms*tan(angleVFM) */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVFM)=%g\n",pRec->name,S);
-
-	Du  = pRec->r + pRec->k;                                              /* Du=D+Lh */
-	if ( Du <= 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%2.0f): D+Lh=%g <= 0 -- exit!\n",
-                                                                pRec->name,pRec->nla,Du);
-        	return (-1);
-	}
-	QQ = DEG2RAD(pRec->t) + TwoAlpha;                                     /* 2Q'=2Q+2*angleVFM */
-	Si = sin(QQ);
-	Co = cos(QQ);
-	if ( Co == 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g=0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Co);
-        	return (-1);
-	}
-        if (tsubCCDDebug > 2) {
-             	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-               	printf("+++tsub=%s(nla=%1.0f): 2Q+2VFM=%g rad\n" ,pRec->name,pRec->nla,QQ);
-               	printf("+++tsub=%s(nla=%1.0f): sin(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Si);
-               	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g\n",pRec->name,pRec->nla,Co);
-	}
-
-
-	if      (pRec->nla ==  1.0)  /* -------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);                              /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* -------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);                              /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* -------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);                              /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* --------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* --------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* --------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) /* --------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      if ( x1 != 0.0) {
-                  prcn = fabs( pRec->a2 / x1 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x1=0\n",pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else if (pRec->nla == 22.0) /* --------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                     /* d(2Q)=(d(D)*cos(2Q+2a)-dX)/(Hu+Lv) */
-	      if ( x2 != 0.0) {
-                  prcn = fabs( pRec->b2 / x2 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x2=0\n",pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else
-	{
-           if (tsubCCDDebug > 0) printf ("***tsub=%s: incorrect nla=%1.0f -- exit!\n",pRec->name,pRec->nla);
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): prcn=%g not in 0-1 range\n",
-                                                                 pRec->name,pRec->nla,prcn);
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                                  /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                                  /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                                  /* m3=prcn*m3_max */
-	d1 = 1000.0*m1*(pRec->a3);                                            /* d1=m1*scale1   */
-	d2 = 1000.0*m2*(pRec->b3);                                            /* d2=m2*scale2   */
-	d3 = 1000.0*m3*(pRec->c3);                                            /* d3=m3*scale3   */
-	x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;                  /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                           /* d(2Q)=(d(D)*cos(2Q+2a)-dX)/(Hu+Lv) */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = fabs(d1);
-	pRec->ob1 = fabs(d2);
-	pRec->oc1 = fabs(d3);
-	pRec->oa2 = fabs(x1);
-	pRec->ob2 = fabs(x2);
-        if (tsubCCDDebug > 1) printf ("+++tsub=%s(nla=%1.0f):  m1=%5.2f  m2=%5.2f  m3=%5.2f\n",
-                                                                pRec->name,pRec->nla,m1,m2,m3);
-	return (ifail);
-}
-
-
-/* ========================================================================== */
-
-
-/* ===========================================
- * tsubCCDLp - CCD lateral position
- */
-static long tsubCCDLp (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubCCDLpSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpMtr - CCD lateral position Motors
- *	oa1 = d1
- *	a = m1
- *      d = Dms (mirror to sample distance from CCDSt)
- *	j = Dds (detector distance from CCDSt)
- *      k = 2Q  (detector 2*theta from CCDSt)
- *      l = Dmhmv (distance between HFM and VFM)
- *      m = angleHFM
- *	n = (0=don't use mirror angle) (1=use mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCCDLpMtr (struct tsubRecord *pRec) {
-	double Dmd=0.0,
-               TwoAlpha=0.0;
-
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-
-	if (pRec->nla == 0.0)
-	{
-		Dmd = pRec->j * COSD(pRec->k) + pRec->d + pRec->l; /* Dmd=Dds*cos(2Q)+Dms+Dmhmv */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd=%g\n",
-                                                    pRec->name,Dmd);
-		Dmd = Dmd * tan(TwoAlpha);
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd*tan(angleHFM)=%g\n",
-                                                    pRec->name,Dmd);
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0 - Dmd;   /* d1=m1*scale1+offset1-tan(2*angleHFM)*Dmd */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpDrv - CCD lateral position Drives
- *	oa0 = m1
- *	a = d1
- *      d = Dms (mirror to sample distance from CCDSt)
- *	j = Dds (detector distance from CCDSt)
- *      k = 2Q  (detector 2*theta from CCDSt)
- *      l = Dmhmv (distance between HFM and VFM)
- *      m = angleHFM
- *	n = (0=don't use mirror angle) (1=use mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCCDLpDrv (struct tsubRecord *pRec) {
-	double Dmd=0.0,
-               TwoAlpha=0.0;
-
-	if ( pRec->a1 == 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-		return (-1);
-	}
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;     /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-
-	if (pRec->nla == 0.0)
-	{
-		Dmd = pRec->j * COSD(pRec->k) + pRec->d + pRec->l; /* Dmd=Dds*cos(2Q)+Dms+Dmhmv */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd=%g\n",
-                                                    pRec->name,Dmd);
-		Dmd = Dmd * tan(TwoAlpha);
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd*tan(angleHFM)=%g\n",
-                                                    pRec->name,Dmd);
-		pRec->oa0 = (pRec->a - pRec->a0 + Dmd) / pRec->a1; /* m1=(d1-offset1+tan(2*angleHFM)*Dmd)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpSpeed - CCD lateral position speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubCCDLpSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-/*	printf ("tsubCCDLpSpeed: called with n=%1.0f \n",pRec->nla); */
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   if (tsubCCDDebug > 0) {
-	      printf ("***tsub=%s(nla=%2.0f): exit on zero calc parameters\n",pRec->name,pRec->nla);
-	      printf ("***tsub=%s(nla=%2.0f): max1=%5.2f sca1=%g\n",pRec->name,pRec->nla,pRec->a,pRec->a3);
-	   }
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-/*	printf ("tsubCCDLpSpeed: m1=%5.2f\n",m1); */
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubCCDStRef[] = {
-    {"tsubCCDSt",      (REGISTRYFUNCTION)tsubCCDSt},
-    {"tsubCCDStSync",  (REGISTRYFUNCTION)tsubCCDStSync},
-    {"tsubCCDStMtr",   (REGISTRYFUNCTION)tsubCCDStMtr},
-    {"tsubCCDStDrv",   (REGISTRYFUNCTION)tsubCCDStDrv},
-    {"tsubCCDStAxs",   (REGISTRYFUNCTION)tsubCCDStAxs},
-    {"tsubCCDStSpeed", (REGISTRYFUNCTION)tsubCCDStSpeed},
-    {"tsubCCDLp",      (REGISTRYFUNCTION)tsubCCDLp},
-    {"tsubCCDLpSync",  (REGISTRYFUNCTION)tsubCCDLpSync},
-    {"tsubCCDLpMtr",   (REGISTRYFUNCTION)tsubCCDLpMtr},
-    {"tsubCCDLpDrv",   (REGISTRYFUNCTION)tsubCCDLpDrv},
-    {"tsubCCDLpSpeed", (REGISTRYFUNCTION)tsubCCDLpSpeed}
-};
-
-static void tsubCCDStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubCCDStRef,NELEMENTS(tsubCCDStRef));
-}
-epicsExportRegistrar(tsubCCDStFunc);
-
diff --git a/pmacApp/tsubSrc/tsubCCD2009.c b/pmacApp/tsubSrc/tsubCCD2009.c
deleted file mode 100644
index 7ed6bde..0000000
--- a/pmacApp/tsubSrc/tsubCCD2009.c
+++ /dev/null
@@ -1,791 +0,0 @@
-/* @(#) tsubCCD.c, version 2.0 2004/04/27 -- speed propagation; support axis sign and start changed */
-
-/* tsubCCDSt.c - Transformation Subroutines for CCD detector 2*Theta and distance      *
- *               (GM/CA CAT detector mounted on A-frame and supported by 3 motors)     *
- * tsubCCDLp.c - Transformation Subroutines for CCD detector lateral position          *
- *		 with respect to x-ray beam deflected by Horiz.Focusing Mirror (HFM)   *
- *               (GM/CA CAT detector mounted on A-frame with 1 motor for latera shift) */
-
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360 	     ((double) 1.7453292e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)      sin(DEG2RAD(deg))
-#define		COSD(deg)      cos(DEG2RAD(deg))
-#define		TAND(deg)      tan(DEG2RAD(deg))
-
-volatile int tsubCCDDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubCCDDebug == (level)) ) { code } }
-
-/* Distances are measured in mm, detector angle is degr., and mirror angles are in mrad */
-
-
-/* ===========================================
- * tsubCCDSt - CCD support
- */
-static long tsubCCDSt (struct tsubRecord *pRec) {
-        return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubCCDStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStMtr - CCD support Motors
- *	oa  = x1	(detector distance)
- *	ob  = x2        (detector 2*theta)
- *	oa1 = d1	(DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	oh  = S 	(vertical beam shift at sample due to mirror angle)
- *	a  = m1
- *	b  = m2
- *	c  = m3
- *	d  = Dms
- *      h  = sV (shift beam vertical)
- *      i  = bV (angle-Beam-Vertical)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStMtr (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       S=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-	TwoAlpha = 2.0*(pRec->i)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleVFM from mrad */
-	S = pRec->d * tan(TwoAlpha) + pRec->h;                 		      /* S=Dms*tan(2*angleBeam+2*angleVFM+2*angleBeam)+S0 */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(2*angleBeam+2*angleVFM)+S0=%g\n",
-                                                          pRec->name,S);
-	pRec->oh = S;
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;                    /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0 - S;                /* d2=m2*scale2+offset2-S*/
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0 - S;                /* d3=m3*scale3+offset3-S*/
-
-		Du = (pRec->oa1+pRec->k)*(pRec->oa1+pRec->k)                  /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->ob1+pRec->j)*(pRec->ob1+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                          pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->ob1)*Du+(pRec->j)*(D-pRec->oa1))	              /* sin(2Q+2a+2b)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a+2b)|=%g > 1 -- exit!\n",
-                                                          pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si)-TwoAlpha);                        /* 2Q = asin(sin(2Q+2a+2b))-2*angleVFM-2*angleBeam */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                          pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q+2a+2b)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a+2b)|=%g > 1 -- exit!\n",
-                                                          pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1.0-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->oa1)*(pRec->p+pRec->k)                      /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->ob1)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->oa1)                  /* d(2Q)=[d(D)*cos(2Q+2a+2b)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStDrv - CCD support Drives
- *	oa = x1		(detector distance)
- *	ob = x2         (detector 2*theta)
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1		(DD  - detector X-slide)
- *	b = d2          (VUS - detector vertical Upstream slide)
- *	c = d3          (VDS - detector vertical Downstream slide)
- *	d  = Dms
- *      h  = sV (shift beam vertical)
- *      i  = bV (angle-Beam-Vertical)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStDrv (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       S=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",
-                                                          pRec->name);
-                return (-1);
-	}
-
-	TwoAlpha = 2.0*(pRec->i)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleVFM from mrad */
-	S = pRec->d * tan(TwoAlpha) + pRec->h;                 		      /* S=Dms*tan(2*angleBeam+2*angleVFM+2*angleBeam)+S0 */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(2*angleBeam+2*angleVFM)+S0=%g\n",
-                                                          pRec->name,S);
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;                  /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0 + S) / pRec->b1;              /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0 + S) / pRec->c1;              /* m3=(d3-offset3)/scale3 */
-
-		Du = (pRec->a+pRec->k)*(pRec->a+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->b+pRec->j)*(pRec->b+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                          pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->b)*Du+(pRec->j)*(D-pRec->a))	              /* sin(2Q+2a+2b)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a+2b)|=%g > 1 -- exit!\n",
-                                                          pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si)-TwoAlpha);                        /* 2Q = asin(sin(2Q+2a+2b))-2*angleVFM-2*angleBeam */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                          pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q+2a+2b)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q+2a+2b)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->a)*(pRec->p+pRec->k)                        /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->b)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->a)                   /* d(2Q)=[d(D)*cos(2Q+2a+2b)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStAxs - CCD support Axes
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1        (DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	of = CCD:Lp:$(val)AutoFollow.PROC
- *	a = x1		(detector distance)
- *	b = x2		(detector 2*theta)
- *	d  = Dms
- *      h  = sV (shift beam vertical)
- *      i  = bV (angle-Beam-Vertical)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *      o  = dH (offset between Hu and Hd)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStAxs (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       S=0.0,
-	       QQ=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               Tg=0.0,
-               TwoAlpha=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",
-                                                          pRec->name);
-		return (-1);
-	}
-
-	TwoAlpha = 2.0*(pRec->i)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleVFM from mrad */
-	S = pRec->d * tan(TwoAlpha) + pRec->h;                 		      /* S=Dms*tan(2*angleBeam+2*angleVFM+2*angleBeam)+S0 */
-        if (tsubCCDDebug > 2) printf("+++tsub=%s: S=Dms*tan(2*angleBeam+2*angleVFM)+S0=%g\n",
-                                                          pRec->name,S);
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		Du  = pRec->a + pRec->k;                                      /* Du=D+Lh */
-		QQ = DEG2RAD(pRec->b) + TwoAlpha;                             /* 2Q'=2Q+2*angleVFM+2*angleBeam */
-		Si = sin(QQ);
-		Co = cos(QQ);
-		Tg = tan(QQ);
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q+2a+2b=%g rad\n" ,pRec->name,pRec->nla,QQ);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = Du*Co - (pRec->j)*Si - pRec->k;                   /* X =(D+Lh)*cos(2Q+2a+2b)-Lv*sin(2Q+2a+2b)-Lh */
-		pRec->ob1 = Du*Si + (pRec->j)*Co - pRec->j;                   /* Hu=(D+Lh)*sin(2Q+2a+2b)+Lv*cos(2Q+2a+2b)-Lv */
-		pRec->oc1 = pRec->ob1 + (pRec->l)*Tg + pRec->o/Co - pRec->o;  /* Hd=Hu+L*tan(2Q+2a+2b)+dH/cos(2Q+2a+2b)-dH */
-
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;                /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0 + S) / pRec->b1;            /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->oc1 - pRec->c0 + S) / pRec->c1;            /* m3=(d3-offset3)/scale3 */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		Du = pRec->r + pRec->k;                                       /* Du=D+Lh */
-		QQ = DEG2RAD(pRec->t) + TwoAlpha;                             /* 2Q'=2Q+2*angleVFM+2*angleBeam */
-		Si = sin(QQ);
-		Co = cos(QQ);
-		if ( Co == 0.0 ) {
-			if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g=0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Co);
-        		return (-1);
-		}
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q+2a+2b=%g rad\n" ,pRec->name,pRec->nla,QQ);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q+2a+2b)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = (pRec->a)*Co-DEG2RAD(pRec->b)*(Du*Si+(pRec->j)*Co);       /*  d(X)=d(D)*cos(2Q+2a+2b)-d(2Q)*(Du*sin(2Q+2a+2b)+Lv*sin(2Q+2a+2b)) */
-		pRec->ob1 = (pRec->a)*Si+DEG2RAD(pRec->b)*(Du*Co-(pRec->j)*Si);       /* d(Hu)=d(D)*sin(2Q+2a+2b)+d(2Q)(Du*cos(2Q+2a+2b)-Lv*sin(2Q+2a+2b)) */
-		pRec->oc1 = pRec->ob1+DEG2RAD(pRec->b)*(pRec->l+pRec->o*Si)/(Co*Co);  /* d(Hd)=d(Hu)+d(2Q)*[L+dH*sin(2Q+2a+2b)]/cos^2(2Q+2a+2b) */
-
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                           /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                           /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->oc1) / pRec->c1;                           /* m3=d3/scale3 */
-	}
-	pRec->of = 1;						              /* send signal to CCD:Lp to adapt position with new sitance */
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSpeed - CCD Support speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *      i  = bV (angle-Beam-Vertical)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	m  = angleVFM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	p  = d1_ActPos (X-slide actual)
- *	q  = d2_ActPos (VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubCCDStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	double Du=0.0,
-	       QQ=0.0,
-	       Co=0.0,
-               TwoAlpha=0.0;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubCCDDebug > 1) printf ("+++tsub=%s: called with n=%1.0f \n",pRec->name,pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ) {
-	   if (tsubCCDDebug > 0) {
-	      printf ("***tsub=%s: exit on zero calc parameters\n", pRec->name);
-	      printf ("***tsub=%s: max1=%5.2f sca1=%g\n", pRec->name,pRec->a,pRec->a3);
-	      printf ("***tsub=%s: max2=%5.2f sca2=%g\n", pRec->name,pRec->b,pRec->b3);
-	      printf ("***tsub=%s: max3=%5.2f sca3=%g\n", pRec->name,pRec->c,pRec->c3);
-	   }
-           return (-1);
-	}
-	TwoAlpha = 2.0*(pRec->i)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleVFM from mrad */
-
-	Du  = pRec->r + pRec->k;                                              /* Du=D+Lh */
-	if ( Du <= 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%2.0f): D+Lh=%g <= 0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Du);
-        	return (-1);
-	}
-	QQ = DEG2RAD(pRec->t) + TwoAlpha;                                     /* 2Q'=2Q+2*angleVFM+2*angleBeam */
-	Co = cos(QQ);
-	if ( Co == 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g=0 -- exit!\n",
-                                                          pRec->name,pRec->nla,Co);
-        	return (-1);
-	}
-        if (tsubCCDDebug > 2) {
-             	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-               	printf("+++tsub=%s(nla=%1.0f): 2Q+2a+2b=%g rad\n" ,pRec->name,pRec->nla,QQ);
-               	printf("+++tsub=%s(nla=%1.0f): cos(2Q+2a+2b)=%g\n",pRec->name,pRec->nla,Co);
-	}
-
-
-	if      (pRec->nla ==  1.0)  /* -------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);                              /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* -------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);                              /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* -------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);                              /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* --------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* --------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* --------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) /* --------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      if ( x1 != 0.0) {
-                  prcn = fabs( pRec->a2 / x1 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x1=0\n",
-                                                          pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else if (pRec->nla == 22.0) /* --------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                     /* d(2Q)=(d(D)*cos(2Q+2a+2b)-dX)/(Hu+Lv) */
-	      if ( x2 != 0.0) {
-                  prcn = fabs( pRec->b2 / x2 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x2=0\n",
-                                                          pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else
-	{
-           if (tsubCCDDebug > 0) printf ("***tsub=%s: incorrect nla=%1.0f -- exit!\n",
-                                                          pRec->name,pRec->nla);
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): prcn=%g not in 0-1 range\n",
-                                                          pRec->name,pRec->nla,prcn);
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                                  /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                                  /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                                  /* m3=prcn*m3_max */
-	d1 = 1000.0*m1*(pRec->a3);                                            /* d1=m1*scale1   */
-	d2 = 1000.0*m2*(pRec->b3);                                            /* d2=m2*scale2   */
-	d3 = 1000.0*m3*(pRec->c3);                                            /* d3=m3*scale3   */
-	x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;                  /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                           /* d(2Q)=(d(D)*cos(2Q+2a+2b)-dX)/(Hu+Lv) */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = fabs(d1);
-	pRec->ob1 = fabs(d2);
-	pRec->oc1 = fabs(d3);
-	pRec->oa2 = fabs(x1);
-	pRec->ob2 = fabs(x2);
-        if (tsubCCDDebug > 1) printf ("+++tsub=%s(nla=%1.0f):  m1=%5.2f  m2=%5.2f  m3=%5.2f\n",
-                                                          pRec->name,pRec->nla,m1,m2,m3);
-	return (ifail);
-}
-
-
-/* ========================================================================== */
-
-
-/* ===========================================
- * tsubCCDLp - CCD lateral position
- */
-static long tsubCCDLp (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubCCDLpSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpMtr - CCD lateral position Motors
- *	oa1 = d1
- *	a = m1
- *      g = sH  (beam H-shift at mirror)
- *      h = bH  (beam H-angle correction)
- *      i = Dms (mirror to sample distance from CCDSt)
- *	j = Dds (detector distance from CCDSt)
- *      k = 2Q  (detector 2*theta from CCDSt)
- *      l = Dmhmv (distance between HFM and VFM)
- *      m = angleHFM
- *	n = (0=don't use mirror angle) (1=use mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCCDLpMtr (struct tsubRecord *pRec) {
-	double Dmd=0.0,
-	       DL = 0.0,
-               TwoAlpha=0.0;
-
-	TwoAlpha = 2.0*(pRec->h)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleHFM from mrad */
-
-	if (pRec->nla == 0.0)
-	{
-		Dmd = pRec->j * COSD(pRec->k) + pRec->i + pRec->l; 	      /* Dmd=Dds*cos(2Q)+Dms+Dmhmv */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd=%g\n",
-                                                          pRec->name,Dmd);
-		DL = Dmd * tan(TwoAlpha) + pRec->g;                          /* DL=Dmd*tan(2a+2b)+Soh */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: DL=Dmd*tan(2a+2b)+Soh=%g\n",
-                                                          pRec->name,DL);
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0 - DL;   	      /* d1=m1*scale1+offset1-DL */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    	      /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpDrv - CCD lateral position Drives
- *	oa0 = m1
- *	a = d1
- *      g = sH  (beam H-shift at mirror)
- *      h = bH  (beam H-angle correction)
- *      i = Dms (mirror to sample distance from CCDSt)
- *	j = Dds (detector distance from CCDSt)
- *      k = 2Q  (detector 2*theta from CCDSt)
- *      l = Dmhmv (distance between HFM and VFM)
- *      m = angleHFM
- *	n = (0=don't use mirror angle) (1=use mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCCDLpDrv (struct tsubRecord *pRec) {
-	double Dmd=0.0,
-	       DL = 0.0,
-               TwoAlpha=0.0;
-
-	if ( pRec->a1 == 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-		return (-1);
-	}
-	TwoAlpha = 2.0*(pRec->h)/1000.0;                		      /* recalc. angleBeam from mrad */
-	if (pRec->n != 0.0) TwoAlpha += 2.0*(pRec->m)/1000.0;                 /* recalc. angleHFM from mrad */
-
-	if (pRec->nla == 0.0)
-	{
-		Dmd = pRec->j * COSD(pRec->k) + pRec->i + pRec->l; 	      /* Dmd=Dds*cos(2Q)+Dms+Dmhmv */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: Dmd=%g\n",
-                                                          pRec->name,Dmd);
-		DL = Dmd * tan(TwoAlpha) + pRec->g;                           /* DL=Dmd*tan(2a+2b)+Soh */
-        	if (tsubCCDDebug > 2) printf("+++tsub=%s: DL=Dmd*tan(angleHFM)+Soh=%g\n",
-                                                          pRec->name,DL);
-		pRec->oa0 = (pRec->a - pRec->a0 + DL) / pRec->a1;             /* m1=(d1-offset1+DL)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                               /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDLpSpeed - CCD lateral position speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubCCDLpSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                                         /* sdis=1 */
-
-/*	printf ("tsubCCDLpSpeed: called with n=%1.0f \n",pRec->nla); */
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   if (tsubCCDDebug > 0) {
-	      printf ("***tsub=%s(nla=%2.0f): exit on zero calc parameters\n",pRec->name,pRec->nla);
-	      printf ("***tsub=%s(nla=%2.0f): max1=%5.2f sca1=%g\n",pRec->name,pRec->nla,pRec->a,pRec->a3);
-	   }
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );                            /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                                  /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );                                 /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-/*	printf ("tsubCCDLpSpeed: m1=%5.2f\n",m1); */
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubCCDStRef[] = {
-    {"tsubCCDSt",      (REGISTRYFUNCTION)tsubCCDSt},
-    {"tsubCCDStSync",  (REGISTRYFUNCTION)tsubCCDStSync},
-    {"tsubCCDStMtr",   (REGISTRYFUNCTION)tsubCCDStMtr},
-    {"tsubCCDStDrv",   (REGISTRYFUNCTION)tsubCCDStDrv},
-    {"tsubCCDStAxs",   (REGISTRYFUNCTION)tsubCCDStAxs},
-    {"tsubCCDStSpeed", (REGISTRYFUNCTION)tsubCCDStSpeed},
-    {"tsubCCDLp",      (REGISTRYFUNCTION)tsubCCDLp},
-    {"tsubCCDLpSync",  (REGISTRYFUNCTION)tsubCCDLpSync},
-    {"tsubCCDLpMtr",   (REGISTRYFUNCTION)tsubCCDLpMtr},
-    {"tsubCCDLpDrv",   (REGISTRYFUNCTION)tsubCCDLpDrv},
-    {"tsubCCDLpSpeed", (REGISTRYFUNCTION)tsubCCDLpSpeed}
-};
-
-static void tsubCCDStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubCCDStRef,NELEMENTS(tsubCCDStRef));
-}
-epicsExportRegistrar(tsubCCDStFunc);
-
diff --git a/pmacApp/tsubSrc/tsubCCD_bm_no_extern_offset.c b/pmacApp/tsubSrc/tsubCCD_bm_no_extern_offset.c
deleted file mode 100644
index 5415931..0000000
--- a/pmacApp/tsubSrc/tsubCCD_bm_no_extern_offset.c
+++ /dev/null
@@ -1,559 +0,0 @@
-/* @(#) tsubCCD.c, version 2.0 2004/04/27 -- speed propagation; support axis sign and start changed */
-
-/* tsubCCDSt.c - Transformation Subroutines for CCD detector 2*Theta and distance      *
- *               (GM/CA CAT detector mounted on A-frame and supported by 3 motors)     *
- * tsubCCDLp.c - Transformation Subroutines for CCD detector lateral position          *
- *		 with respect to x-ray beam deflected by Horiz.Focusing Mirror (HFM)   *
- *               (GM/CA CAT detector mounted on A-frame with 1 motor for latera shift) */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360       ((double) 1.7453292e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)      sin(DEG2RAD(deg))
-#define		COSD(deg)      cos(DEG2RAD(deg))
-#define		TAND(deg)      tan(DEG2RAD(deg))
-
-volatile int tsubCCDDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubCCDDebug == (level)) ) { code } }
-
-/* Distances are measured in mm, detector angle is degr., and mirror angles are in mrad */
-
-
-/* ===========================================
- * tsubCCDSt - CCD support
- */
-static long tsubCCDSt (struct tsubRecord *pRec) {
-        return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubCCDStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStMtr - CCD support Motors
- *	oa  = x1	(detector distance)
- *	ob  = x2        (detector 2*theta)
- *	oa1 = d1	(DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	a  = m1
- *	b  = m2
- *	c  = m3
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStMtr (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       Si=0.0,
-	       Co=0.0;
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;                    /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;                    /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;                    /* d3=m3*scale3+offset3 */
-
-		Du = (pRec->oa1+pRec->k)*(pRec->oa1+pRec->k)                  /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->ob1+pRec->j)*(pRec->ob1+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->ob1)*Du+(pRec->j)*(D-pRec->oa1))	              /* sin(2Q)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si));                                 /* 2Q = asin(sin(2Q)) */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1.0-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->oa1)*(pRec->p+pRec->k)                      /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->ob1)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->oa1)                  /* d(2Q)=[d(D)*cos(2Q)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStDrv - CCD support Drives
- *	oa = x1		(detector distance)
- *	ob = x2         (detector 2*theta)
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1		(DD  - detector X-slide)
- *	b = d2          (VUS - detector vertical Upstream slide)
- *	c = d3          (VDS - detector vertical Downstream slide)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStDrv (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       D=0.0,
-	       Si=0.0,
-	       Co=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-                return (-1);
-	}
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;                  /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;                  /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;                  /* m3=(d3-offset3)/scale3 */
-
-		Du = (pRec->a+pRec->k)*(pRec->a+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->b+pRec->j)*(pRec->b+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->b)*Du+(pRec->j)*(D-pRec->a))	              /* sin(2Q)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		pRec->oa = D;		                                      /*  D = Du-Lh */
-		pRec->ob = RAD2DEG(asin(Si));                                 /* 2Q = asin(sin(2Q)) */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3 */
-
-		/* First calculate absolute positions based on actual X and Hu */
-		Du = (pRec->p+pRec->k)*(pRec->p+pRec->k)                      /* Du^2=(X+Lh)^2+(Hu+Lv)^2-Lv^2 */
-                   + (pRec->q+pRec->j)*(pRec->q+pRec->j)
-                   - (pRec->j)*(pRec->j);
-	        if ( Du <= 0.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): (D+Lh)^2=%g <= 0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Du);
-                     return (-1);
-		}
-		Du = sqrt(Du);                                                /* Du is: Du=D+Lh */
-		D  = Du - pRec->k;	                                      /*  D = Du-Lh */
-  	        if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): D+Lh=%7.2f, D=%7.2f\n",
-                                                            pRec->name,pRec->nla,Du,D);
-		Si = ((pRec->q)*Du+(pRec->j)*(D-pRec->p))                     /* sin(2Q)=[Hu*Du+Lv(D-X)]/[Du^2+Lv^2] */
-		   / (Du*Du+(pRec->j)*(pRec->j));
-	        if ( fabs(Si) > 1.0 ) {
-		     if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): |sin(2Q)|=%g > 1 -- exit!\n",
-                                                                              pRec->name,pRec->nla,Si);
-                     return (-1);
-		}
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Si);
-		Co = sqrt(1-Si*Si);
-		if (tsubCCDDebug > 2) printf("+++tsub=%s(nla=%1.0f): cos(2Q)=%g\n",
-                                                          pRec->name,pRec->nla,Co);
-		pRec->oa =((pRec->a)*(pRec->p+pRec->k)                        /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-                         + (pRec->b)*(pRec->q+pRec->j))
-                         / Du;
-		pRec->ob = RAD2DEG(((pRec->oa)*Co-pRec->a)                   /* d(2Q)=[d(D)*cos(2Q)-dX]/(Hu+Lv) */
-                                   /(pRec->q+pRec->j));
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStAxs - CCD support Axes
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1        (DD  - detector X-slide)
- *	ob1 = d2	(VUS - detector vertical Upstream slide)
- *	oc1 = d3	(VDS - detector vertical Downstream slide)
- *	a = x1		(detector distance)
- *	b = x2		(detector 2*theta)
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *      o  = dH (offset between Hu and Hd)
- *	p  = d1_ActPos	(X-slide actual)
- *	q  = d2_ActPos	(VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubCCDStAxs (struct tsubRecord *pRec) {
-	double Du=0.0,
-	       Si=0.0,
-	       Co=0.0,
-               Tg=0.0;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (pRec->c1 == 0.0) ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s: scale=0 -- exit!\n",pRec->name);
-		return (-1);
-	}
-
-	if (pRec->nla == 0.0)   /* ------- Absolute motion --------- */
-	{
-		Du  = pRec->a + pRec->k;                                      /* Du=D+Lh */
-		Si = SIND(pRec->b);
-		Co = COSD(pRec->b);
-		Tg = TAND(pRec->b);
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q=%g degr\n" ,pRec->name,pRec->nla,pRec->b);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = Du*Co - (pRec->j)*Si - pRec->k;                   /* X =(D+Lh)*cos(2Q)-Lv*sin(2Q)-Lh */
-		pRec->ob1 = Du*Si + (pRec->j)*Co - pRec->j;                   /* Hu=(D+Lh)*sin(2Q)+Lv*cos(2Q)-Lv */
-		pRec->oc1 = pRec->ob1 + (pRec->l)*Tg + pRec->o/Co - pRec->o;  /* Hd=Hu+L*tan(2Q)+dH/cos(2Q)-dH */
-
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;                /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;                /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->oc1 - pRec->c0) / pRec->c1;                /* m3=(d3-offset3)/scale3 */
-	}
-	else                    /* ------- Relative motion --------- */
-	{
-		Du = pRec->r + pRec->k;                                       /* Du=D+Lh */
-		Si = SIND(pRec->t);
-		Co = COSD(pRec->t);
-		if ( Co == 0.0 ) {
-			if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q)=%g=0 -- exit!\n",
-                                                                                  pRec->name,pRec->nla,Co);
-        		return (-1);
-		}
-                if (tsubCCDDebug > 2) {
-                	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-                	printf("+++tsub=%s(nla=%1.0f): 2Q=%g rad\n" ,pRec->name,pRec->nla,pRec->t);
-                	printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",pRec->name,pRec->nla,Si);
-                	printf("+++tsub=%s(nla=%1.0f): cos(2Q)=%g\n",pRec->name,pRec->nla,Co);
-		}
-
-		pRec->oa1 = (pRec->a)*Co-DEG2RAD(pRec->b)*(Du*Si+(pRec->j)*Co);       /*  d(X)=d(D)*cos(2Q)-d(2Q)*(Du*sin(2Q)+Lv*sin(2Q)) */
-		pRec->ob1 = (pRec->a)*Si+DEG2RAD(pRec->b)*(Du*Co-(pRec->j)*Si);       /* d(Hu)=d(D)*sin(2Q)+d(2Q)(Du*cos(2Q)-Lv*sin(2Q)) */
-		pRec->oc1 = pRec->ob1+DEG2RAD(pRec->b)*(pRec->l+pRec->o*Si)/(Co*Co);  /* d(Hd)=d(Hu)+d(2Q)*[L+dH*sin(2Q)]/cos^2(2Q) */
-
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                           /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                           /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->oc1) / pRec->c1;                           /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCCDStSpeed - CCD Support speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	j  = Lv
- *	k  = Lh
- *	l  = L
- *      o  = dH (offset between Hu and Hd)
- *	p  = d1_ActPos (X-slide actual)
- *	q  = d2_ActPos (VUS actual)
- *	r  = x1_ActPos	(Distance actual)
- *	t  = x2_ActPos	(2*Theta actual)
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubCCDStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	double Du=0.0,
-	       Si=0.0,
-	       Co=0.0;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubCCDDebug > 1) printf ("+++tsub=%s: called with n=%1.0f \n",pRec->name,pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ) {
-	   if (tsubCCDDebug > 0) {
-	      printf ("***tsub=%s: exit on zero calc parameters\n", pRec->name);
-	      printf ("***tsub=%s: max1=%5.2f sca1=%g\n", pRec->name,pRec->a,pRec->a3);
-	      printf ("***tsub=%s: max2=%5.2f sca2=%g\n", pRec->name,pRec->b,pRec->b3);
-	      printf ("***tsub=%s: max3=%5.2f sca3=%g\n", pRec->name,pRec->c,pRec->c3);
-	   }
-           return (-1);
-	}
-
-	Du  = pRec->r + pRec->k;                                              /* Du=D+Lh */
-	if ( Du <= 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%2.0f): D+Lh=%g <= 0 -- exit!\n",
-                                                                pRec->name,pRec->nla,Du);
-        	return (-1);
-	}
-	Si = SIND(pRec->t);
-	Co = COSD(pRec->t);
-	if ( Co == 0.0 ) {
-		if (tsubCCDDebug > 0) printf("***tsub=%s(nla=%1.0f): cos(2Q+2VFM)=%g=0 -- exit!\n",
-                                                                          pRec->name,pRec->nla,Co);
-        	return (-1);
-	}
-        if (tsubCCDDebug > 2) {
-             	printf("+++tsub=%s: D+Lh=%g\n",pRec->name,Du);
-               	printf("+++tsub=%s(nla=%1.0f): 2Q=%g degr\n" ,pRec->name,pRec->nla,pRec->t);
-               	printf("+++tsub=%s(nla=%1.0f): sin(2Q)=%g\n",pRec->name,pRec->nla,Si);
-               	printf("+++tsub=%s(nla=%1.0f): cos(2Q)=%g\n",pRec->name,pRec->nla,Co);
-	}
-
-
-	if      (pRec->nla ==  1.0)  /* -------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);                              /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* -------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);                              /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* -------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);                              /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* --------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* --------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* --------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) /* --------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      if ( x1 != 0.0) {
-                  prcn = fabs( pRec->a2 / x1 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x1=0\n",pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else if (pRec->nla == 22.0) /* --------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;                                 /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;                                 /* if 0, then set to max */
-	   else {
-	      d1 = 1000.0 *  pRec->a * pRec->a3;                              /* d1=m1*scale1 */
-	      d2 = 1000.0 *  pRec->b * pRec->b3;                              /* d2=m2*scale2 */
-	      d3 = 1000.0 *  pRec->c * pRec->c3;                              /* d3=m3*scale3 */
-	      x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;            /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	      x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                     /* d(2Q)=(d(D)*cos(2Q)-dX)/(Hu+Lv) */
-	      if ( x2 != 0.0) {
-                  prcn = fabs( pRec->b2 / x2 );
-	      }
-	      else {
-	          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): x2=0\n",pRec->name,pRec->nla);
-		  prcn = 1.0;
-	      }
-	   }
-	}
-	else
-	{
-           if (tsubCCDDebug > 0) printf ("***tsub=%s: incorrect nla=%1.0f -- exit!\n",pRec->name,pRec->nla);
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          if (tsubCCDDebug > 0) printf ("***tsub=%s(nla=%1.0f): prcn=%g not in 0-1 range\n",
-                                                                 pRec->name,pRec->nla,prcn);
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                                  /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                                  /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                                  /* m3=prcn*m3_max */
-	d1 = 1000.0*m1*(pRec->a3);                                            /* d1=m1*scale1   */
-	d2 = 1000.0*m2*(pRec->b3);                                            /* d2=m2*scale2   */
-	d3 = 1000.0*m3*(pRec->c3);                                            /* d3=m3*scale3   */
-	x1 = (d1*(pRec->p+pRec->l)+d2*(pRec->q+pRec->j))/Du;                  /* d(D) =[dX*(X+Lh)+dHu*(Hu+Lv)]/Du */
-	x2 = RAD2DEG((x1*Co-d1)/(pRec->q+pRec->j));                           /* d(2Q)=(d(D)*cos(2Q)-dX)/(Hu+Lv) */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = fabs(d1);
-	pRec->ob1 = fabs(d2);
-	pRec->oc1 = fabs(d3);
-	pRec->oa2 = fabs(x1);
-	pRec->ob2 = fabs(x2);
-        if (tsubCCDDebug > 1) printf ("+++tsub=%s(nla=%1.0f):  m1=%5.2f  m2=%5.2f  m3=%5.2f\n",
-                                                                pRec->name,pRec->nla,m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubCCDStRef[] = {
-    {"tsubCCDSt",      (REGISTRYFUNCTION)tsubCCDSt},
-    {"tsubCCDStSync",  (REGISTRYFUNCTION)tsubCCDStSync},
-    {"tsubCCDStMtr",   (REGISTRYFUNCTION)tsubCCDStMtr},
-    {"tsubCCDStDrv",   (REGISTRYFUNCTION)tsubCCDStDrv},
-    {"tsubCCDStAxs",   (REGISTRYFUNCTION)tsubCCDStAxs},
-    {"tsubCCDStSpeed", (REGISTRYFUNCTION)tsubCCDStSpeed}
-};
-
-static void tsubCCDStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubCCDStRef,NELEMENTS(tsubCCDStRef));
-}
-epicsExportRegistrar(tsubCCDStFunc);
diff --git a/pmacApp/tsubSrc/tsubCS.c b/pmacApp/tsubSrc/tsubCS.c
deleted file mode 100644
index b8da754..0000000
--- a/pmacApp/tsubSrc/tsubCS.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/* @(#) tsubCS.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubCS.c - Transformation Subroutines For Collimator Slits */
-/* These equations are for "piggy-back" slits, i.e. blade-2   */
-/* runs "on the back" of blade-1                              */
-/*                ** ACCEL SLITS CONFIGURATION **             */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubCSDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubCSDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubCSAp - Aperture Initialization
- */
-static long tsubCSAp (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubCSApSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubCSApSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubCSApMtr - Aperture Motors To Drives           |  ACCEL CSAv      |  ACCEL CSAh      |   xxx (biocat?)   |
- *	oa = x1  (x_center)                          | d1=top,d2=piggy  | d1=out,f2=piggy  | d1=bottom,d2=piggy|
- *	ob = x2  (x_size)                            |    d2 < 0        |    d2 < 0        |   d2 > 0          |
- *	oa1 = d1 (d_out or d_top)    -- independent  | center=d1+0.5*d2 | center=d1+0.5*d2 | center=d1+0.5*d2  |
- *	ob1 = d2 (d_in  or d_bottom) -- piggy-backed |   size=-d2       |   size=-d2       |   size=d2         |
- *	a = m1   (m_position)                        |    top=d1        |    out=d1        |    top=d1+d2      |
- *	b = m2   (m_size)                            | bottom=d1+d2     |     in=d1+d2     | bottom=d1         |
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCSApMtr (struct tsubRecord *pRec) {
-	double d2_real;
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1 = m1*scale1+offset1 */
-		d2_real   = pRec->b * pRec->b1 + pRec->b0;         /* d2'= m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1 = m1*scale1 */
-		d2_real   = pRec->b * pRec->b1;                    /* d2'= m2*scale2 */
-	}
-	pRec->ob1 = pRec->oa1 + d2_real;                           /* d2 = d1+d2' */
-
-	pRec->oa =       0.5         * (pRec->ob1 + pRec->oa1);    /* x1=0.5*(d2+d1) */
-	pRec->ob = (1 - 2 * pRec->i) * (pRec->ob1 - pRec->oa1);    /* x2=inv*(d2-d1) */
-	return (0);
-}
-
-/* ===========================================
- * tsubCSApDrv - Horizontal Aperture Drives          |  ACCEL CSAv      |  ACCEL CSAh      |   xxx (biocat?)   |
- *	oa = x1  (x_center)                          | d1=top,d2=piggy  | d1=out,f2=piggy  | d1=bottom,d2=piggy|
- *	ob = x2  (x_size)                            |    d2 < 0        |    d2 < 0        |   d2 > 0          |
- *	oa0 = m1 (m_position)                        | center=d1+0.5*d2 | center=d1+0.5*d2 | center=d1+0.5*d2  |
- *	ob0 = m2 (m_size)                            |   size=-d2       |   size=-d2       |   size=d2         |
- *	a = d1   (d_out or d_top)    -- independent  |    top=d1        |    out=d1        |    top=d1+d2      |
- *	b = d2   (d_in  or d_bottom) -- piggy-backed | bottom=d1+d2     |     in=d1+d2     | bottom=d1         |
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCSApDrv (struct tsubRecord *pRec) {
-	double d2_real;
-
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-
-	d2_real = (pRec->b - pRec->a);                             /* d2'= d2-d1 */
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1 -offset1)/scale1 */
-		pRec->ob0 = (d2_real - pRec->b0) / pRec->b1;       /* m2=(d2'-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                  /* m1=d1 /scale1 */
-		pRec->ob0 = (d2_real) / pRec->b1;                  /* m2=d2'/scale2 */
-	}
-
-	pRec->oa =       0.5         * (pRec->b + pRec->a);        /* x1=0.5*(d2+d1) */
-	pRec->ob = (1 - 2 * pRec->i) * (pRec->b - pRec->a);        /* x2=inv*(d2-d1) */
- 	return (0);
-}
-
-/* ===========================================
- * tsubCSApAxs - Horizontal Aperture Axes            |  ACCEL CSAv      |  ACCEL CSAh      |   xxx (biocat?)   |
- *	oa0 = m1 (m_position)                        | d1=top,d2=piggy  | d1=out,f2=piggy  | d1=bottom,d2=piggy|
- *	oa1 = d1 (d_out or d_top)    -- independent  |    d2 < 0        |    d2 < 0        |   d2 > 0          |
- *	ob0 = m2 (m_size)                            | center=d1+0.5*d2 | center=d1+0.5*d2 | center=d1+0.5*d2  |
- *	ob1 = d2 (d_in  or d_bottom) -- piggy-backed |   size=-d2       |   size=-d2       |   size=d2         |
- *	a = x1   (x_center)                          |    top=d1        |    out=d1        |    top=d1+d2      |
- *	b = x2   (x_size)                            | bottom=d1+d2     |     in=d1+d2     | bottom=d1         |
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubCSApAxs (struct tsubRecord *pRec) {
-	double d2_real;
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-
-	pRec->oa1 = pRec->a - (0.5 - pRec->i) * pRec->b;           /* d1=x1-0.5*inv*x2 */
-	pRec->ob1 = pRec->a + (0.5 - pRec->i) * pRec->b;           /* d2=x1+0.5*inv*x2 */
-
-	d2_real = (pRec->ob1 - pRec->oa1);                         /* d2'= d2-d1 */
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1 -offset1)/scale1 */
-		pRec->ob0 = ( d2_real  - pRec->b0) / pRec->b1;     /* m2=(d2'-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1 /scale1 */
-		pRec->ob0 =  (d2_real)  / pRec->b1;                /* m2=d2'/scale2 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubCSApSpeed - Speed propagation spreadsheet
- *	oa0 = m1    (m_position)                        |  ACCEL CSAv      |  ACCEL CSAh      |
- *	ob0 = m2    (m_size)                            | d1=top,d2=piggy  | d1=out,f2=piggy  |
- *	oa1 = d1    (d_out or d_top)    -- independent  |    d2 < 0        |    d2 < 0        |
- *	ob1 = d2    (d_in  or d_bottom) -- piggy-backed | center=d1+0.5*d2 | center=d1+0.5*d2 |
- *	oa2 = x1    (x_center)                          |   size=-d2       |   size=-d2       |
- *	ob2 = x2    (x_size)                            |    top=d1        |    out=d1        |
- *      oj  = sdis (sdis=1 -- disable record processing)| bottom=d1+d2     |     in=d1+d2     |
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1     (m_position)
- *	b0 = m2     (m_size)
- *	a1 = d1     (d_out or d_top)    -- independent
- *	b1 = d2     (d_in  or d_bottom) -- piggy-backed
- *	a2 = x1     (x_center)
- *	b2 = x2     (x_size)
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubCSApSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubCSDebug > 1) printf ("tsubCSApSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ) {
-	   printf ("tsubCSApSpeed: exit on zero calc parameters\n");
-	   printf ("tsubCSApSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubCSApSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* In piggy-back slit the speed of center is the same as the speed of the first blade */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-              prcn = fabs( pRec->a2 / d1 );
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* In piggy-back slit the speed of size is the same as the speed of the second blade */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-              prcn = fabs( pRec->b2 / d2 );
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	x1 = d1;                                         /* center */
-	x2 = d2;                                         /* size */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubCSDebug > 1) printf ("tsubCSApSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubCSApRef[] = {
-    {"tsubCSAp",      (REGISTRYFUNCTION)tsubCSAp},
-    {"tsubCSApSync",  (REGISTRYFUNCTION)tsubCSApSync},
-    {"tsubCSApMtr",   (REGISTRYFUNCTION)tsubCSApMtr},
-    {"tsubCSApDrv",   (REGISTRYFUNCTION)tsubCSApDrv},
-    {"tsubCSApAxs",   (REGISTRYFUNCTION)tsubCSApAxs},
-    {"tsubCSApSpeed", (REGISTRYFUNCTION)tsubCSApSpeed}
-};
-
-static void tsubCSApFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubCSApRef,NELEMENTS(tsubCSApRef));
-}
-epicsExportRegistrar(tsubCSApFunc);
-
diff --git a/pmacApp/tsubSrc/tsubCollimator.c b/pmacApp/tsubSrc/tsubCollimator.c
deleted file mode 100644
index b8e14a5..0000000
--- a/pmacApp/tsubSrc/tsubCollimator.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/* @(#) tsubCollimator.c 2011/07/01 */
-
-/* tsubCollimator.c - Save/Upload collimator presets on the event of changing collimator  */
-/* This tsub is associated with the $(BL)bi:copyColPresets record in the bluiceConfig.db */
-/* that is processed on the change of $(BL)bi:currentCollimatorSet */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubCollDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubCollDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubColl - Initialization
- */
-static long tsubColl (struct tsubRecord *pRec) {
-/*	printf ("+++tsub=%s:  initialization\n",pRec->name); */
-	return (0);
-}
-
-/* ===========================================
- * tsubCollSR - save current presets and upload new
- *	a = requested set (1=set1/0=set0)
- *	oa =  memorized index of currently loaded set (1=set1/0=set0)
- *	oa0 ... oa9 = set-0
- *	ob0 ... ob9 = set-1
- *	oc0...oc9 = output presets (new presets to be set)
- *	c0 ... c9 = input preset (previous presets to be backed up)
- */
-static long tsubCollSR (struct tsubRecord *pRec) {
-        /* printf ("+++tsub=%s:  set=%5.2f\n",pRec->name,pRec->a); */
-	if (pRec->a == 0) {				/* set-0 is requested */
-	   if (pRec->oa != pRec->a) {			/* choice changed! */
-
-		pRec->oa = pRec->a;			/* remember choice */
-
-		pRec->ob0 = pRec->c0;			/* memorize presets of set-1 */
-		pRec->ob1 = pRec->c1;
-		pRec->ob2 = pRec->c2;
-		pRec->ob3 = pRec->c3;
-		pRec->ob4 = pRec->c4;
-		pRec->ob5 = pRec->c5;
-		pRec->ob6 = pRec->c6;
-		pRec->ob7 = pRec->c7;
-		pRec->ob8 = pRec->c8;
-		pRec->ob9 = pRec->c9;
-
-		pRec->oc0 = pRec->oa0;			/* load set-0 presets */
-		pRec->oc1 = pRec->oa1;
-		pRec->oc2 = pRec->oa2;
-		pRec->oc3 = pRec->oa3;
-		pRec->oc4 = pRec->oa4;
-		pRec->oc5 = pRec->oa5;
-		pRec->oc6 = pRec->oa6;
-		pRec->oc7 = pRec->oa7;
-		pRec->oc8 = pRec->oa8;
-		pRec->oc9 = pRec->oa9;
-	   }
-	} else {                                        /* set-1 is requested */
-	   if (pRec->oa != pRec->a) {			/* choice changed! */
-
-		pRec->oa = pRec->a;			/* remember choice */
-
-		pRec->oa0 = pRec->c0;                   /* memorize presets of set-0 */
-		pRec->oa1 = pRec->c1;
-		pRec->oa2 = pRec->c2;
-		pRec->oa3 = pRec->c3;
-		pRec->oa4 = pRec->c4;
-		pRec->oa5 = pRec->c5;
-		pRec->oa6 = pRec->c6;
-		pRec->oa7 = pRec->c7;
-		pRec->oa8 = pRec->c8;
-		pRec->oa9 = pRec->c9;
-
-		pRec->oc0 = pRec->ob0;                  /* load set-1 presets */
-		pRec->oc1 = pRec->ob1;
-		pRec->oc2 = pRec->ob2;
-		pRec->oc3 = pRec->ob3;
-		pRec->oc4 = pRec->ob4;
-		pRec->oc5 = pRec->ob5;
-		pRec->oc6 = pRec->ob6;
-		pRec->oc7 = pRec->ob7;
-		pRec->oc8 = pRec->ob8;
-		pRec->oc9 = pRec->ob9;
-	   }
-	}
-	return (0);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubCollRef[] = {
-    {"tsubColl",  (REGISTRYFUNCTION)tsubColl},
-    {"tsubCollSR",(REGISTRYFUNCTION)tsubCollSR}
-};
-
-static void tsubCollFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubCollRef,NELEMENTS(tsubCollRef));
-}
-epicsExportRegistrar(tsubCollFunc);
-
diff --git a/pmacApp/tsubSrc/tsubDN.c b/pmacApp/tsubSrc/tsubDN.c
deleted file mode 100644
index 21ff18a..0000000
--- a/pmacApp/tsubSrc/tsubDN.c
+++ /dev/null
@@ -1,298 +0,0 @@
-/* @(#) tsubDN.c 1.4 97/04/03 */
-
-/* tsubDN.c - Transformation Subroutines For Downstream Support */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define TSUB_DIAGNOSTIC tsubDNDebug
-
-volatile int tsubDNDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubDNDebug == (level)) ) { code } }
-
-
-/* if x1=mm, x2=mrad, base=m (BioCAT), then FCDN=1; if base=mm, then FCDN=1000. */
-double FCDN = 1.0;
-
-/* ===========================================
- * tsubDNSt - Support Initialization
- */
-static long tsubDNSt (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubDNStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubDNStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubDNStMtr - Support Motors
- *	oa = x1
- *	ob = x2
- *	oa1 = d1
- *	ob1 = d2
- *	a = m1
- *	b = m2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubDNStMtr (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-	}
-	pRec->ob = FCDN * (pRec->ob1 - pRec->oa1) / pRec->k;       /* x2=(d2-d1)/BaseLength */
-	pRec->oa = pRec->oa1 + (pRec->ob * pRec->l / FCDN);        /* x1=d1+x2*RotOrigin */
-	return (0);				   /* another way is: x1=d1*(1-R/B)+d2*(R/B) */
-}
-
-/* ===========================================
- * tsubDNStDrv - Support Drives
- *	oa = x1
- *	ob = x2
- *	oa0 = m1
- *	ob0 = m2
- *	a = d1
- *	b = d2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubDNStDrv (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) ||
-	     (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                  /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                  /* m2=d2/scale2 */
-	}
-	pRec->ob = FCDN * (pRec->b - pRec->a) / pRec->k;           /* x2=(d2-d1)/BaseLength */
-	pRec->oa = pRec->a + (pRec->ob * pRec->l / FCDN);          /* x1=d1+x2*RotOrigin    */
-	return (0); 				   /* another way is: x1=d1*(1-R/B)+d2*(R/B) */
-
-}
-
-/* ===========================================
- * tsubDNStAxs - Support Axes
- *	oa0 = m1
- *	oa1 = d1
- *	ob0 = m2
- *	ob1 = d2
- *	a = x1
- *	b = x2
- *	k = BaseLength
- *	l = RotOrigin
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubDNStAxs (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	pRec->oa1 = pRec->a - (pRec->b * pRec->l / FCDN);          /* d1=x1-x2*RotOrigin     */
-	pRec->ob1 = pRec->b * (pRec->k / FCDN) + pRec->oa1;        /* d2=x2*BaseLength+d1    */
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;     /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                /* m2=d2/scale2 */
-	}
-	return (0);
-}
-
-
-/* ===========================================
- * tsubDNStSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oa1 = d1
- *	ob1 = d2
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	k = BaseLength
- *	l = RotOrigin
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubDNStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2, r;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubDNDebug > 1) printf ("tsubDNStSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ||
-             pRec->k  == 0.0) {
-	   printf ("tsubDNStSpeed: exit on zero calc parameters\n");
-	   printf ("tsubDNStSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubDNStSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubDNStSpeed: BaseLength=%g\n",pRec->k);
-           return (-1);
-	}
-	r = pRec->l/pRec->k;				   /* r=RotOrigin/BaseLength */
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of center is the average of the speeds of individual drives */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      x1 = d1 * ( 1.0 - r) + d2 * r;
-	      if ( x1 != 0.0 ) prcn = fabs( pRec->a2 / x1 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of angle is the sum of the speeds of each motor divided by base */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      x2 = FCDN*(d1+d2) / pRec->k;
-	      if ( x2 != 0.0 ) prcn = fabs( pRec->b2 / x2 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	x1 = fabs( d1 * (1.0 - r) + d2 * r );            /* x1=d1*(1-r)+d2*r */
-	x2 = fabs( FCDN*(d1 + d2) / pRec->k );           /* x2=(d2+d1)/BaseLength */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubDNDebug > 1) printf ("tsubDNStSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubDNStRef[] = {
-    {"tsubDNSt",      (REGISTRYFUNCTION)tsubDNSt},
-    {"tsubDNStSync",  (REGISTRYFUNCTION)tsubDNStSync},
-    {"tsubDNStMtr",   (REGISTRYFUNCTION)tsubDNStMtr},
-    {"tsubDNStDrv",   (REGISTRYFUNCTION)tsubDNStDrv},
-    {"tsubDNStAxs",   (REGISTRYFUNCTION)tsubDNStAxs},
-    {"tsubDNStSpeed", (REGISTRYFUNCTION)tsubDNStSpeed}
-};
-
-static void tsubDNStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubDNStRef,NELEMENTS(tsubDNStRef));
-}
-epicsExportRegistrar(tsubDNStFunc);
-
diff --git a/pmacApp/tsubSrc/tsubHS.c b/pmacApp/tsubSrc/tsubHS.c
deleted file mode 100644
index 5dc79a2..0000000
--- a/pmacApp/tsubSrc/tsubHS.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/* @(#) tsubHS.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubHS.c - Transformation Subroutines For Huber Slits */
-/*            This is for 2 individual blades - Stepanov */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-void msleep_ms( unsigned long milliseconds );
-
-volatile int tsubHSDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubHSDebug == (level)) ) { code } }
-
-
-/* ===========================================
- * tsubHSAp - Initialization
- */
-static long tsubHSAp (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubHSApSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubHSApSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubHSApMtr - Motors To Drives
- *	oa = x1
- *	ob = x2
- *	oa1 = d1
- *	ob1 = d2
- *	a = m1
- *	b = m2
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubHSApMtr (struct tsubRecord *pRec) {
-	double inv = 1. - 2. * pRec->i;		/* either 1 or -1 */
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-	}
-	pRec->oa =       0.5 * (pRec->ob1 + pRec->oa1);            /* x1=0.5*(d2+d1) */
-	pRec->ob =       inv * (pRec->ob1 - pRec->oa1);            /* x2=inv*(d2-d1) */
-	return (0);
-}
-
-/* ===========================================
- * tsubHSApDrv - Drives
- *	oa = x1
- *	ob = x2
- *	oa0 = m1
- *	ob0 = m2
- *	a = d1
- *	b = d2
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubHSApDrv (struct tsubRecord *pRec) {
-	double inv = 1. - 2. * pRec->i;		/* either 1 or -1 */
-
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                  /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                  /* m2=d2/scale2 */
-	}
-	pRec->oa = 0.5 * (pRec->b + pRec->a);                      /* x1=0.5*(d2+d1) */
-	pRec->ob = inv * (pRec->b - pRec->a);                      /* x2=inv*(d2-d1) */
- 	return (0);
-}
-
-/* ===========================================
- * tsubHSApAxs - Axes
- *	oa0 = m1
- *	oa1 = d1
- *	ob0 = m2
- *	ob1 = d2
- *	a = x1
- *	b = x2
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubHSApAxs (struct tsubRecord *pRec) {
-	double inv = 1. - 2. * pRec->i;		/* either 1 or -1 */
-
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) || (inv == 0.0) )
-	{
-		return (-1);
-	}
-
-	pRec->oa1 = pRec->a - 0.5 * pRec->b / inv;                 /* d1=x1-0.5*inv*x2 */
-	pRec->ob1 = pRec->a + 0.5 * pRec->b / inv;                 /* d2=x1+0.5*inv*x2 */
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;     /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                /* m2=d2/scale2 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubHSApSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oa1 = d1
- *	ob1 = d2
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *      i = Invert (0 -> +1   1 -> -1, implemented as 1-2i)
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubHSApSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2;
-	double inv = 1. - 2. * pRec->i;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubHSDebug > 1) printf ("tsubHSApSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ) {
-	   printf ("tsubHSApSpeed: exit on zero calc parameters\n");
-	   printf ("tsubHSApSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubHSApSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of center is the average of the speeds of individual blades */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-              d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-              prcn = fabs( pRec->a2 / ( (d1+d2)/2.0 ) );
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of slit size is the sum of the speeds of each blade */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-              prcn = fabs( pRec->b2 / (d1+d2) );
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	x1 = fabs(  0.5  * (d1 + d2) );                  /* x1=0.5*(d2+d1) */
-	x2 = fabs(  inv  * (d1 + d2) );                  /* x2=inv*(d2+d1) */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubHSDebug > 1) printf ("tsubHSApSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubHSApRef[] = {
-    {"tsubHSAp",      (REGISTRYFUNCTION)tsubHSAp},
-    {"tsubHSApSync",  (REGISTRYFUNCTION)tsubHSApSync},
-    {"tsubHSApMtr",   (REGISTRYFUNCTION)tsubHSApMtr},
-    {"tsubHSApDrv",   (REGISTRYFUNCTION)tsubHSApDrv},
-    {"tsubHSApAxs",   (REGISTRYFUNCTION)tsubHSApAxs},
-    {"tsubHSApSpeed", (REGISTRYFUNCTION)tsubHSApSpeed}
-};
-
-static void tsubHSApFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubHSApRef,NELEMENTS(tsubHSApRef));
-}
-epicsExportRegistrar(tsubHSApFunc);
-
diff --git a/pmacApp/tsubSrc/tsubInclude.dbd b/pmacApp/tsubSrc/tsubInclude.dbd
deleted file mode 100644
index 99d4461..0000000
--- a/pmacApp/tsubSrc/tsubInclude.dbd
+++ /dev/null
@@ -1,23 +0,0 @@
-#TSUB
-include "tsubRecord.dbd"
-
-registrar(tsubSeqFunc)
-registrar(tsubBDStFunc)
-registrar(tsubBD3StFunc)
-registrar(tsubCCDStFunc)
-registrar(tsubCSApFunc)
-registrar(tsubHSApFunc)
-registrar(tsubMDCsFunc)
-registrar(tsubMIStFunc)
-registrar(tsubMOEnFunc)
-registrar(tsubSHPsFunc)
-registrar(tsubTBStFunc)
-# registrar(tsubAPsFunc)
-registrar(tsubXPsFunc)
-# registrar(tsubXbmPsFunc)
-registrar(tsubXYPsFunc)
-registrar(tsubXYZPsFunc)
-registrar(tsubXYZfraPsFunc)
-registrar(tsubAcc65eFunc)
-registrar(tsubCollFunc)
-
diff --git a/pmacApp/tsubSrc/tsubLIBOBJS b/pmacApp/tsubSrc/tsubLIBOBJS
deleted file mode 100644
index 8945dab..0000000
--- a/pmacApp/tsubSrc/tsubLIBOBJS
+++ /dev/null
@@ -1,2 +0,0 @@
-# TSUB library
-TSUBLIBOBJS += $(PMAC_TSUB)/tsubLib
diff --git a/pmacApp/tsubSrc/tsubMD.c b/pmacApp/tsubSrc/tsubMD.c
deleted file mode 100644
index 4bc4ae3..0000000
--- a/pmacApp/tsubSrc/tsubMD.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/* @(#) tsubMD.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubMD.c - Transformation Subroutines for Modular Motors */
-/*            This is for 1-motor assemblies -- Stepanov    */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubMDDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubMDDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubMDCs - Assembly-X Initialization
- */
-static long tsubMDCs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubMDCsSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubMDCsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubMDCsMtr - Assembly-X Motors
- *	oa1 = d1
- *	a = m1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubMDCsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMDCsDrv - Assembly-X Drives
- *	oa0 = m1
- *	a = d1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubMDCsDrv (struct tsubRecord *pRec) {
-	if ( pRec->a1 == 0.0 )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMDCsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubMDCsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubMDDebug > 1) printf ("tsubMDCsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   printf ("tsubMDCsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubMDCsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-  	if (tsubMDDebug > 1) printf ("tsubMDCsSpeed: m1=%5.2f\n",m1);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubMDCsRef[] = {
-    {"tsubMDCs",      (REGISTRYFUNCTION)tsubMDCs},
-    {"tsubMDCsSync",  (REGISTRYFUNCTION)tsubMDCsSync},
-    {"tsubMDCsMtr",   (REGISTRYFUNCTION)tsubMDCsMtr},
-    {"tsubMDCsDrv",   (REGISTRYFUNCTION)tsubMDCsDrv},
-    {"tsubMDCsSpeed", (REGISTRYFUNCTION)tsubMDCsSpeed}
-};
-
-static void tsubMDCsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubMDCsRef,NELEMENTS(tsubMDCsRef));
-}
-epicsExportRegistrar(tsubMDCsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubMI.c b/pmacApp/tsubSrc/tsubMI.c
deleted file mode 100644
index 78062cb..0000000
--- a/pmacApp/tsubSrc/tsubMI.c
+++ /dev/null
@@ -1,291 +0,0 @@
-/* @(#) tsubMI.c 2.1 2004/05/31 -- speed propagation */
-
-/* tsubMI.c - Transformation Subroutines For Mirror -- ACCEL mirror support */
-/*            This is for 2-point mirror support - Stepanov */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubMIDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubMIDebug == (level)) ) { code } }
-
-/* if x1=mm, x2=mrad, base=m (BioCAT), then FCMI=1; if base=mm, then FCMI=1000. */
-double FCMI = 1.0;
-
-/* ===========================================
- * tsubMISt - Support Initialization
- */
-static long tsubMISt (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubMIStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubMIStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubMIStMtr - Support Motors
- *	oa = x1
- *	ob = x2
- *	oa1 = d1
- *	ob1 = d2
- *	a = m1
- *	b = m2
- *	k = BaseLength
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubMIStMtr (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;
-		pRec->ob1 = pRec->b * pRec->b1;
-	}
-	pRec->oa =      (pRec->ob1 + pRec->oa1) / 2.0;             /* x1=(d2+d1)/2         */
-	pRec->ob = FCMI*(pRec->ob1 - pRec->oa1) / pRec->k;         /* x2=(d2-d1)/BaseLength */
-	return (0);
-}
-
-/* ===========================================
- * tsubMIStDrv - Support Drives
- *	oa = x1
- *	ob = x2
- *	oa0 = m1
- *	ob0 = m2
- *	a = d1
- *	b = d2
- *	k = BaseLength
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubMIStDrv (struct tsubRecord *pRec) {
-	if ( (pRec->k == 0.0) ||
-	     (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                  /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                  /* m2=d2/scale2 */
-	}
-	pRec->oa =      (pRec->b + pRec->a) / 2.0;                 /* x1=(d2+d1)/2         */
-	pRec->ob = FCMI*(pRec->b - pRec->a) / pRec->k;             /* x2=(d2-d1)/BaseLength */
-	return (0);
-}
-
-/* ===========================================
- * tsubMIStAxs - Support Axes
- *	oa0 = m1
- *	oa1 = d1
- *	ob0 = m2
- *	ob1 = d2
- *	a = x1
- *	b = x2
- *	k = BaseLength
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubMIStAxs (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) || (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-
-	pRec->oa1 = pRec->a - pRec->b * pRec->k / (2.0*FCMI);      /* d1=x1-x2*BaseLength/2 */
-	pRec->ob1 = pRec->a + pRec->b * pRec->k / (2.0*FCMI);      /* d2=x1+x2*BaseLength/2 */
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;     /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                /* m2=d2/scale2 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMIStSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oa1 = d1
- *	ob1 = d2
- *	oa2 = x1
- *	ob2 = x2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	k = BaseLength
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubMIStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubMIDebug > 1) printf ("tsubMIStSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ||
-             pRec->k  == 0.0) {
-	   printf ("tsubMIStSpeed: exit on zero calc parameters\n");
-	   printf ("tsubMIStSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubMIStSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubMIStSpeed: BaseLength=%g\n",pRec->k);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of center is the average of the speeds of individual drives */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      x1 = (d1+d2)/2.0;
-	      if ( x1 != 0.0 ) prcn = fabs( pRec->a2 / x1 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of angle is the sum of the speeds of each motor divided by base */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      x2 = FCMI*(d1+d2)/pRec->k;
-	      if ( x2 != 0.0 ) prcn = fabs( pRec->b2 / x2 );
-	      else             prcn = 1.0;
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	x1 = fabs( (d1 + d2) / 2.0);                     /* x1=(d2+d1)/2 */
-	x2 = fabs( FCMI*(d1 + d2) / pRec->k );           /* x2=(d2+d1)/BaseLength */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubMIDebug > 1) printf ("tsubMIStSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubMIStRef[] = {
-    {"tsubMISt",      (REGISTRYFUNCTION)tsubMISt},
-    {"tsubMIStSync",  (REGISTRYFUNCTION)tsubMIStSync},
-    {"tsubMIStMtr",   (REGISTRYFUNCTION)tsubMIStMtr},
-    {"tsubMIStDrv",   (REGISTRYFUNCTION)tsubMIStDrv},
-    {"tsubMIStAxs",   (REGISTRYFUNCTION)tsubMIStAxs},
-    {"tsubMIStSpeed", (REGISTRYFUNCTION)tsubMIStSpeed}
-};
-
-static void tsubMIStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubMIStRef,NELEMENTS(tsubMIStRef));
-}
-epicsExportRegistrar(tsubMIStFunc);
-
-
diff --git a/pmacApp/tsubSrc/tsubMO_2mtr_cry2down.c b/pmacApp/tsubSrc/tsubMO_2mtr_cry2down.c
deleted file mode 100644
index 274e937..0000000
--- a/pmacApp/tsubSrc/tsubMO_2mtr_cry2down.c
+++ /dev/null
@@ -1,397 +0,0 @@
-/* @(#) tsubMO.c 2.0 2004/05/31 -- speed propagation */
-
-/* tsubMO.c - Transformation Subroutines For Monochromator Energy */
-/*            This is for Accel monochromator (no trolley X)      */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360 	     ((double) 1.7453292519943295769236907684886e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)      sin(DEG2RAD(deg))
-#define		COSD(deg)      cos(DEG2RAD(deg))
-
-volatile int tsubMODebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubMODebug == (level)) ) { code } }
-
-double coQB, siQB;                      /* added by Sergey 2001/04/20 */
-
-/*####################################################################*/
-/* =========================================== - Energy Initialization
- * tsubMOEn - Energy Initialization
- */
-static long tsubMOEn (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubMOEnSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubMOEnSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* =========================================== - Energy Motors
- * tsubMOEnMtr - Energy Motors
- *	oa = x1  (=E)      a = m1
- *	ob = x2  (=L)      b = m2
- *	oa1 = d1 (=QB)     g = ESinTheta
- *	ob1 = d2 (=t2)     h = EvLambda
- *	oa2 = m1_int       i = BeamOffset
- *	oa3 = m1_fra       a0 = d1:Offset
- *	                   a1 = d1:Scale
- *	                   b0 = d2:Offset
- *	                   b1 = d2:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *                         p = x1:ActPos (E:ActPos)
- *	                   nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;		      /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;		      /* d2=m2*scale2+offset2 */
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)              */
-		if (siQB != 0.0)     pRec->oa = pRec->g / siQB;               /* E=EsinTheta/sin(QB)  */
-		if (pRec->oa != 0.0) pRec->ob = pRec->h / pRec->oa;           /* L=EvLambda/E         */
-                pRec->oa2 = (long)(pRec->a);
-		pRec->oa3 = pRec->a - pRec->oa2;
-	}
-	else {				/* ----------Relative Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1         */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2         */
-		siQB = SIND(pRec->m);                                         /* sin(QB)              */
-		coQB = COSD(pRec->m);                                         /* cos(QB)              */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->oa1) /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		} else {
-			pRec->oa = 0.0;                                        /* dE=0.               */
-		}
-		if (pRec->p != 0.0) {                                          /* if E#0              */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                   /* dL=-EvLambda*dE/E^2 */
-				 / (pRec->p * pRec->p);
-		} else {
-			pRec->ob = 0.0;                                        /* dL=0.               */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Drives
- * tsubMOEnDrv - Energy Drives
- *	oa = x1  (=E)      a = d1   (=QB)
- *	ob = x2  (=L)      b = d2   (=t2)
- *	oa0 = m1           g = ESinTheta
- *	ob0 = m2           h = EvLambda
- *	oa2 = m1_int       i = BeamOffset
- *      oa3 = m1_fra       a0 = d1:Offset
- *                         a1 = d1:Scale
- *                         b0 = d2:Offset
- *	                   b1 = d2:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *                         p = x1:ActPos (E:ActPos)
- *	                   nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnDrv (struct tsubRecord *pRec) {
-	if ((pRec->a1 == 0.0) || (pRec->b1 == 0.0)) return (-1);
-
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;                  /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;                  /* m2=(d2-offset2)/scale2 */
-		siQB = SIND(pRec->a);                                         /* sin(QB)                */
-		if (siQB != 0.0)     pRec->oa = pRec->g / siQB;               /* E=EsinTheta/sin(QB)    */
-		if (pRec->oa != 0.0) pRec->ob = pRec->h / pRec->oa;           /* L=EvLambda/E           */
-                pRec->oa2 = (long)(pRec->oa0);
-		pRec->oa3 = pRec->oa0 - pRec->oa2;
-	}
-	else {				/* ----------Relative Motion--------- */
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1           */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2           */
-		siQB = SIND(pRec->m);                                         /* sin(QB)                */
-		coQB = COSD(pRec->m);                                         /* cos(QB)                */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->a)   /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		} else {
-			pRec->oa = 0.0;                                       /* dE=0.                  */
-		}
-		if (pRec->p != 0.0) {                                         /* if E#0                 */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                  /* dL=-EvLambda*dE/E^2    */
-			         / (pRec->p * pRec->p);
-		} else {
-			pRec->ob = 0.0;                                       /* dL=0.                  */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Axes
- * tsubMOEnAxs - Energy Axes
- *	oa0 = m1           a = x1
- *	oa1 = d1 (=QB)     b = x2
- *	ob0 = m2           f = TrolleyFlag
- *	ob1 = d2 (=t2)     g = ESinTheta
- *	oa2 = m1_int       h = EvLambda
- *	oa3 = m1_fra       i = BeamOffset
- *	                   a0 = d1:Offset
- *	                   a1 = d1:Scale
- *	                   b0 = d2:Offset
- *	                   b1 = d2:Scale
- *                         m = d1:ActPos     (QB:ActPos)
- *                         n = d2:RqsPos     (T2:RqsPos)
- *                         p = x1:ActPos     (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs (struct tsubRecord *pRec) {
-	if ((pRec->a1 == 0.0) || (pRec->b1 == 0.0)) return (-1);
-
-	if (pRec->nla == 0.0) { /* ------------Absolute Motion--------------- */
-		if (pRec->a != 0.0) {                                         /* if E#0                 */
-		        siQB = pRec->g / pRec->a;                             /* sin(QB)                */
-                        if      (siQB > 1.0)  pRec->oa1 = 90.0;
-                        else if (siQB < -1.0) pRec->oa1 = -90.0;
-			else                  pRec->oa1 = RAD2DEG (asin(siQB)); /* QB=asin(EsinTheta/E)   */
-		}
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;                /* m1=(d1-offset1)/scale1 */
-                pRec->oa2 = (long)(pRec->oa0);
-		pRec->oa3 = pRec->oa0 - pRec->oa2;
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)                */
-		coQB = COSD(pRec->oa1);                                       /* cos(QB)                */
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && coQB != 0.0) {                            /* if TrolleyFlag # 1     */
-		   	pRec->ob1 = pRec->i / (2.0 * coQB);                   /* d2=t2=BeamOffset/[2*cos(QB)] */
-		} else {
-		   	pRec->ob1 = pRec->n;		                     /* d2=d2 */
-		}
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;	             /* m2=(d2-offset2)/scale2       */
-	}
-	else {	/* --------------------Relative Motion----------------------- */
-		if (pRec->p != 0.0) {                                         /* if E#0                */
-			siQB = pRec->g / pRec->p;                             /* sin(QB)=(EsinTheta/E) */
-			if      (siQB > 1.0)  {siQB = 1.0;  coQB = 0.0;}
-			else if (siQB < -1.0) {siQB = -1.0; coQB = 0.0;}
-			else                  {coQB = sqrt( 1.0 - siQB*siQB );}
-			if (coQB != 0.0) {
-				pRec->oa1 = -1.0 * pRec->g * RAD2DEG(pRec->a) /* d1=d(QB)=-EsinTheta*dE/[E^2*cos(QB)]    */
-					  / ( pRec->p * pRec->p * coQB );
-			}
-			else {
-				pRec->oa1 = 0.0;                              /* d1=d(QB)=0.         */
-			}
-		} else {                                                      /* if E=0              */
-			siQB = SIND(pRec->m);                                 /* take QB=QB_actual   */
-			coQB = COSD(pRec->m);                                 /* take QB=QB_actual   */
-		  	pRec->oa1 = 0.0;                                      /* d1=d(QB)=0.         */
-		}
-		pRec->oa0 = pRec->oa1 / pRec->a1;                             /* m1 = d1 / d1:Scale  */
-
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && coQB != 0.0) {                            /* if TrolleyFlag # 0  */
-			pRec->ob1 = pRec->i * siQB * DEG2RAD(pRec->oa1)       /* d2=d(t2)=BeamOffset*sin(QB)*dQ  */
-				  / (2.0 * coQB * coQB);                      /*         /(2*cos^2(QB))          */
-		} else {
-			pRec->ob1 = 0.0;                                      /* d2=d(t2)=0.         */
-		}
-		pRec->ob0 = pRec->ob1 / pRec->b1;                             /* m2=d2/scale2        */
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Energy To Lambda
- * tsubMOEnAxs1 - Axes Energy To Lambda
- *	oa = L               h = EvLambda
- *	a = E                p = x1:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs1 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* L=EvLambda/E        */
-	} else {			/* ---------Relative Motion---------- */
-		if (pRec->p != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dL=-EvLambda*dE/E^2 */
-					     / (pRec->p * pRec->p);
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Lamdba To Energy
- * tsubMOEnAx2 - Axes Lamdba To Energy
- *	oa = E               h = EvLambda
- *	a = L                q = x2:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs2 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* E=EvLambda/L        */
-	} else {			/* ----------Relative Motion--------- */
-		if (pRec->q != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dE=-EvLambda*dL/L^2 */
-					     / (pRec->q * pRec->q);
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMOEnSpeed - Speed propagation spreadsheet
- *	oa0 = m1   (=rotary)
- *	ob0 = m2   (=translation_2)
- *	oa1 = d1   (=QB)
- *	ob1 = d2   (=t2)
- *	oa2 = x1   (=E)
- *	ob2 = x2   (=L)
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	g = ESinTheta
- *	h = EvLambda
- *      m = d1:ActPos (QB:ActPos)
- *      p = x1:ActPos (E:ActPos)
- *      nla = Index of input (m1=1, m2=2, d1=11, d2=12, x1=21, x2=22)
- */
-static long tsubMOEnSpeed (struct tsubRecord *	pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                      /* sdis=1 */
-
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: called with n=%f \n",pRec->nla);
-
-	siQB = SIND(pRec->m);                              /* sin(QB) */
-	coQB = COSD(pRec->m);                              /* cos(QB) */
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ||
-             pRec->g  == 0.0 || pRec->h  == 0.0 ||
-             siQB     == 0.0 || coQB     == 0.0 ) {
-	   printf ("tsubMOEnSpeed: exit on zero calc parameters\n");
-	   printf ("tsubMOEnSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubMOEnSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubMOEnSpeed: ESinTheta=%g EvLambda=%g\n",pRec->g,pRec->h);
-	   printf ("tsubMOEnSpeed: sin(QB)=%g cos(QB)=%g\n",siQB,coQB);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0) {    /* --------------------- m1 speed changed */
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0) {    /* --------------------- m2 speed changed */
-	   if (pRec->b0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) {    /* --------------------- d1 speed changed */
-	   if (pRec->a1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) {    /* --------------------- d2 speed changed */
-	   if (pRec->b1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 21.0) {    /* --------------------- x1 speed changed */
-	   if (pRec->a2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-             prcn = fabs( pRec->a2 / x1 );
-	   }
-	}
-	else if (pRec->nla == 22.0) {    /* --------------------- x2 speed changed */
-	   if (pRec->b2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-/* maximum speed: max(x2)=max(dL/dt)=-(EvLambda/E^2)*max(dE/dt) */
-	     x2 = -(pRec->h / (pRec->p*pRec->p)) * x1;
-             prcn = fabs( pRec->b2 / x2 );
-	   }
-	}
-	else {
-	   return (-1);
-	}
-
-	if (prcn < 0.0 || prcn > 1.0) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-/* If we are scanning trolley, we should not reduce the speed of rotary,
- * since the rotary is generally slower than trolley and it may limit
- * the scan speed of trolley */
-	if ( pRec->nla == 2.0 ||
-             pRec->nla == 12.0 ) m1 = pRec->a;                    /* m1=m1_max */
-	else                     m1 = prcn * pRec->a;             /* m1=prcn*m1_max */
-	m1 = prcn * pRec->a;                                      /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                      /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );                     /* d1=dQ/dt=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );                     /* d2=dt2/dt=m2*scale2 */
-	x1 = fabs( pRec->g * DEG2RAD(d1) * coQB / (siQB*siQB) );  /* x1=dE/dt=-(EsinTheta*cos(QB)/sin^2(QB))*dQ/dt */
-	x2 = fabs( pRec->h * x1 / (pRec->p*pRec->p) );            /* x2=dL/dt=-(EvLambda/E^2)*dE/dt */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubMOEnRef[] = {
-    {"tsubMOEn",      (REGISTRYFUNCTION)tsubMOEn},
-    {"tsubMOEnSync",  (REGISTRYFUNCTION)tsubMOEnSync},
-    {"tsubMOEnMtr",   (REGISTRYFUNCTION)tsubMOEnMtr},
-    {"tsubMOEnDrv",   (REGISTRYFUNCTION)tsubMOEnDrv},
-    {"tsubMOEnAxs",   (REGISTRYFUNCTION)tsubMOEnAxs},
-    {"tsubMOEnAxs1",  (REGISTRYFUNCTION)tsubMOEnAxs1},
-    {"tsubMOEnAxs2",  (REGISTRYFUNCTION)tsubMOEnAxs2},
-    {"tsubMOEnSpeed", (REGISTRYFUNCTION)tsubMOEnSpeed}
-};
-
-static void tsubMOEnFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubMOEnRef,NELEMENTS(tsubMOEnRef));
-}
-epicsExportRegistrar(tsubMOEnFunc);
-
diff --git a/pmacApp/tsubSrc/tsubMO_3mtr_cry2down.c b/pmacApp/tsubSrc/tsubMO_3mtr_cry2down.c
deleted file mode 100644
index de78bf1..0000000
--- a/pmacApp/tsubSrc/tsubMO_3mtr_cry2down.c
+++ /dev/null
@@ -1,460 +0,0 @@
-/* @(#) tsubMObm.c 2.0 2005/12/22 -- speed propagation */
-
-/* tsubMObm.c - Transformation Subroutines For Monochromator Energy       */
-/*              This is for Accel BM monochromator (with trolley X and Y) */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360 ((double) 1.7453292519943295769236907684886e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)	sin(DEG2RAD(deg))
-#define		COSD(deg)	cos(DEG2RAD(deg))
-
-volatile int tsubMODebug = 0;
-#define	TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubMODebug == (level)) ) { code } }
-
-double coQB, siQB;                      /* added by Sergey 2001/04/20 */
-
-/*####################################################################*/
-/* =========================================== - Energy Initialization
- * tsubMOEn - Energy Initialization
- */
-static long tsubMOEn (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubMOEnSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m3:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubMOEnSync (struct tsubRecord *	pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* =========================================== - Energy Motors
- * tsubMOEnMtr - Energy Motors
- *	oa = x1  (=E)      a = m1
- *	ob = x2  (=L)      b = m2
- *	oa1 = d1 (=QB)     c = m3
- *	ob1 = d2 (=t2)     g = ESinTheta
- *	oc1 = d3 (=tx)     h = EvLambda
- *	oa2 = m1_int       i = BeamOffset
- *	oa3 = m1_fra       a0 = d1:Offset
- *	                   a1 = d1:Scale
- *	                   a2 = mirrAng
- *                         b0 = d2:Offset
- *                         b1 = d2:Scale
- *	                   c0 = d3:Offset
- *                         c1 = d3:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *	                   p = x1:ActPos (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0 + 2.0*pRec->a2;     /* d1=m1*scale1+offset1+2*mirrAng */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;		      /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;		      /* d3=m3*scale3+offset3 */
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)              */
-		if (siQB != 0.0)     pRec->oa = pRec->g / siQB;               /* E=EsinTheta/sin(QB)  */
-		if (pRec->oa != 0.0) pRec->ob = pRec->h / pRec->oa;           /* L=EvLambda/E         */
-                pRec->oa2 = (long)(pRec->a);                                  /* m1_int */
-		pRec->oa3 = pRec->a - pRec->oa2;                              /* m1_fra */
-	}
-	else {				/* ----------Relative Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1         */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2         */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3         */
-		siQB = SIND(pRec->m);                                         /* sin(QB)              */
-		coQB = COSD(pRec->m);                                         /* cos(QB)              */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->oa1) /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		}
-		else {
-			pRec->oa = 0.0;                                        /* dE=0.               */
-		}
-		if (pRec->p != 0.0) {                                          /* if E#0              */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                   /* dL=-EvLambda*dE/E^2 */
-				 / (pRec->p * pRec->p);
-		}
-		else {
-			pRec->ob = 0.0;                                        /* dL=0.               */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Drives
- * tsubMOEnDrv - Energy Drives
- *	oa = x1  (=E)      a = d1   (=QB)
- *	ob = x2  (=L)      b = d2   (=t2)
- *	oa0 = m1           c = d3   (=tx)
- *	ob0 = m2           g = ESinTheta
- *	oc0 = m3           h = EvLambda
- *      oa2 = m1_int       i = BeamOffset
- *      oa3 = m1_fra       a0 = d1:Offset
- *                         a1 = d1:Scale
- *	                   a2 = mirrAng
- *	                   b0 = d2:Offset
- *                         b1 = d2:Scale
- *	                   c0 = d3:Offset
- *                         c1 = d3:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *	                   p = x1:ActPos (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnDrv (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )  return (-1);
-	if (pRec->nla == 0.0) {		/* ---------Absolute Motion---------- */
-		pRec->oa0 = (pRec->a - pRec->a0 - 2.0*pRec->a2) / pRec->a1;   /* m1=(d1-offset1-2*mirrAng)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;                  /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;                  /* m3=(d3-offset3)/scale3 */
-		siQB = SIND(pRec->a);                                         /* sin(QB)                */
-		if (siQB != 0.0)     pRec->oa = pRec->g / siQB;               /* E=EsinTheta/sin(QB)    */
-		if (pRec->oa != 0.0) pRec->ob = pRec->h / pRec->oa;           /* L=EvLambda/E           */
-                pRec->oa2 = (long)(pRec->oa0);                                /* m1_int */
-		pRec->oa3 = pRec->oa0 - pRec->oa2;                            /* m1_fra */
-	}
-	else {				/* ---------Relative Motion---------- */
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1           */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2           */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3           */
-		siQB = SIND(pRec->m);                                         /* sin(QB)                */
-		coQB = COSD(pRec->m);                                         /* cos(QB)                */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->a)   /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		} else {
-			pRec->oa = 0.0;                                       /* dE=0.                  */
-		}
-		if (pRec->p != 0.0) {                                         /* if E#0                 */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                  /* dL=-EvLambda*dE/E^2    */
-			         / (pRec->p * pRec->p);
-		} else {
-			pRec->ob = 0.0;                                       /* dL=0.                  */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Axes
- * tsubMOEnAxs - Energy Axes
- *	oa0 = m1           a = x1
- *	oa1 = d1 (=QB)     b = x2
- *	ob0 = m2           f = TrolleyFlag
- *	ob1 = d2 (=t2)     g = ESinTheta
- *	oc0 = m3           h = EvLambda
- *	oc1 = d3 (=tx)     i = BeamOffset
- *	oa2 = m1_int       a0 = d1:Offset
- *	oa3 = m1_fra       a1 = d1:Scale
- *	                   a2 = mirrAng
- *	                   b0 = d2:Offset
- *	                   b1 = d2:Scale
- *	                   c0 = d3:Offset
- *	                   c1 = d3:Scale
- *                         m = d1:ActPos     (QB:ActPos)
- *                         n = d2:RqsPos     (T2:RqsPos)
- *                         o = d3:RqsPos     (Tx:RqsPos)
- *                         p = x1:ActPos     (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-             (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) ) return (-1);
-
-	if (pRec->nla == 0.0) { /* ------------Absolute Motion--------------- */
-		if (pRec->a != 0.0) {                                         /* if E#0                 */
-		        siQB = pRec->g / pRec->a;                             /* sin(QB)                */
-                        if      (siQB > 1.0)  pRec->oa1 = 90.0;
-                        else if (siQB < -1.0) pRec->oa1 = -90.0;
-			else                  pRec->oa1 = RAD2DEG (asin(siQB)); /* QB=asin(EsinTheta/E) */
-		}
-		pRec->oa0 = (pRec->oa1 - pRec->a0 - 2.0*pRec->a2) / pRec->a1; /* m1=(d1-offset1-2*mirrAng)/scale1 */
-                pRec->oa2 = (long)(pRec->oa0);                                /* m1_int */
-		pRec->oa3 = pRec->oa0 - pRec->oa2;                            /* m1_fra */
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)                */
-		coQB = COSD(pRec->oa1);                                       /* cos(QB)                */
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && pRec->f != 3 && coQB != 0.0) {            /* if TrolleyFlag # 0 or 3*/
-		   	pRec->ob1 = pRec->i / (2.0 * coQB);                   /* d2=t2=BeamOffset/[2*cos(QB)]  */
-		} else {
-		   	pRec->ob1 = pRec->n;                                  /* d2=d2  */
-		}
-                /* Trolley-X (Crystal2 Tx): */
-		if (pRec->f != 0 && pRec->f != 2 && siQB != 0.0) {            /* if TrolleyFlag # 0 or 2*/
-		   	pRec->oc1 = pRec->i / (-2.0 * siQB);                  /* d3=tx=BeamOffset/[-2*sin(QB)] */
-		} else {
-		   	pRec->oc1 = pRec->o;                                  /* d3=d3  */
-		}
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;                /* m2=(d2-offset2)/scale2        */
-		pRec->oc0 = (pRec->oc1 - pRec->c0) / pRec->c1;                /* m3=(d3-offset3)/scale3        */
-	}
-	else {	/* --------------------Relative Motion----------------------- */
-		if (pRec->p != 0.0) {                                         /* if E#0                */
-			siQB = pRec->g / pRec->p;                             /* sin(QB)=(EsinTheta/E) */
-			if      (siQB > 1.0)  {siQB = 1.0;  coQB = 0.0;}
-			else if (siQB < -1.0) {siQB = -1.0; coQB = 0.0;}
-			else                  {coQB = sqrt(1.0 - siQB*siQB);}
-			if (coQB != 0.0) {
-				pRec->oa1 = -1.0 * pRec->g * RAD2DEG(pRec->a) /* d1=d(QB)=-EsinTheta*dE/[E^2*cos(QB)]    */
-					  / ( pRec->p * pRec->p * coQB );
-			}
-			else {
-				pRec->oa1 = 0.0;                              /* d1=d(QB)=0.         */
-			}
-		} else {                                                      /* if E=0              */
-			siQB = SIND(pRec->m);                                 /* take QB=QB_actual   */
-			coQB = COSD(pRec->m);                                 /* take QB=QB_actual   */
-		  	pRec->oa1 = 0.0;                                      /* d1=d(QB)=0.         */
-		}
-		pRec->oa0 = pRec->oa1 / pRec->a1;                             /* m1 = d1 / d1:Scale  */
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && pRec->f != 3 && coQB != 0.0) {            /* if TrolleyFlag # 0 or 3*/
-			pRec->ob1 = pRec->i * siQB * DEG2RAD(pRec->oa1)       /* d2=d(t2)=BeamOffset*sin(QB)*dQ  */
-				  / (2.0 * coQB * coQB);                      /*         /(2*cos^2(QB))          */
-		} else {
-			pRec->ob1 = 0.0;                                      /* d2=d(t2)=0.         */
-		}
-
-                /* Trolley-X (Crystal2 Tx): */
-		if (pRec->f != 0 && pRec->f != 2 && siQB != 0.0) {            /* if TrolleyFlag # 0 or 2*/
-			pRec->oc1 = pRec->i * coQB * DEG2RAD(pRec->oa1)       /* d3=d(tx)=BeamOffset*cos(QB)*dQ  */
-				  / (2.0 * siQB * siQB);                      /*         /(2*sin^2(QB))                  */
-		} else {
-			pRec->oc1 = 0.0;                                      /* d3=d(tx)=0.         */
-		}
-		pRec->ob0 = pRec->ob1 / pRec->b1;                             /* m2=d2/scale2        */
-		pRec->oc0 = pRec->oc1 / pRec->c1;                             /* m3=d3/scale3        */
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Energy To Lambda
- * tsubMOEnAxs1 - Axes Energy To Lambda
- *	oa = L               h = EvLambda
- *	a = E                p = x1:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs1 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* L=EvLambda/E        */
-	} else {			/* ----------Relative Motion--------- */
-		if (pRec->p != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dL=-EvLambda*dE/E^2 */
-					     / (pRec->p * pRec->p);
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Lamdba To Energy
- * tsubMOEnAx2 - Axes Lamdba To Energy
- *	oa = E               h = EvLambda
- *	a = L                q = x2:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs2 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* E=EvLambda/L        */
-	} else {			/* ----------Relative Motion--------- */
-		if (pRec->q != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dE=-EvLambda*dL/L^2 */
-					     / (pRec->q * pRec->q);
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMOEnSpeed - Speed propagation spreadsheet
- *	oa0 = m1   (=rotary)
- *	ob0 = m2   (=translation_2)
- *	oc0 = m3   (=translation_x)
- *	oa1 = d1   (=QB)
- *	ob1 = d2   (=t2)
- *	oc1 = d3   (=tx)
- *	oa2 = x1   (=E)
- *	ob2 = x2   (=L)
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *	g = ESinTheta
- *	h = EvLambda
- *      m = d1:ActPos (QB:ActPos)
- *      p = x1:ActPos (E:ActPos)
- *      nla = Index of input (m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubMOEnSpeed (struct tsubRecord *	pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                      /* sdis=1 */
-
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: called with n=%f \n",pRec->nla);
-
-	siQB = SIND(pRec->m);                              /* sin(QB) */
-	coQB = COSD(pRec->m);                              /* cos(QB) */
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ||
-             pRec->g  == 0.0 || pRec->h  == 0.0 ||
-             siQB     == 0.0 || coQB     == 0.0 ) {
-	   printf ("tsubMOEnSpeed: exit on zero calc parameters\n");
-	   printf ("tsubMOEnSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubMOEnSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubMOEnSpeed: max3=%5.2f sca3=%g\n",pRec->c,pRec->c3);
-	   printf ("tsubMOEnSpeed: ESinTheta=%g EvLambda=%g\n",pRec->g,pRec->h);
-	   printf ("tsubMOEnSpeed: sin(QB)=%g cos(QB)=%g\n",siQB,coQB);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0) { /* ------------------------ m1 speed changed */
-	   if (pRec->a0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);           /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0) { /* ------------------------ m2 speed changed */
-	   if (pRec->b0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);           /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0) { /* ------------------------ m3 speed changed */
-	   if (pRec->c0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);           /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) { /* ------------------------ d1 speed changed */
-	   if (pRec->a1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) { /* ------------------------ d2 speed changed */
-	   if (pRec->b1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) { /* ------------------------ d3 speed changed */
-	   if (pRec->c1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->c1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) { /* ------------------------ x1 speed changed */
-	   if (pRec->a2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-             prcn = fabs( pRec->a2 / x1 );
-	   }
-	}
-	else if (pRec->nla == 22.0) { /* ------------------------ x2 speed changed */
-	   if (pRec->b2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-/* maximum speed: max(x2)=max(dL/dt)=-(EvLambda/E^2)*max(dE/dt) */
-	     x2 = -(pRec->h / (pRec->p*pRec->p)) * x1;
-             prcn = fabs( pRec->b2 / x2 );
-	   }
-	}
-	else {
-	   return (-1);
-	}
-
-	if (prcn < 0.0 || prcn > 1.0) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-/* If we are scanning trolley, we should not reduce the speed of rotary,
- * since the rotary is generally slower than trolley and it may limit
- * the scan speed of trolley */
-	if ( pRec->nla == 2.0 ||
-             pRec->nla == 3.0 ||
-             pRec->nla == 12.0 ||
-             pRec->nla == 13.0 ) m1 = pRec->a;                    /* m1=m1_max */
-	else                     m1 = prcn * pRec->a;             /* m1=prcn*m1_max */
-
-	m1 = prcn * pRec->a;                                      /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                      /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                      /* m3=prcn*m3_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );                     /* d1=dQ/dt=m1*scale1  */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );                     /* d2=dt2/dt=m2*scale2 */
-	d3 = fabs( 1000.0 *  m3 * pRec->c3 );                     /* d3=dx2/dt=m3*scale3 */
-	x1 = fabs( pRec->g * DEG2RAD(d1) * coQB / (siQB*siQB) );  /* x1=dE/dt=-(EsinTheta*cos(QB)/sin^2(QB))*dQ/dt */
-	x2 = fabs( pRec->h * x1 / (pRec->p*pRec->p) );            /* x2=dL/dt=-(EvLambda/E^2)*dE/dt */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oc1 = d3;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: m1=%5.2f  m2=%5.2f  m3=%5.2f\n",m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubMOEnRef[] = {
-    {"tsubMOEn",      (REGISTRYFUNCTION)tsubMOEn},
-    {"tsubMOEnSync",  (REGISTRYFUNCTION)tsubMOEnSync},
-    {"tsubMOEnMtr",   (REGISTRYFUNCTION)tsubMOEnMtr},
-    {"tsubMOEnDrv",   (REGISTRYFUNCTION)tsubMOEnDrv},
-    {"tsubMOEnAxs",   (REGISTRYFUNCTION)tsubMOEnAxs},
-    {"tsubMOEnAxs1",  (REGISTRYFUNCTION)tsubMOEnAxs1},
-    {"tsubMOEnAxs2",  (REGISTRYFUNCTION)tsubMOEnAxs2},
-    {"tsubMOEnSpeed", (REGISTRYFUNCTION)tsubMOEnSpeed}
-};
-
-static void tsubMOEnFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubMOEnRef,NELEMENTS(tsubMOEnRef));
-}
-epicsExportRegistrar(tsubMOEnFunc);
-
diff --git a/pmacApp/tsubSrc/tsubMO_3mtr_cry2up.c b/pmacApp/tsubSrc/tsubMO_3mtr_cry2up.c
deleted file mode 100644
index 738733c..0000000
--- a/pmacApp/tsubSrc/tsubMO_3mtr_cry2up.c
+++ /dev/null
@@ -1,463 +0,0 @@
-/* @(#) tsubMObm.c 2.0 2005/12/22 -- speed propagation */
-
-/* tsubMObm.c - Transformation Subroutines For Monochromator Energy       */
-/*              This is for Accel BM monochromator (with trolley X and Y) */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define   	PI2360 	     ((double) 1.7453292519943295769236907684886e-2)	/* = 2*pi/360 */
-#define   	DEG2RAD(deg) ((deg) * PI2360)
-#define   	RAD2DEG(rad) ((rad) / PI2360)
-#define		SIND(deg)    sin(DEG2RAD(deg))
-#define		COSD(deg)    cos(DEG2RAD(deg))
-#define  	MIRRORSIGN   ((double) -1.)					/* +1: mirror reflects down, -1: mirror reflects up */
-
-volatile int tsubMODebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubMODebug == (level)) ) { code } }
-
-double coQB, siQB;                      /* added by Sergey 2001/04/20 */
-
-/*####################################################################*/
-/* =========================================== - Energy Initialization
- * tsubMOEn - Energy Initialization
- */
-static long tsubMOEn (struct tsubRecord *pRec) {
- 	return (0);
-}
-
-
-/* ===========================================
- * tsubMOEnSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m3:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubMOEnSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* =========================================== - Energy Motors
- * tsubMOEnMtr - Energy Motors
- *	oa = x1  (=E)      a = m1
- *	ob = x2  (=L)      b = m2
- *	oa1 = d1 (=QB)     c = m3
- *	ob1 = d2 (=t2)     g = ESinTheta
- *	oc1 = d3 (=tx)     h = EvLambda
- *	oa2 = m1_int       i = BeamOffset
- *	oa3 = m1_fra       a0 = d1:Offset
- *	                   a1 = d1:Scale
- *	                   a2 = mirrAng
- *                         b0 = d2:Offset
- *                         b1 = d2:Scale
- *	                   c0 = d3:Offset
- *                         c1 = d3:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *	                   p = x1:ActPos (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0 + 2.0*MIRRORSIGN*pRec->a2;     /* d1=m1*scale1+offset1+2*mirrAng */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;		      /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;		      /* d3=m3*scale3+offset3 */
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)              */
-		if (siQB != 0.0)     pRec->oa = pRec->g / siQB;               /* E=EsinTheta/sin(QB)  */
-		if (pRec->oa != 0.0) pRec->ob = pRec->h / pRec->oa;           /* L=EvLambda/E         */
-                pRec->oa2 = (long)(pRec->a);                                  /* m1_int */
-		pRec->oa3 = pRec->a - pRec->oa2;                              /* m1_fra */
-	}
-	else {				/* ----------Relative Motion--------- */
-		pRec->oa1 = pRec->a * pRec->a1;                               /* d1=m1*scale1         */
-		pRec->ob1 = pRec->b * pRec->b1;                               /* d2=m2*scale2         */
-		pRec->oc1 = pRec->c * pRec->c1;                               /* d3=m3*scale3         */
-		siQB = SIND(pRec->m);                                         /* sin(QB)              */
-		coQB = COSD(pRec->m);                                         /* cos(QB)              */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->oa1) /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		} else {
-			pRec->oa = 0.0;                                        /* dE=0.               */
-		}
-		if (pRec->p != 0.0) {                                          /* if E#0              */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                   /* dL=-EvLambda*dE/E^2 */
-				 / (pRec->p * pRec->p);
-		} else {
-			pRec->ob = 0.0;                                        /* dL=0.               */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Drives
- * tsubMOEnDrv - Energy Drives
- *	oa = x1  (=E)      a = d1   (=QB)
- *	ob = x2  (=L)      b = d2   (=t2)
- *	oa0 = m1           c = d3   (=tx)
- *	ob0 = m2           g = ESinTheta
- *	oc0 = m3           h = EvLambda
- *      oa2 = m1_int       i = BeamOffset
- *      oa3 = m1_fra       a0 = d1:Offset
- *                         a1 = d1:Scale
- *	                   a2 = mirrAng
- *	                   b0 = d2:Offset
- *                         b1 = d2:Scale
- *	                   c0 = d3:Offset
- *                         c1 = d3:Scale
- *                         m = d1:ActPos (QB:ActPos)
- *	                   p = x1:ActPos (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnDrv (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )  return (-1);
-
-	if (pRec->nla == 0.0) {		/* ----------Absolute Motion--------- */
-		pRec->oa0 = (pRec->a - pRec->a0 - 2.0*MIRRORSIGN*pRec->a2) / pRec->a1;   /* m1=(d1-offset1-2*mirrAng)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;                  /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;                  /* m3=(d3-offset3)/scale3 */
-		siQB = SIND(pRec->a);                                         /* sin(QB)                */
-		if (siQB != 0.0) {
-			pRec->oa = pRec->g / siQB;                            /* E=EsinTheta/sin(QB)    */
-		}
-		if (pRec->oa != 0.0) {
-			pRec->ob = pRec->h / pRec->oa;                        /* L=EvLambda/E           */
-		}
-                pRec->oa2 = (long)(pRec->oa0);                                /* m1_int */
-		pRec->oa3 = pRec->oa0 - pRec->oa2;                            /* m1_fra */
-	}
-	else {				/* ----------Relative Motion--------- */
-		pRec->oa0 = (pRec->a) / pRec->a1;                             /* m1=d1/scale1           */
-		pRec->ob0 = (pRec->b) / pRec->b1;                             /* m2=d2/scale2           */
-		pRec->oc0 = (pRec->c) / pRec->c1;                             /* m3=d3/scale3           */
-		siQB = SIND(pRec->m);                                         /* sin(QB)                */
-		coQB = COSD(pRec->m);                                         /* cos(QB)                */
-		if (siQB != 0.0) {
-			pRec->oa = -1.0 * pRec->g * coQB * DEG2RAD(pRec->a)   /* dE=-EsinTheta*cos(QB)*dQ/sin^2(QB) */
-			         / (siQB*siQB);
-		} else {
-			pRec->oa = 0.0;                                       /* dE=0.                  */
-		}
-		if (pRec->p != 0.0) {                                         /* if E#0                 */
-			pRec->ob = -1.0 * pRec->h * pRec->oa                  /* dL=-EvLambda*dE/E^2    */
-			         / (pRec->p * pRec->p);
-		} else {
-			pRec->ob = 0.0;                                       /* dL=0.                  */
-		}
-	}
-	return (0);
-}
-
-/* =========================================== - Energy Axes
- * tsubMOEnAxs - Energy Axes
- *	oa0 = m1           a = x1
- *	oa1 = d1 (=QB)     b = x2
- *	ob0 = m2           f = TrolleyFlag
- *	ob1 = d2 (=t2)     g = ESinTheta
- *	oc0 = m3           h = EvLambda
- *	oc1 = d3 (=tx)     i = BeamOffset
- *	oa2 = m1_int       a0 = d1:Offset
- *	oa3 = m1_fra       a1 = d1:Scale
- *	                   a2 = mirrAng
- *	                   b0 = d2:Offset
- *	                   b1 = d2:Scale
- *	                   c0 = d3:Offset
- *	                   c1 = d3:Scale
- *                         m = d1:ActPos     (QB:ActPos)
- *                         n = d2:RqsPos     (T2:RqsPos)
- *                         o = d3:RqsPos     (Tx:RqsPos)
- *                         p = x1:ActPos     (E:ActPos)
- *                         nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-             (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )   return (-1);
-
-	if (pRec->nla == 0.0) { /* ------------Absolute Motion--------------- */
-		if (pRec->a != 0.0) {                                         /* if E#0                 */
-		        siQB = pRec->g / pRec->a;                             /* sin(QB)                */
-                        if      (siQB > 1.0)  pRec->oa1 = 90.0;
-                        else if (siQB < -1.0) pRec->oa1 = -90.0;
-			else                  pRec->oa1 = RAD2DEG (asin(siQB)); /* QB=asin(EsinTheta/E) */
-		}
-		pRec->oa0 = (pRec->oa1 - pRec->a0 - 2.0*MIRRORSIGN*pRec->a2) / pRec->a1; /* m1=(d1-offset1-2*mirrAng)/scale1 */
-                pRec->oa2 = (long)(pRec->oa0);                                /* m1_int */
-		pRec->oa3 = pRec->oa0 - pRec->oa2;                            /* m1_fra */
-		siQB = SIND(pRec->oa1);                                       /* sin(QB)                */
-		coQB = COSD(pRec->oa1);                                       /* cos(QB)                */
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && pRec->f != 3 && coQB != 0.0) {            /* if TrolleyFlag # 0 or 3*/
-		   	pRec->ob1 = pRec->i / (2.0 * coQB);                   /* d2=t2=BeamOffset/[2*cos(QB)]  */
-		} else {
-		   	pRec->ob1 = pRec->n;                                  /* d2=d2  */
-		}
-                /* Trolley-X (Crystal2 Tx): */
-		if (pRec->f != 0 && pRec->f != 2 && siQB != 0.0) {            /* if TrolleyFlag # 0 or 2*/
-		   	pRec->oc1 = pRec->i / (2.0 * siQB);                   /* d3=tx=BeamOffset/[2*sin(QB)] */
-		} else {
-		   	pRec->oc1 = pRec->o;                                  /* d3=d3  */
-		}
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;                /* m2=(d2-offset2)/scale2        */
-		pRec->oc0 = (pRec->oc1 - pRec->c0) / pRec->c1;                /* m3=(d3-offset3)/scale3        */
-	}
-	else {	/* --------------------Relative Motion----------------------- */
-		if (pRec->p != 0.0) {                                         /* if E#0                */
-			siQB = pRec->g / pRec->p;                             /* sin(QB)=(EsinTheta/E) */
-			if      (siQB > 1.0)  {siQB = 1.0;  coQB = 0.0;}
-			else if (siQB < -1.0) {siQB = -1.0; coQB = 0.0;}
-			else                  {coQB = sqrt(1.0 - siQB*siQB);}
-			if (coQB != 0.0) {
-				pRec->oa1 = -1.0 * pRec->g * RAD2DEG(pRec->a) /* d1=d(QB)=-EsinTheta*dE/[E^2*cos(QB)]    */
-					  / ( pRec->p * pRec->p * coQB );
-			} else {
-				pRec->oa1 = 0.0;                              /* d1=d(QB)=0.         */
-			}
-		}
-		else {                                                        /* if E=0              */
-			siQB = SIND(pRec->m);                                 /* take QB=QB_actual   */
-			coQB = COSD(pRec->m);                                 /* take QB=QB_actual   */
-		  	pRec->oa1 = 0.0;                                      /* d1=d(QB)=0.         */
-		}
-		pRec->oa0 = pRec->oa1 / pRec->a1;                             /* m1 = d1 / d1:Scale  */
-
-                /* Trolley-Y (Crystal2 T2): */
-		if (pRec->f != 0 && pRec->f != 3 && coQB != 0.0) {            /* if TrolleyFlag # 0 or 3*/
-			pRec->ob1 = pRec->i * siQB * DEG2RAD(pRec->oa1)       /* d2=d(t2)=BeamOffset*sin(QB)*dQ  */
-				  / (2.0 * coQB * coQB);                      /*         /(2*cos^2(QB))          */
-		} else {
-			pRec->ob1 = 0.0;                                      /* d2=d(t2)=0.         */
-		}
-
-                /* Trolley-X (Crystal2 Tx): */
-		if (pRec->f != 0 && pRec->f != 2 && siQB != 0.0) {            /* if TrolleyFlag # 0 or 2*/
-			pRec->oc1 = pRec->i * coQB * DEG2RAD(pRec->oa1)       /* d3=d(tx)=BeamOffset*cos(QB)*dQ  */
-				  / (-2.0 * siQB * siQB);                     /*         /(-2*sin^2(QB))         */
-		} else {
-			pRec->oc1 = 0.0;                                      /* d3=d(tx)=0.         */
-		}
-		pRec->ob0 = pRec->ob1 / pRec->b1;                             /* m2=d2/scale2        */
-		pRec->oc0 = pRec->oc1 / pRec->c1;                             /* m3=d3/scale3        */
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Energy To Lambda
- * tsubMOEnAxs1 - Axes Energy To Lambda
- *	oa = L               h = EvLambda
- *	a = E                p = x1:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs1 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {	/* --------------Absolute Motion------------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* L=EvLambda/E        */
-	} else {		/* ---------------Relative Motion------------ */
-		if (pRec->p != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dL=-EvLambda*dE/E^2 */
-					     / (pRec->p * pRec->p);
-	}
-	return (0);
-}
-
-/* =========================================== - Axes Lamdba To Energy
- * tsubMOEnAx2 - Axes Lamdba To Energy
- *	oa = E               h = EvLambda
- *	a = L                q = x2:ActPos
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubMOEnAxs2 (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0) {	/* ----------------Absolute Motion----------- */
-		if (pRec->a != 0.0) pRec->oa = pRec->h / pRec->a;             /* E=EvLambda/L        */
-	} else {		/* -----------------Relative Motion---------- */
-		if (pRec->q != 0.0) pRec->oa = -1.0 * pRec->h * pRec->a       /* dE=-EvLambda*dL/L^2 */
-					     / (pRec->q * pRec->q);
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubMOEnSpeed - Speed propagation spreadsheet
- *	oa0 = m1   (=rotary)
- *	ob0 = m2   (=translation_2)
- *	oc0 = m3   (=translation_x)
- *	oa1 = d1   (=QB)
- *	ob1 = d2   (=t2)
- *	oc1 = d3   (=tx)
- *	oa2 = x1   (=E)
- *	ob2 = x2   (=L)
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *	g = ESinTheta
- *	h = EvLambda
- *      m = d1:ActPos (QB:ActPos)
- *      p = x1:ActPos (E:ActPos)
- *      nla = Index of input (m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22)
- */
-static long tsubMOEnSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                      /* sdis=1 */
-
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: called with n=%f \n",pRec->nla);
-
-	siQB = SIND(pRec->m);                              /* sin(QB) */
-	coQB = COSD(pRec->m);                              /* cos(QB) */
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ||
-             pRec->g  == 0.0 || pRec->h  == 0.0 ||
-             siQB     == 0.0 || coQB     == 0.0 ) {
-	   printf ("tsubMOEnSpeed: exit on zero calc parameters\n");
-	   printf ("tsubMOEnSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubMOEnSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubMOEnSpeed: max3=%5.2f sca3=%g\n",pRec->c,pRec->c3);
-	   printf ("tsubMOEnSpeed: ESinTheta=%g EvLambda=%g\n",pRec->g,pRec->h);
-	   printf ("tsubMOEnSpeed: sin(QB)=%g cos(QB)=%g\n",siQB,coQB);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0) { /* ------------------------ m1 speed changed */
-	   if (pRec->a0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0) { /* ------------------------ m2 speed changed */
-	   if (pRec->b0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0) { /* ------------------------ m3 speed changed */
-	   if (pRec->c0 == 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else prcn = fabs( pRec->c0 / pRec->c );         /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) { /* ------------------------ d1 speed changed */
-	   if (pRec->a1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) { /* ------------------------ d2 speed changed */
-	   if (pRec->b1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs(pRec->b1 / (1000.0 * pRec->b * pRec->b3));
-	}
-	else if (pRec->nla == 13.0) { /* ------------------------ d3 speed changed */
-	   if (pRec->c1  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->c1 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs(pRec->c1 / (1000.0 * pRec->c * pRec->c3));
-	}
-	else if (pRec->nla == 21.0) { /* ------------------------- x1 speed changed */
-	   if (pRec->a2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->a2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-             prcn = fabs( pRec->a2 / x1 );
-	   }
-	}
-	else if (pRec->nla == 22.0) { /* ------------------------ x2 speed changed */
-	   if (pRec->b2  < 0.0) ifail = -1;                /* x,d speeds are always > 0 */
-	   if (pRec->b2 <= 0.0) prcn = 1.0;                /* if 0, then set to max */
-	   else {
-/* d1=dQ/dt=m1*scale1 */
-	     d1 = fabs( 1000.0 * pRec->a * pRec->a3 );
-/* maximum speed: max(x1)=max(dE/dt)=-(EsinTheta*cos(QB)/sin^2(QB))*max(dQ/dt) */
-	     x1 = -(pRec->g * coQB/(siQB*siQB)) * DEG2RAD(d1);
-/* maximum speed: max(x2)=max(dL/dt)=-(EvLambda/E^2)*max(dE/dt) */
-	     x2 = -(pRec->h / (pRec->p*pRec->p)) * x1;
-             prcn = fabs( pRec->b2 / x2 );
-	   }
-	}
-	else {
-	   return (-1);
-	}
-
-	if (prcn < 0.0 || prcn > 1.0) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-/* If we are scanning trolley, we should not reduce the speed of rotary,
- * since the rotary is generally slower than trolley and it may limit
- * the scan speed of trolley */
-	if ( pRec->nla == 2.0 ||
-             pRec->nla == 3.0 ||
-             pRec->nla == 12.0 ||
-             pRec->nla == 13.0 ) m1 = pRec->a;                    /* m1=m1_max */
-	else                     m1 = prcn * pRec->a;             /* m1=prcn*m1_max */
-
-	m1 = prcn * pRec->a;                                      /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                      /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                      /* m3=prcn*m3_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );                     /* d1=dQ/dt=m1*scale1  */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );                     /* d2=dt2/dt=m2*scale2 */
-	d3 = fabs( 1000.0 *  m3 * pRec->c3 );                     /* d3=dx2/dt=m3*scale3 */
-	x1 = fabs( pRec->g * DEG2RAD(d1) * coQB / (siQB*siQB) );  /* x1=dE/dt=-(EsinTheta*cos(QB)/sin^2(QB))*dQ/dt */
-	x2 = fabs( pRec->h * x1 / (pRec->p*pRec->p) );            /* x2=dL/dt=-(EvLambda/E^2)*dE/dt */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oc1 = d3;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-  	if (tsubMODebug > 1) printf ("tsubMOEnSpeed: m1=%5.2f  m2=%5.2f  m3=%5.2f\n",m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubMOEnRef[] = {
-    {"tsubMOEn",      (REGISTRYFUNCTION)tsubMOEn},
-    {"tsubMOEnSync",  (REGISTRYFUNCTION)tsubMOEnSync},
-    {"tsubMOEnMtr",   (REGISTRYFUNCTION)tsubMOEnMtr},
-    {"tsubMOEnDrv",   (REGISTRYFUNCTION)tsubMOEnDrv},
-    {"tsubMOEnAxs",   (REGISTRYFUNCTION)tsubMOEnAxs},
-    {"tsubMOEnAxs1",  (REGISTRYFUNCTION)tsubMOEnAxs1},
-    {"tsubMOEnAxs2",  (REGISTRYFUNCTION)tsubMOEnAxs2},
-    {"tsubMOEnSpeed", (REGISTRYFUNCTION)tsubMOEnSpeed}
-};
-
-static void tsubMOEnFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubMOEnRef,NELEMENTS(tsubMOEnRef));
-}
-epicsExportRegistrar(tsubMOEnFunc);
diff --git a/pmacApp/tsubSrc/tsubRecord.c b/pmacApp/tsubSrc/tsubRecord.c
deleted file mode 100644
index 27a6212..0000000
--- a/pmacApp/tsubSrc/tsubRecord.c
+++ /dev/null
@@ -1,503 +0,0 @@
-/* recTsub.c */
-/* share/src/rec @(#)recTsub.c	1.19     6/4/93 */
-
-/* recTsub.c - Record Support Routines for Subroutine records */
-/*
- *      Original Author: Bob Dalesio
- *      Current Author:  Marty Kraimer
- *      Date:            01-25-90
- *
- *      Experimental Physics and Industrial Control System (EPICS)
- *
- *      Copyright 1991, the Regents of the University of California,
- *      and the University of Chicago Board of Governors.
- *
- *      This software was produced under  U.S. Government contracts:
- *      (W-7405-ENG-36) at the Los Alamos National Laboratory,
- *      and (W-31-109-ENG-38) at Argonne National Laboratory.
- *
- *      Initial development by:
- *              The Controls and Automation Group (AT-8)
- *              Ground Test Accelerator
- *              Accelerator Technology Division
- *              Los Alamos National Laboratory
- *
- *      Co-developed with
- *              The Controls and Computing Group
- *              Accelerator Systems Division
- *              Advanced Photon Source
- *              Argonne National Laboratory
- *
- * Modification Log:
- * -----------------
- * .01  10-10-90	mrk	Made changes for new record support
- * .02  11-11-91        jba     Moved set and reset of alarm stat and sevr to macros
- * .03  01-08-92        jba     Added casts in symFindByName to avoid compile warning messages
- * .04  02-05-92	jba	Changed function arguments from paddr to precord
- * .05  02-28-92        jba     Changed get_precision,get_graphic_double,get_control_double
- * .06  02-28-92	jba	ANSI C changes
- * .07  04-10-92        jba     pact now used to test for asyn processing, not status
- * .08  06-02-92        jba     changed graphic/control limits for hihi,high,low,lolo
- * .09  07-15-92        jba     changed VALID_ALARM to INVALID alarm
- * .10  07-16-92        jba     added invalid alarm fwd link test and chngd fwd lnk to macro
- * .11  07-21-92        jba     changed alarm limits for non val related fields
- * .12  08-06-92        jba     New algorithm for calculating analog alarms
- * .13  08-06-92        jba     monitor now posts events for changes in a-l
- * .14  10-10-92        jba     replaced code with recGblGetLinkValue call
- * .15  10-18-93        mhb     Built big subroutine record from sub record
- * .16  02-05-95	jt	use update to r3.12
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include	<alarm.h>
-#include	<cantProceed.h>
-#include	<dbDefs.h>
-#include	<dbEvent.h>
-#include	<dbAccess.h>
-#include	<dbFldTypes.h>
-#include	<dbStaticLib.h>
-#include	<errMdef.h>
-#include	<errlog.h>
-#include	<recSup.h>
-#include	<devSup.h>
-#include	<special.h>
-#include	<registryFunction.h>
-#include	<epicsExport.h>
-#include	<recGbl.h>
-
-#define GEN_SIZE_OFFSET
-#include	<tsubRecord.h>
-#undef  GEN_SIZE_OFFSET
-
-/* Create RSET - Record Support Entry Table*/
-#define report NULL
-#define initialize NULL
-static long init_record(tsubRecord *, int);
-static long process(tsubRecord *);
-#define special NULL
-static long get_value(tsubRecord *, valueDes *);
-#define cvt_dbaddr NULL
-#define get_array_info NULL
-#define put_array_info NULL
-static long get_units    (DBADDR *, char *);
-static long get_precision(DBADDR *, long *);
-#define get_enum_str NULL
-#define get_enum_strs NULL
-#define put_enum_str NULL
-static long get_graphic_double(DBADDR *, struct dbr_grDouble *);
-static long get_control_double(DBADDR *, struct dbr_ctrlDouble *);
-static long get_alarm_double  (DBADDR *, struct dbr_alDouble *);
-
-rset tsubRSET={
-	RSETNUMBER,
-	report,
-	initialize,
-	init_record,
-	process,
-	special,
-	get_value,
-	cvt_dbaddr,
-	get_array_info,
-	put_array_info,
-	get_units,
-	get_precision,
-	get_enum_str,
-	get_enum_strs,
-	put_enum_str,
-	get_graphic_double,
-	get_control_double,
-	get_alarm_double };
-epicsExportAddress(rset,tsubRSET);
-
-static void set_alarms  (tsubRecord *);
-static long do_sub      (tsubRecord *);
-static long fetch_values(tsubRecord *);
-static long push_values (tsubRecord *);
-static void monitor     (tsubRecord *);
-
-#define IN_ARG_MAX 20
-#define INP_ARG_MAX 80
-#define OUT_ARG_MAX 70
-/* Fldnames should have as many as INP_ARG_MAX */
-
-typedef long (*TSUBFUNCPTR)(struct tsubRecord *);
-
-
-static long init_record(tsubRecord *ptsub, int pass)
-{
-    TSUBFUNCPTR pfunc;
-    struct 	link *plink;
-    double 	*pvalue;
-    long        status;
-    int         i;
-
-    if (pass==0) {
-      return(0);
-    }
-
-   status = 0;
-
-    /* Initialize Input Links */
-    plink = &ptsub->inpa;
-    pvalue = &ptsub->a;
-    for(i=0; i<INP_ARG_MAX; i++, plink++, pvalue++) {
-        switch (plink->type) {
-        case CONSTANT:
-                if (recGblInitConstantLink(plink, DBF_DOUBLE, pvalue)) {
-                    ptsub->udf = FALSE;
-                } else
-                    ptsub->udf = TRUE;
-            break;
-
-        case PV_LINK:
-        case CA_LINK:
-        case DB_LINK:
-            break;
-
-        default:
-            recGblRecordError(S_db_badField, (void *)ptsub,
-                "tsubRecord(init_record) Illegal INPUT LINK");
-            status = S_db_badField;
-            break;
-        }
-    }
-
-    if (status)
-        return status;
-
-    /* Initialize Output Links */
-    plink = &ptsub->outa;
-    pvalue = &ptsub->oa;
-    for(i=0; i<OUT_ARG_MAX; i++, plink++, pvalue++) {
-        switch (plink->type) {
-        case CONSTANT:
-        case PV_LINK:
-        case CA_LINK:
-        case DB_LINK:
-            break;
-
-        default:
-            recGblRecordError(S_db_badField, (void *)ptsub,
-                "tsubRecord(init_record) Illegal OUTPUT LINK");
-            status = S_db_badField;
-        }
-    }
-    if (status)
-        return status;
-
-    /* Call the user initialization routine if there is one */
-    if (ptsub->inam[0] != 0) {
-        pfunc = (TSUBFUNCPTR)registryFunctionFind(ptsub->inam);
-        if (pfunc) {
-            pfunc(ptsub);
-        } else {
-            recGblRecordError(S_db_BadSub, (void *)ptsub,
-                "tsubRecord::init_record - INAM subr not found");
-            return S_db_BadSub;
-        }
-    }
-
-    if (ptsub->snam[0] != 0) {
-        pfunc = (TSUBFUNCPTR)registryFunctionFind(ptsub->snam);
-        if (pfunc)
-            ptsub->sadr = pfunc;
-        else {
-            recGblRecordError(S_db_BadSub, (void *)ptsub,
-                "tsubRecord::init_record - SNAM subr not found");
-            return S_db_BadSub;
-        }
-    }
-    return 0;
-}
-
-
-
-static long process(tsubRecord *ptsub)
-{
-	long		 status=0;
-	unsigned char	 pact=ptsub->pact;
-
-        if(!ptsub->pact){
-		ptsub->pact = TRUE;
-		status = fetch_values(ptsub);
-		ptsub->pact = FALSE;
-	}
-        if(status==0) status = do_sub(ptsub);
-	if(!pact && ptsub->pact) {
-	  return(0);
-	}
-        ptsub->pact = TRUE;
-	if(status==1) {
-	  return(0);
-	}
-	recGblGetTimeStamp(ptsub);
-        /* check for alarms */
-        set_alarms(ptsub);
-        /* check event list */
-        monitor(ptsub);
-
-	/* Push out the output link data values */
-	status = push_values(ptsub);
-
-        /* process the forward scan link record */
-        recGblFwdLink(ptsub);
-
-        ptsub->pact = FALSE;
-        return(status);
-}
-
-static long get_value(tsubRecord *ptsub, valueDes *pvdes)
-{
-    pvdes->field_type = DBF_DOUBLE;
-    pvdes->no_elements=1;
-/*  (double *)(pvdes->pvalue) = &ptsub->val; */
-/* Sergey */
-    pvdes->pvalue = (double *)(&ptsub->val);
-    return(0);
-}
-
-
-static long get_units(DBADDR *paddr, char *units)
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    strncpy(units,ptsub->egu,sizeof(ptsub->egu));
-    return(0);
-}
-
-
-static long get_precision(DBADDR *paddr, long *precision)
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    *precision = ptsub->prec;
-    if(paddr->pfield==(void *)&ptsub->val) return(0);
-    recGblGetPrec(paddr,precision);
-    return(0);
-}
-
-
-static long get_graphic_double (DBADDR *paddr, struct dbr_grDouble *pgd)
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val
-    || paddr->pfield==(void *)&ptsub->hihi
-    || paddr->pfield==(void *)&ptsub->high
-    || paddr->pfield==(void *)&ptsub->low
-    || paddr->pfield==(void *)&ptsub->lolo){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-
-    if(paddr->pfield>=(void *)&ptsub->a && paddr->pfield<=(void *)&ptsub->t){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-    if(paddr->pfield>=(void *)&ptsub->la && paddr->pfield<=(void *)&ptsub->lt){
-        pgd->upper_disp_limit = ptsub->hopr;
-        pgd->lower_disp_limit = ptsub->lopr;
-        return(0);
-    }
-    return(0);
-}
-
-
-static long get_control_double(DBADDR *paddr, struct dbr_ctrlDouble *pcd)
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val
-    || paddr->pfield==(void *)&ptsub->hihi
-    || paddr->pfield==(void *)&ptsub->high
-    || paddr->pfield==(void *)&ptsub->low
-    || paddr->pfield==(void *)&ptsub->lolo){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-       return(0);
-    }
-
-    if(paddr->pfield>=(void *)&ptsub->a && paddr->pfield<=(void *)&ptsub->t){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-        return(0);
-    }
-    if(paddr->pfield>=(void *)&ptsub->la && paddr->pfield<=(void *)&ptsub->lt){
-        pcd->upper_ctrl_limit = ptsub->hopr;
-        pcd->lower_ctrl_limit = ptsub->lopr;
-        return(0);
-    }
-    return(0);
-}
-
-
-static long get_alarm_double(DBADDR *paddr, struct dbr_alDouble *pad)
-{
-    struct tsubRecord	*ptsub=(struct tsubRecord *)paddr->precord;
-
-    if(paddr->pfield==(void *)&ptsub->val){
-         pad->upper_alarm_limit = ptsub->hihi;
-         pad->upper_warning_limit = ptsub->high;
-         pad->lower_warning_limit = ptsub->low;
-         pad->lower_alarm_limit = ptsub->lolo;
-    } else recGblGetAlarmDouble(paddr,pad);
-    return(0);
-}
-
-static void set_alarms(tsubRecord *ptsub)
-{
-	double		val;
-	float		hyst, lalm, hihi, high, low, lolo;
-	unsigned short	hhsv, llsv, hsv, lsv;
-
-	if(ptsub->udf == TRUE ){
- 		recGblSetSevr(ptsub,UDF_ALARM,INVALID_ALARM);
-		return;
-	}
-	hihi = ptsub->hihi; lolo = ptsub->lolo; high = ptsub->high; low = ptsub->low;
-	hhsv = ptsub->hhsv; llsv = ptsub->llsv; hsv = ptsub->hsv; lsv = ptsub->lsv;
-	val = ptsub->val; hyst = ptsub->hyst; lalm = ptsub->lalm;
-
-	/* alarm condition hihi */
-	if (hhsv && (val >= hihi || ((lalm==hihi) && (val >= hihi-hyst)))){
-	        if (recGblSetSevr(ptsub,HIHI_ALARM,ptsub->hhsv)) ptsub->lalm = hihi;
-		return;
-	}
-
-	/* alarm condition lolo */
-	if (llsv && (val <= lolo || ((lalm==lolo) && (val <= lolo+hyst)))){
-	        if (recGblSetSevr(ptsub,LOLO_ALARM,ptsub->llsv)) ptsub->lalm = lolo;
-		return;
-	}
-
-	/* alarm condition high */
-	if (hsv && (val >= high || ((lalm==high) && (val >= high-hyst)))){
-	        if (recGblSetSevr(ptsub,HIGH_ALARM,ptsub->hsv)) ptsub->lalm = high;
-		return;
-	}
-
-	/* alarm condition low */
-	if (lsv && (val <= low || ((lalm==low) && (val <= low+hyst)))){
-	        if (recGblSetSevr(ptsub,LOW_ALARM,ptsub->lsv)) ptsub->lalm = low;
-		return;
-	}
-
-	/* we get here only if val is out of alarm by at least hyst */
-	ptsub->lalm = val;
-	return;
-}
-
-static void monitor(tsubRecord *ptsub)
-{
-	unsigned short	monitor_mask;
-	double		delta;
-	double           *pnew;
-	double           *pprev;
-	int             i;
-
-        monitor_mask = recGblResetAlarms(ptsub);
-        monitor_mask |= (DBE_LOG|DBE_VALUE);
-        if(monitor_mask)
-        db_post_events(ptsub,(void *)&(ptsub->val),monitor_mask);
-        /* check for value change */
-        delta = ptsub->mlst - ptsub->val;
-        if(delta<0.0) delta = -delta;
-        if (delta > ptsub->mdel) {
-                /* post events for value change */
-                monitor_mask |= DBE_VALUE;
-                /* update last value monitored */
-                ptsub->mlst = ptsub->val;
-        }
-        /* check for archive change */
-        delta = ptsub->alst - ptsub->val;
-        if(delta<0.0) delta = -delta;
-        if (delta > ptsub->adel) {
-                /* post events on value field for archive change */
-                monitor_mask |= DBE_LOG;
-                /* update last archive value monitored */
-                ptsub->alst = ptsub->val;
-        }
-        /* send out monitors connected to the value field */
-        if (monitor_mask){
-                db_post_events(ptsub,&ptsub->val,monitor_mask);
-        }
-	/* check all link input fields for changes */
-	for(i=0, pnew=&ptsub->a, pprev=&ptsub->la; i<INP_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-	/* check all non-link input fields for changes */
-	for(i=0, pnew=&ptsub->nla, pprev=&ptsub->lnla; i<IN_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-	/* check all output fields for changes */
-	for(i=0, pnew=&ptsub->oa, pprev=&ptsub->loa; i<OUT_ARG_MAX; i++, pnew++, pprev++) {
-		if(*pnew != *pprev) {
-			db_post_events(ptsub,pnew,monitor_mask|DBE_VALUE);
-			*pprev = *pnew;
-		}
-	}
-        return;
-}
-
-static long fetch_values(tsubRecord *ptsub)
-{
-        struct link     *plink; /* structure of the link field  */
-        double           *pvalue;
-        int             i;
-	long		status;
-
-        for(i=0, plink=&ptsub->inpa, pvalue=&ptsub->a;
-        		i<INP_ARG_MAX; i++, plink++, pvalue++)
-        {
-		status=dbGetLink(plink,DBR_DOUBLE, pvalue,0,0);
-		/*status=recGblGetFastLink(plink,(void *)ptsub,pvalue);*/
-		if (!RTN_SUCCESS(status)) return(-1);
-        }
-        return(0);
-}
-
-static long push_values(tsubRecord *ptsub)
-{
-        struct link     *plink; /* structure of the link field  */
-        double           *pvalue;
-        int             i;
-	long		status;
-
-        for(i=0, plink=&ptsub->outa, pvalue=&ptsub->oa;
-        		i<OUT_ARG_MAX; i++, plink++, pvalue++)
-        {
-		status=dbPutLink(plink, DBR_DOUBLE, pvalue, 1);
-		if (!RTN_SUCCESS(status)) return(-1);
-        }
-        return(0);
-}
-
-static long do_sub(tsubRecord *ptsub)
-{
-	TSUBFUNCPTR	pfunc = ptsub->sadr;
-	long		status;
-
-	/* call the subroutine */
-	if(pfunc == NULL) {
-               	recGblSetSevr(ptsub,BAD_SUB_ALARM,INVALID_ALARM);
-            	return S_db_BadSub;
-	}
-	status = pfunc(ptsub);
-	if(status < 0)
-               	recGblSetSevr(ptsub, SOFT_ALARM, ptsub->brsv);
-	else
-		ptsub->udf = FALSE;
-
-	return(status);
-}
diff --git a/pmacApp/tsubSrc/tsubRecord.dbd b/pmacApp/tsubSrc/tsubRecord.dbd
deleted file mode 100644
index cc60f95..0000000
--- a/pmacApp/tsubSrc/tsubRecord.dbd
+++ /dev/null
@@ -1,2689 +0,0 @@
-recordtype(tsub) {
-	include "dbCommon.dbd"
-	field(VAL,DBF_DOUBLE) {
-		prompt("Result")
-		asl(ASL0)
-		pp(TRUE)
-	}
-	field(INAM,DBF_STRING) {
-		prompt("Init Routine Name")
-		promptgroup(GUI_COMMON)
-		special(SPC_NOMOD)
-		interest(1)
-		size(16)
-	}
-	field(SNAM,DBF_STRING) {
-		prompt("Subroutine Name")
-		promptgroup(GUI_ALARMS)
-		special(SPC_NOMOD)
-		interest(1)
-		size(16)
-	}
-	field(SADR,DBF_NOACCESS) {
-		prompt("Subroutine Address")
-		special(SPC_NOMOD)
-		special(SPC_NOMOD)
-		interest(2)
-		extra("long (*sadr)(struct tsubRecord *)")
-	}
-	field(EGU,DBF_STRING) {
-		prompt("Units Name")
-		promptgroup(GUI_TIMER)
-		interest(1)
-		size(16)
-	}
-	field(HOPR,DBF_FLOAT) {
-		prompt("High Operating Rng")
-		promptgroup(GUI_WAVE)
-		interest(1)
-	}
-	field(LOPR,DBF_FLOAT) {
-		prompt("Low Operating Range")
-		promptgroup(GUI_SCAN)
-		interest(1)
-	}
-	field(HIHI,DBF_FLOAT) {
-		prompt("Hihi Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOLO,DBF_FLOAT) {
-		prompt("Lolo Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(HIGH,DBF_FLOAT) {
-		prompt("High Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LOW,DBF_FLOAT) {
-		prompt("Low Alarm Limit")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(PREC,DBF_SHORT) {
-		prompt("Display Precision")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(BRSV,DBF_MENU) {
-		prompt("Bad Return Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HHSV,DBF_MENU) {
-		prompt("Hihi Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LLSV,DBF_MENU) {
-		prompt("Lolo Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HSV,DBF_MENU) {
-		prompt("High Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(LSV,DBF_MENU) {
-		prompt("Low Severity")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-		menu(menuAlarmSevr)
-	}
-	field(HYST,DBF_DOUBLE) {
-		prompt("Alarm Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(ADEL,DBF_DOUBLE) {
-		prompt("Archive Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(MDEL,DBF_DOUBLE) {
-		prompt("Monitor Deadband")
-		promptgroup(GUI_DISPLAY)
-		interest(1)
-	}
-	field(LALM,DBF_DOUBLE) {
-		prompt("Last Value Alarmed")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(ALST,DBF_DOUBLE) {
-		prompt("Last Value Archived")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(MLST,DBF_DOUBLE) {
-		prompt("Last Value Monitored")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(OUTA,DBF_OUTLINK) {
-		prompt("Output Link A")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTB,DBF_OUTLINK) {
-		prompt("Output Link B")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTC,DBF_OUTLINK) {
-		prompt("Output Link C")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTD,DBF_OUTLINK) {
-		prompt("Output Link D")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTE,DBF_OUTLINK) {
-		prompt("Output Link E")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTF,DBF_OUTLINK) {
-		prompt("Output Link F")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTG,DBF_OUTLINK) {
-		prompt("Output Link G")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTH,DBF_OUTLINK) {
-		prompt("Output Link H")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTI,DBF_OUTLINK) {
-		prompt("Output Link I")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OUTJ,DBF_OUTLINK) {
-		prompt("Output Link J")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA0,DBF_OUTLINK) {
-		prompt("Output Link A0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA1,DBF_OUTLINK) {
-		prompt("Output Link A1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA2,DBF_OUTLINK) {
-		prompt("Output Link A2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA3,DBF_OUTLINK) {
-		prompt("Output Link A3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA4,DBF_OUTLINK) {
-		prompt("Output Link A4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA5,DBF_OUTLINK) {
-		prompt("Output Link A5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA6,DBF_OUTLINK) {
-		prompt("Output Link A6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA7,DBF_OUTLINK) {
-		prompt("Output Link A7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA8,DBF_OUTLINK) {
-		prompt("Output Link A8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTA9,DBF_OUTLINK) {
-		prompt("Output Link A9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB0,DBF_OUTLINK) {
-		prompt("Output Link B0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB1,DBF_OUTLINK) {
-		prompt("Output Link B1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB2,DBF_OUTLINK) {
-		prompt("Output Link B2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB3,DBF_OUTLINK) {
-		prompt("Output Link B3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB4,DBF_OUTLINK) {
-		prompt("Output Link B4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB5,DBF_OUTLINK) {
-		prompt("Output Link B5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB6,DBF_OUTLINK) {
-		prompt("Output Link B6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB7,DBF_OUTLINK) {
-		prompt("Output Link B7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB8,DBF_OUTLINK) {
-		prompt("Output Link B8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTB9,DBF_OUTLINK) {
-		prompt("Output Link B9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC0,DBF_OUTLINK) {
-		prompt("Output Link C0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC1,DBF_OUTLINK) {
-		prompt("Output Link C1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC2,DBF_OUTLINK) {
-		prompt("Output Link C2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC3,DBF_OUTLINK) {
-		prompt("Output Link C3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC4,DBF_OUTLINK) {
-		prompt("Output Link C4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC5,DBF_OUTLINK) {
-		prompt("Output Link C5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC6,DBF_OUTLINK) {
-		prompt("Output Link C6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC7,DBF_OUTLINK) {
-		prompt("Output Link C7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC8,DBF_OUTLINK) {
-		prompt("Output Link C8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTC9,DBF_OUTLINK) {
-		prompt("Output Link C9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD0,DBF_OUTLINK) {
-		prompt("Output Link D0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD1,DBF_OUTLINK) {
-		prompt("Output Link D1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD2,DBF_OUTLINK) {
-		prompt("Output Link D2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD3,DBF_OUTLINK) {
-		prompt("Output Link D3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD4,DBF_OUTLINK) {
-		prompt("Output Link D4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD5,DBF_OUTLINK) {
-		prompt("Output Link D5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD6,DBF_OUTLINK) {
-		prompt("Output Link D6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD7,DBF_OUTLINK) {
-		prompt("Output Link D7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD8,DBF_OUTLINK) {
-		prompt("Output Link D8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTD9,DBF_OUTLINK) {
-		prompt("Output Link D9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE0,DBF_OUTLINK) {
-		prompt("Output Link E0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE1,DBF_OUTLINK) {
-		prompt("Output Link E1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE2,DBF_OUTLINK) {
-		prompt("Output Link E2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE3,DBF_OUTLINK) {
-		prompt("Output Link E3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE4,DBF_OUTLINK) {
-		prompt("Output Link E4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE5,DBF_OUTLINK) {
-		prompt("Output Link E5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE6,DBF_OUTLINK) {
-		prompt("Output Link E6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE7,DBF_OUTLINK) {
-		prompt("Output Link E7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE8,DBF_OUTLINK) {
-		prompt("Output Link E8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTE9,DBF_OUTLINK) {
-		prompt("Output Link E9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF0,DBF_OUTLINK) {
-		prompt("Output Link F0")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF1,DBF_OUTLINK) {
-		prompt("Output Link F1")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF2,DBF_OUTLINK) {
-		prompt("Output Link F2")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF3,DBF_OUTLINK) {
-		prompt("Output Link F3")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF4,DBF_OUTLINK) {
-		prompt("Output Link F4")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF5,DBF_OUTLINK) {
-		prompt("Output Link F5")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF6,DBF_OUTLINK) {
-		prompt("Output Link F6")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF7,DBF_OUTLINK) {
-		prompt("Output Link F7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF8,DBF_OUTLINK) {
-		prompt("Output Link F8")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OTF9,DBF_OUTLINK) {
-		prompt("Output Link F9")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(OA,DBF_DOUBLE) {
-		prompt("Output Value A")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB,DBF_DOUBLE) {
-		prompt("Output Value B")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC,DBF_DOUBLE) {
-		prompt("Output Value C")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD,DBF_DOUBLE) {
-		prompt("Output Value D")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE,DBF_DOUBLE) {
-		prompt("Output Value E")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF,DBF_DOUBLE) {
-		prompt("Output Value F")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OG,DBF_DOUBLE) {
-		prompt("Output Value G")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OH,DBF_DOUBLE) {
-		prompt("Output Value H")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OI,DBF_DOUBLE) {
-		prompt("Output Value I")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OJ,DBF_DOUBLE) {
-		prompt("Output Value J")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA0,DBF_DOUBLE) {
-		prompt("Output Value A0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA1,DBF_DOUBLE) {
-		prompt("Output Value A1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA2,DBF_DOUBLE) {
-		prompt("Output Value A2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA3,DBF_DOUBLE) {
-		prompt("Output Value A3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA4,DBF_DOUBLE) {
-		prompt("Output Value A4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA5,DBF_DOUBLE) {
-		prompt("Output Value A5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA6,DBF_DOUBLE) {
-		prompt("Output Value A6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA7,DBF_DOUBLE) {
-		prompt("Output Value A7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA8,DBF_DOUBLE) {
-		prompt("Output Value A8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OA9,DBF_DOUBLE) {
-		prompt("Output Value A9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB0,DBF_DOUBLE) {
-		prompt("Output Value B0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB1,DBF_DOUBLE) {
-		prompt("Output Value B1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB2,DBF_DOUBLE) {
-		prompt("Output Value B2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB3,DBF_DOUBLE) {
-		prompt("Output Value B3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB4,DBF_DOUBLE) {
-		prompt("Output Value B4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB5,DBF_DOUBLE) {
-		prompt("Output Value B5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB6,DBF_DOUBLE) {
-		prompt("Output Value B6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB7,DBF_DOUBLE) {
-		prompt("Output Value B7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB8,DBF_DOUBLE) {
-		prompt("Output Value B8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OB9,DBF_DOUBLE) {
-		prompt("Output Value B9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC0,DBF_DOUBLE) {
-		prompt("Output Value C0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC1,DBF_DOUBLE) {
-		prompt("Output Value C1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC2,DBF_DOUBLE) {
-		prompt("Output Value C2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC3,DBF_DOUBLE) {
-		prompt("Output Value C3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC4,DBF_DOUBLE) {
-		prompt("Output Value C4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC5,DBF_DOUBLE) {
-		prompt("Output Value C5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC6,DBF_DOUBLE) {
-		prompt("Output Value C6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC7,DBF_DOUBLE) {
-		prompt("Output Value C7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC8,DBF_DOUBLE) {
-		prompt("Output Value C8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OC9,DBF_DOUBLE) {
-		prompt("Output Value C9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD0,DBF_DOUBLE) {
-		prompt("Output Value D0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD1,DBF_DOUBLE) {
-		prompt("Output Value D1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD2,DBF_DOUBLE) {
-		prompt("Output Value D2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD3,DBF_DOUBLE) {
-		prompt("Output Value D3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD4,DBF_DOUBLE) {
-		prompt("Output Value D4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD5,DBF_DOUBLE) {
-		prompt("Output Value D5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD6,DBF_DOUBLE) {
-		prompt("Output Value D6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD7,DBF_DOUBLE) {
-		prompt("Output Value D7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD8,DBF_DOUBLE) {
-		prompt("Output Value D8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OD9,DBF_DOUBLE) {
-		prompt("Output Value D9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE0,DBF_DOUBLE) {
-		prompt("Output Value E0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE1,DBF_DOUBLE) {
-		prompt("Output Value E1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE2,DBF_DOUBLE) {
-		prompt("Output Value E2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE3,DBF_DOUBLE) {
-		prompt("Output Value E3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE4,DBF_DOUBLE) {
-		prompt("Output Value E4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE5,DBF_DOUBLE) {
-		prompt("Output Value E5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE6,DBF_DOUBLE) {
-		prompt("Output Value E6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE7,DBF_DOUBLE) {
-		prompt("Output Value E7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE8,DBF_DOUBLE) {
-		prompt("Output Value E8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OE9,DBF_DOUBLE) {
-		prompt("Output Value E9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF0,DBF_DOUBLE) {
-		prompt("Output Value F0")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF1,DBF_DOUBLE) {
-		prompt("Output Value F1")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF2,DBF_DOUBLE) {
-		prompt("Output Value F2")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF3,DBF_DOUBLE) {
-		prompt("Output Value F3")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF4,DBF_DOUBLE) {
-		prompt("Output Value F4")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF5,DBF_DOUBLE) {
-		prompt("Output Value F5")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF6,DBF_DOUBLE) {
-		prompt("Output Value F6")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF7,DBF_DOUBLE) {
-		prompt("Output Value F7")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF8,DBF_DOUBLE) {
-		prompt("Output Value F8")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(OF9,DBF_DOUBLE) {
-		prompt("Output Value F9")
-		promptgroup(GUI_DISPLAY)
-	}
-	field(LOA,DBF_DOUBLE) {
-		prompt("Prev Value of OA")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB,DBF_DOUBLE) {
-		prompt("Prev Value of OB")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC,DBF_DOUBLE) {
-		prompt("Prev Value of OC")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD,DBF_DOUBLE) {
-		prompt("Prev Value of OD")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE,DBF_DOUBLE) {
-		prompt("Prev Value of OE")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF,DBF_DOUBLE) {
-		prompt("Prev Value of OF")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOG,DBF_DOUBLE) {
-		prompt("Prev Value of OG")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOH,DBF_DOUBLE) {
-		prompt("Prev Value of OH")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOI,DBF_DOUBLE) {
-		prompt("Prev Value of OI")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOJ,DBF_DOUBLE) {
-		prompt("Prev Value of OJ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA0,DBF_DOUBLE) {
-		prompt("Prev Value of OA0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA1,DBF_DOUBLE) {
-		prompt("Prev Value of OA1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA2,DBF_DOUBLE) {
-		prompt("Prev Value of OA2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA3,DBF_DOUBLE) {
-		prompt("Prev Value of OA3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA4,DBF_DOUBLE) {
-		prompt("Prev Value of OA4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA5,DBF_DOUBLE) {
-		prompt("Prev Value of OA5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA6,DBF_DOUBLE) {
-		prompt("Prev Value of OA6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA7,DBF_DOUBLE) {
-		prompt("Prev Value of OA7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA8,DBF_DOUBLE) {
-		prompt("Prev Value of OA8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOA9,DBF_DOUBLE) {
-		prompt("Prev Value of OA9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB0,DBF_DOUBLE) {
-		prompt("Prev Value of OB0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB1,DBF_DOUBLE) {
-		prompt("Prev Value of OB1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB2,DBF_DOUBLE) {
-		prompt("Prev Value of OB2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB3,DBF_DOUBLE) {
-		prompt("Prev Value of OB3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB4,DBF_DOUBLE) {
-		prompt("Prev Value of OB4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB5,DBF_DOUBLE) {
-		prompt("Prev Value of OB5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB6,DBF_DOUBLE) {
-		prompt("Prev Value of OB6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB7,DBF_DOUBLE) {
-		prompt("Prev Value of OB7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB8,DBF_DOUBLE) {
-		prompt("Prev Value of OB8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOB9,DBF_DOUBLE) {
-		prompt("Prev Value of OB9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC0,DBF_DOUBLE) {
-		prompt("Prev Value of OC0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC1,DBF_DOUBLE) {
-		prompt("Prev Value of OC1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC2,DBF_DOUBLE) {
-		prompt("Prev Value of OC2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC3,DBF_DOUBLE) {
-		prompt("Prev Value of OC3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC4,DBF_DOUBLE) {
-		prompt("Prev Value of OC4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC5,DBF_DOUBLE) {
-		prompt("Prev Value of OC5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC6,DBF_DOUBLE) {
-		prompt("Prev Value of OC6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC7,DBF_DOUBLE) {
-		prompt("Prev Value of OC7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC8,DBF_DOUBLE) {
-		prompt("Prev Value of OC8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOC9,DBF_DOUBLE) {
-		prompt("Prev Value of OC9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD0,DBF_DOUBLE) {
-		prompt("Prev Value of OD0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD1,DBF_DOUBLE) {
-		prompt("Prev Value of OD1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD2,DBF_DOUBLE) {
-		prompt("Prev Value of OD2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD3,DBF_DOUBLE) {
-		prompt("Prev Value of OD3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD4,DBF_DOUBLE) {
-		prompt("Prev Value of OD4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD5,DBF_DOUBLE) {
-		prompt("Prev Value of OD5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD6,DBF_DOUBLE) {
-		prompt("Prev Value of OD6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD7,DBF_DOUBLE) {
-		prompt("Prev Value of OD7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD8,DBF_DOUBLE) {
-		prompt("Prev Value of OD8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOD9,DBF_DOUBLE) {
-		prompt("Prev Value of OD9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE0,DBF_DOUBLE) {
-		prompt("Prev Value of OE0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE1,DBF_DOUBLE) {
-		prompt("Prev Value of OE1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE2,DBF_DOUBLE) {
-		prompt("Prev Value of OE2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE3,DBF_DOUBLE) {
-		prompt("Prev Value of OE3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE4,DBF_DOUBLE) {
-		prompt("Prev Value of OE4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE5,DBF_DOUBLE) {
-		prompt("Prev Value of OE5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE6,DBF_DOUBLE) {
-		prompt("Prev Value of OE6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE7,DBF_DOUBLE) {
-		prompt("Prev Value of OE7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE8,DBF_DOUBLE) {
-		prompt("Prev Value of OE8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOE9,DBF_DOUBLE) {
-		prompt("Prev Value of OE9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF0,DBF_DOUBLE) {
-		prompt("Prev Value of OF0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF1,DBF_DOUBLE) {
-		prompt("Prev Value of OF1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF2,DBF_DOUBLE) {
-		prompt("Prev Value of OF2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF3,DBF_DOUBLE) {
-		prompt("Prev Value of OF3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF4,DBF_DOUBLE) {
-		prompt("Prev Value of OF4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF5,DBF_DOUBLE) {
-		prompt("Prev Value of OF5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF6,DBF_DOUBLE) {
-		prompt("Prev Value of OF6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF7,DBF_DOUBLE) {
-		prompt("Prev Value of OF7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF8,DBF_DOUBLE) {
-		prompt("Prev Value of OF8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LOF9,DBF_DOUBLE) {
-		prompt("Prev Value of OF9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(INPA,DBF_INLINK) {
-		prompt("Input A")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPB,DBF_INLINK) {
-		prompt("Input B")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPC,DBF_INLINK) {
-		prompt("Input C")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPD,DBF_INLINK) {
-		prompt("Input D")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPE,DBF_INLINK) {
-		prompt("Input E")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPF,DBF_INLINK) {
-		prompt("Input F")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPG,DBF_INLINK) {
-		prompt("Input G")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPH,DBF_INLINK) {
-		prompt("Input H")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPI,DBF_INLINK) {
-		prompt("Input I")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPJ,DBF_INLINK) {
-		prompt("Input J")
-		promptgroup(GUI_LINKS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPK,DBF_INLINK) {
-		prompt("Input K")
-		promptgroup(GUI_MBB)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPL,DBF_INLINK) {
-		prompt("Input L")
-		promptgroup(GUI_MOTOR)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPM,DBF_INLINK) {
-		prompt("Input M")
-		promptgroup(GUI_OUTPUT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPN,DBF_INLINK) {
-		prompt("Input N")
-		promptgroup(GUI_PID)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPO,DBF_INLINK) {
-		prompt("Input O")
-		promptgroup(GUI_PULSE)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPP,DBF_INLINK) {
-		prompt("Input P")
-		promptgroup(GUI_SELECT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPQ,DBF_INLINK) {
-		prompt("Input Q")
-		promptgroup(GUI_SEQ1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPR,DBF_INLINK) {
-		prompt("Input R")
-		promptgroup(GUI_SEQ2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPS,DBF_INLINK) {
-		prompt("Input S")
-		promptgroup(GUI_SEQ3)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(INPT,DBF_INLINK) {
-		prompt("Input T")
-		promptgroup(GUI_SUB)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA0,DBF_INLINK) {
-		prompt("Input A0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA1,DBF_INLINK) {
-		prompt("Input A1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA2,DBF_INLINK) {
-		prompt("Input A2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA3,DBF_INLINK) {
-		prompt("Input A3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA4,DBF_INLINK) {
-		prompt("Input A4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA5,DBF_INLINK) {
-		prompt("Input A5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA6,DBF_INLINK) {
-		prompt("Input A6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA7,DBF_INLINK) {
-		prompt("Input A7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA8,DBF_INLINK) {
-		prompt("Input A8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPA9,DBF_INLINK) {
-		prompt("Input A9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB0,DBF_INLINK) {
-		prompt("Input B0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB1,DBF_INLINK) {
-		prompt("Input B1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB2,DBF_INLINK) {
-		prompt("Input B2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB3,DBF_INLINK) {
-		prompt("Input B3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB4,DBF_INLINK) {
-		prompt("Input B4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB5,DBF_INLINK) {
-		prompt("Input B5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB6,DBF_INLINK) {
-		prompt("Input B6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB7,DBF_INLINK) {
-		prompt("Input B7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB8,DBF_INLINK) {
-		prompt("Input B8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPB9,DBF_INLINK) {
-		prompt("Input B9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC0,DBF_INLINK) {
-		prompt("Input C0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC1,DBF_INLINK) {
-		prompt("Input C1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC2,DBF_INLINK) {
-		prompt("Input C2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC3,DBF_INLINK) {
-		prompt("Input C3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC4,DBF_INLINK) {
-		prompt("Input C4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC5,DBF_INLINK) {
-		prompt("Input C5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC6,DBF_INLINK) {
-		prompt("Input C6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC7,DBF_INLINK) {
-		prompt("Input C7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC8,DBF_INLINK) {
-		prompt("Input C8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPC9,DBF_INLINK) {
-		prompt("Input C9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD0,DBF_INLINK) {
-		prompt("Input D0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD1,DBF_INLINK) {
-		prompt("Input D1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD2,DBF_INLINK) {
-		prompt("Input D2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD3,DBF_INLINK) {
-		prompt("Input D3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD4,DBF_INLINK) {
-		prompt("Input D4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD5,DBF_INLINK) {
-		prompt("Input D5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD6,DBF_INLINK) {
-		prompt("Input D6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD7,DBF_INLINK) {
-		prompt("Input D7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD8,DBF_INLINK) {
-		prompt("Input D8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPD9,DBF_INLINK) {
-		prompt("Input D9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE0,DBF_INLINK) {
-		prompt("Input E0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE1,DBF_INLINK) {
-		prompt("Input E1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE2,DBF_INLINK) {
-		prompt("Input E2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE3,DBF_INLINK) {
-		prompt("Input E3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE4,DBF_INLINK) {
-		prompt("Input E4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE5,DBF_INLINK) {
-		prompt("Input E5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE6,DBF_INLINK) {
-		prompt("Input E6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE7,DBF_INLINK) {
-		prompt("Input E7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE8,DBF_INLINK) {
-		prompt("Input E8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPE9,DBF_INLINK) {
-		prompt("Input E9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF0,DBF_INLINK) {
-		prompt("Input F0")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF1,DBF_INLINK) {
-		prompt("Input F1")
-		promptgroup(GUI_BITS1)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF2,DBF_INLINK) {
-		prompt("Input F2")
-		promptgroup(GUI_BITS2)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF3,DBF_INLINK) {
-		prompt("Input F3")
-		promptgroup(GUI_CALC)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF4,DBF_INLINK) {
-		prompt("Input F4")
-		promptgroup(GUI_CLOCK)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF5,DBF_INLINK) {
-		prompt("Input F5")
-		promptgroup(GUI_COMPRESS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF6,DBF_INLINK) {
-		prompt("Input F6")
-		promptgroup(GUI_CONVERT)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF7,DBF_INLINK) {
-		prompt("Input F7")
-		promptgroup(GUI_DISPLAY)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF8,DBF_INLINK) {
-		prompt("Input F8")
-		promptgroup(GUI_HIST)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(IPF9,DBF_INLINK) {
-		prompt("Input F9")
-		promptgroup(GUI_INPUTS)
-		special(SPC_NOMOD)
-		interest(1)
-	}
-	field(A,DBF_DOUBLE) {
-		prompt("Value of Input A")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B,DBF_DOUBLE) {
-		prompt("Value of Input B")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C,DBF_DOUBLE) {
-		prompt("Value of Input C")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D,DBF_DOUBLE) {
-		prompt("Value of Input D")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E,DBF_DOUBLE) {
-		prompt("Value of Input E")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F,DBF_DOUBLE) {
-		prompt("Value of Input F")
-		pp(TRUE)
-		interest(1)
-	}
-	field(G,DBF_DOUBLE) {
-		prompt("Value of Input G")
-		pp(TRUE)
-		interest(1)
-	}
-	field(H,DBF_DOUBLE) {
-		prompt("Value of Input H")
-		pp(TRUE)
-		interest(1)
-	}
-	field(I,DBF_DOUBLE) {
-		prompt("Value of Input I")
-		pp(TRUE)
-		interest(1)
-	}
-	field(J,DBF_DOUBLE) {
-		prompt("Value of Input J")
-		pp(TRUE)
-		interest(1)
-	}
-	field(K,DBF_DOUBLE) {
-		prompt("Value of Input K")
-		pp(TRUE)
-		interest(1)
-	}
-	field(L,DBF_DOUBLE) {
-		prompt("Value of Input L")
-		pp(TRUE)
-		interest(1)
-	}
-	field(M,DBF_DOUBLE) {
-		prompt("Value of Input M")
-		pp(TRUE)
-		interest(1)
-	}
-	field(N,DBF_DOUBLE) {
-		prompt("Value of Input N")
-		pp(TRUE)
-		interest(1)
-	}
-	field(O,DBF_DOUBLE) {
-		prompt("Value of Input O")
-		pp(TRUE)
-		interest(1)
-	}
-	field(P,DBF_DOUBLE) {
-		prompt("Value of Input P")
-		pp(TRUE)
-		interest(1)
-	}
-	field(Q,DBF_DOUBLE) {
-		prompt("Value of Input Q")
-		pp(TRUE)
-		interest(1)
-	}
-	field(R,DBF_DOUBLE) {
-		prompt("Value of Input R")
-		pp(TRUE)
-		interest(1)
-	}
-	field(S,DBF_DOUBLE) {
-		prompt("Value of Input S")
-		pp(TRUE)
-		interest(1)
-	}
-	field(T,DBF_DOUBLE) {
-		prompt("Value of Input T")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A0,DBF_DOUBLE) {
-		prompt("Value of Input A0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A1,DBF_DOUBLE) {
-		prompt("Value of Input A1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A2,DBF_DOUBLE) {
-		prompt("Value of Input A2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A3,DBF_DOUBLE) {
-		prompt("Value of Input A3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A4,DBF_DOUBLE) {
-		prompt("Value of Input A4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A5,DBF_DOUBLE) {
-		prompt("Value of Input A5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A6,DBF_DOUBLE) {
-		prompt("Value of Input A6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A7,DBF_DOUBLE) {
-		prompt("Value of Input A7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A8,DBF_DOUBLE) {
-		prompt("Value of Input A8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(A9,DBF_DOUBLE) {
-		prompt("Value of Input A9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B0,DBF_DOUBLE) {
-		prompt("Value of Input B0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B1,DBF_DOUBLE) {
-		prompt("Value of Input B1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B2,DBF_DOUBLE) {
-		prompt("Value of Input B2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B3,DBF_DOUBLE) {
-		prompt("Value of Input B3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B4,DBF_DOUBLE) {
-		prompt("Value of Input B4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B5,DBF_DOUBLE) {
-		prompt("Value of Input B5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B6,DBF_DOUBLE) {
-		prompt("Value of Input B6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B7,DBF_DOUBLE) {
-		prompt("Value of Input B7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B8,DBF_DOUBLE) {
-		prompt("Value of Input B8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(B9,DBF_DOUBLE) {
-		prompt("Value of Input B9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C0,DBF_DOUBLE) {
-		prompt("Value of Input C0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C1,DBF_DOUBLE) {
-		prompt("Value of Input C1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C2,DBF_DOUBLE) {
-		prompt("Value of Input C2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C3,DBF_DOUBLE) {
-		prompt("Value of Input C3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C4,DBF_DOUBLE) {
-		prompt("Value of Input C4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C5,DBF_DOUBLE) {
-		prompt("Value of Input C5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C6,DBF_DOUBLE) {
-		prompt("Value of Input C6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C7,DBF_DOUBLE) {
-		prompt("Value of Input C7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C8,DBF_DOUBLE) {
-		prompt("Value of Input C8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(C9,DBF_DOUBLE) {
-		prompt("Value of Input C9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D0,DBF_DOUBLE) {
-		prompt("Value of Input D0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D1,DBF_DOUBLE) {
-		prompt("Value of Input D1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D2,DBF_DOUBLE) {
-		prompt("Value of Input D2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D3,DBF_DOUBLE) {
-		prompt("Value of Input D3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D4,DBF_DOUBLE) {
-		prompt("Value of Input D4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D5,DBF_DOUBLE) {
-		prompt("Value of Input D5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D6,DBF_DOUBLE) {
-		prompt("Value of Input D6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D7,DBF_DOUBLE) {
-		prompt("Value of Input D7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D8,DBF_DOUBLE) {
-		prompt("Value of Input D8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(D9,DBF_DOUBLE) {
-		prompt("Value of Input D9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E0,DBF_DOUBLE) {
-		prompt("Value of Input E0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E1,DBF_DOUBLE) {
-		prompt("Value of Input E1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E2,DBF_DOUBLE) {
-		prompt("Value of Input E2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E3,DBF_DOUBLE) {
-		prompt("Value of Input E3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E4,DBF_DOUBLE) {
-		prompt("Value of Input E4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E5,DBF_DOUBLE) {
-		prompt("Value of Input E5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E6,DBF_DOUBLE) {
-		prompt("Value of Input E6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E7,DBF_DOUBLE) {
-		prompt("Value of Input E7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E8,DBF_DOUBLE) {
-		prompt("Value of Input E8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(E9,DBF_DOUBLE) {
-		prompt("Value of Input E9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F0,DBF_DOUBLE) {
-		prompt("Value of Input F0")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F1,DBF_DOUBLE) {
-		prompt("Value of Input F1")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F2,DBF_DOUBLE) {
-		prompt("Value of Input F2")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F3,DBF_DOUBLE) {
-		prompt("Value of Input F3")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F4,DBF_DOUBLE) {
-		prompt("Value of Input F4")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F5,DBF_DOUBLE) {
-		prompt("Value of Input F5")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F6,DBF_DOUBLE) {
-		prompt("Value of Input F6")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F7,DBF_DOUBLE) {
-		prompt("Value of Input F7")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F8,DBF_DOUBLE) {
-		prompt("Value of Input F8")
-		pp(TRUE)
-		interest(1)
-	}
-	field(F9,DBF_DOUBLE) {
-		prompt("Value of Input F9")
-		pp(TRUE)
-		interest(1)
-	}
-	field(LA,DBF_DOUBLE) {
-		prompt("Prev Value of A")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB,DBF_DOUBLE) {
-		prompt("Prev Value of B")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC,DBF_DOUBLE) {
-		prompt("Prev Value of C")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD,DBF_DOUBLE) {
-		prompt("Prev Value of D")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE,DBF_DOUBLE) {
-		prompt("Prev Value of E")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF,DBF_DOUBLE) {
-		prompt("Prev Value of F")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LG,DBF_DOUBLE) {
-		prompt("Prev Value of G")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LH,DBF_DOUBLE) {
-		prompt("Prev Value of H")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LI,DBF_DOUBLE) {
-		prompt("Prev Value of I")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LJ,DBF_DOUBLE) {
-		prompt("Prev Value of J")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LK,DBF_DOUBLE) {
-		prompt("Prev Value of K")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LL,DBF_DOUBLE) {
-		prompt("Prev Value of L")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LM,DBF_DOUBLE) {
-		prompt("Prev Value of M")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LN,DBF_DOUBLE) {
-		prompt("Prev Value of N")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LO,DBF_DOUBLE) {
-		prompt("Prev Value of O")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LP,DBF_DOUBLE) {
-		prompt("Prev Value of P")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LQ,DBF_DOUBLE) {
-		prompt("Prev Value of Q")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LR,DBF_DOUBLE) {
-		prompt("Prev Value of R")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LS,DBF_DOUBLE) {
-		prompt("Prev Value of S")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LT,DBF_DOUBLE) {
-		prompt("Prev Value of T")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA0,DBF_DOUBLE) {
-		prompt("Prev Value of A0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA1,DBF_DOUBLE) {
-		prompt("Prev Value of A1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA2,DBF_DOUBLE) {
-		prompt("Prev Value of A2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA3,DBF_DOUBLE) {
-		prompt("Prev Value of A3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA4,DBF_DOUBLE) {
-		prompt("Prev Value of A4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA5,DBF_DOUBLE) {
-		prompt("Prev Value of A5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA6,DBF_DOUBLE) {
-		prompt("Prev Value of A6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA7,DBF_DOUBLE) {
-		prompt("Prev Value of A7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA8,DBF_DOUBLE) {
-		prompt("Prev Value of A8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LA9,DBF_DOUBLE) {
-		prompt("Prev Value of A9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB0,DBF_DOUBLE) {
-		prompt("Prev Value of B0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB1,DBF_DOUBLE) {
-		prompt("Prev Value of B1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB2,DBF_DOUBLE) {
-		prompt("Prev Value of B2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB3,DBF_DOUBLE) {
-		prompt("Prev Value of B3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB4,DBF_DOUBLE) {
-		prompt("Prev Value of B4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB5,DBF_DOUBLE) {
-		prompt("Prev Value of B5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB6,DBF_DOUBLE) {
-		prompt("Prev Value of B6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB7,DBF_DOUBLE) {
-		prompt("Prev Value of B7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB8,DBF_DOUBLE) {
-		prompt("Prev Value of B8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LB9,DBF_DOUBLE) {
-		prompt("Prev Value of B9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC0,DBF_DOUBLE) {
-		prompt("Prev Value of C0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC1,DBF_DOUBLE) {
-		prompt("Prev Value of C1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC2,DBF_DOUBLE) {
-		prompt("Prev Value of C2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC3,DBF_DOUBLE) {
-		prompt("Prev Value of C3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC4,DBF_DOUBLE) {
-		prompt("Prev Value of C4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC5,DBF_DOUBLE) {
-		prompt("Prev Value of C5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC6,DBF_DOUBLE) {
-		prompt("Prev Value of C6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC7,DBF_DOUBLE) {
-		prompt("Prev Value of C7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC8,DBF_DOUBLE) {
-		prompt("Prev Value of C8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LC9,DBF_DOUBLE) {
-		prompt("Prev Value of C9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD0,DBF_DOUBLE) {
-		prompt("Prev Value of D0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD1,DBF_DOUBLE) {
-		prompt("Prev Value of D1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD2,DBF_DOUBLE) {
-		prompt("Prev Value of D2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD3,DBF_DOUBLE) {
-		prompt("Prev Value of D3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD4,DBF_DOUBLE) {
-		prompt("Prev Value of D4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD5,DBF_DOUBLE) {
-		prompt("Prev Value of D5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD6,DBF_DOUBLE) {
-		prompt("Prev Value of D6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD7,DBF_DOUBLE) {
-		prompt("Prev Value of D7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD8,DBF_DOUBLE) {
-		prompt("Prev Value of D8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LD9,DBF_DOUBLE) {
-		prompt("Prev Value of D9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE0,DBF_DOUBLE) {
-		prompt("Prev Value of E0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE1,DBF_DOUBLE) {
-		prompt("Prev Value of E1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE2,DBF_DOUBLE) {
-		prompt("Prev Value of E2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE3,DBF_DOUBLE) {
-		prompt("Prev Value of E3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE4,DBF_DOUBLE) {
-		prompt("Prev Value of E4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE5,DBF_DOUBLE) {
-		prompt("Prev Value of E5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE6,DBF_DOUBLE) {
-		prompt("Prev Value of E6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE7,DBF_DOUBLE) {
-		prompt("Prev Value of E7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE8,DBF_DOUBLE) {
-		prompt("Prev Value of E8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LE9,DBF_DOUBLE) {
-		prompt("Prev Value of E9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF0,DBF_DOUBLE) {
-		prompt("Prev Value of F0")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF1,DBF_DOUBLE) {
-		prompt("Prev Value of F1")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF2,DBF_DOUBLE) {
-		prompt("Prev Value of F2")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF3,DBF_DOUBLE) {
-		prompt("Prev Value of F3")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF4,DBF_DOUBLE) {
-		prompt("Prev Value of F4")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF5,DBF_DOUBLE) {
-		prompt("Prev Value of F5")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF6,DBF_DOUBLE) {
-		prompt("Prev Value of F6")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF7,DBF_DOUBLE) {
-		prompt("Prev Value of F7")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF8,DBF_DOUBLE) {
-		prompt("Prev Value of F8")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LF9,DBF_DOUBLE) {
-		prompt("Prev Value of F9")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(NLA,DBF_DOUBLE) {
-		prompt("Non-link input A")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLB,DBF_DOUBLE) {
-		prompt("Non-link input B")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLC,DBF_DOUBLE) {
-		prompt("Non-link input C")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLD,DBF_DOUBLE) {
-		prompt("Non-link input D")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLE,DBF_DOUBLE) {
-		prompt("Non-link input E")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLF,DBF_DOUBLE) {
-		prompt("Non-link input F")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLG,DBF_DOUBLE) {
-		prompt("Non-link input G")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLH,DBF_DOUBLE) {
-		prompt("Non-link input H")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLI,DBF_DOUBLE) {
-		prompt("Non-link input I")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLJ,DBF_DOUBLE) {
-		prompt("Non-link input J")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLK,DBF_DOUBLE) {
-		prompt("Non-link input K")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLL,DBF_DOUBLE) {
-		prompt("Non-link input L")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLM,DBF_DOUBLE) {
-		prompt("Non-link input M")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLN,DBF_DOUBLE) {
-		prompt("Non-link input N")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLO,DBF_DOUBLE) {
-		prompt("Non-link input O")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLP,DBF_DOUBLE) {
-		prompt("Non-link input P")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLQ,DBF_DOUBLE) {
-		prompt("Non-link input Q")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLR,DBF_DOUBLE) {
-		prompt("Non-link input R")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLS,DBF_DOUBLE) {
-		prompt("Non-link input S")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(NLT,DBF_DOUBLE) {
-		prompt("Non-link input T")
-		promptgroup(GUI_DISPLAY)
-		pp(TRUE)
-		interest(1)
-	}
-	field(LNLA,DBF_DOUBLE) {
-		prompt("Prev Value of NLA")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLB,DBF_DOUBLE) {
-		prompt("Prev Value of NLB")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLC,DBF_DOUBLE) {
-		prompt("Prev Value of NLC")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLD,DBF_DOUBLE) {
-		prompt("Prev Value of NLD")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLE,DBF_DOUBLE) {
-		prompt("Prev Value of NLE")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLF,DBF_DOUBLE) {
-		prompt("Prev Value of NLF")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLG,DBF_DOUBLE) {
-		prompt("Prev Value of NLG")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLH,DBF_DOUBLE) {
-		prompt("Prev Value of NLH")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLI,DBF_DOUBLE) {
-		prompt("Prev Value of NLI")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLJ,DBF_DOUBLE) {
-		prompt("Prev Value of NLJ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLK,DBF_DOUBLE) {
-		prompt("Prev Value of NLK")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLL,DBF_DOUBLE) {
-		prompt("Prev Value of NLL")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLM,DBF_DOUBLE) {
-		prompt("Prev Value of NLM")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLN,DBF_DOUBLE) {
-		prompt("Prev Value of NLN")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLO,DBF_DOUBLE) {
-		prompt("Prev Value of NLO")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLP,DBF_DOUBLE) {
-		prompt("Prev Value of NLP")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLQ,DBF_DOUBLE) {
-		prompt("Prev Value of NLQ")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLR,DBF_DOUBLE) {
-		prompt("Prev Value of NLR")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLS,DBF_DOUBLE) {
-		prompt("Prev Value of NLS")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-	field(LNLT,DBF_DOUBLE) {
-		prompt("Prev Value of NLT")
-		special(SPC_NOMOD)
-		interest(3)
-	}
-}
diff --git a/pmacApp/tsubSrc/tsubSH.c b/pmacApp/tsubSrc/tsubSH.c
deleted file mode 100644
index 9b72a86..0000000
--- a/pmacApp/tsubSrc/tsubSH.c
+++ /dev/null
@@ -1,171 +0,0 @@
-/* @(#) tsubSH.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubSH.c - Transformation Subroutines for Shutter Motor          */
-/*            (similar to XPs with the exception that provides      */
-/*             binary ouput on shutter status)                      */
-/*            This is for 1-motor assemblies -- Stepanov            */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubSHDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubSHDebug == (level)) ) { code } }
-
-
-/* ===========================================
- * tsubSHPs - Assembly-SHPs Initialization
- */
-static long tsubSHPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubSHPsSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubSHPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubSHPsMtr - Assembly-SHPs Motors
- *	oa1 = d1
- *	a = m1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- *      od = "shutter open/close" binary status
- *      c  = "shutter close" coordinate
- *      o  = "shutter open"  coordinate
- */
-static long tsubSHPsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		if (fabs(pRec->a-pRec->o) < fabs(pRec->a-pRec->c)) pRec->od = 1;  /* shutter open */
-                else                                               pRec->od = 0;  /* shutter closed */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubSHPsDrv - Assembly-SHPs Drives
- *	oa0 = m1
- *	a = d1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- *      od = "shutter open/close" binary status
- *      c  = "shutter close" coordinate
- *      o  = "shutter open"  coordinate
- */
-static long tsubSHPsDrv (struct tsubRecord *pRec) {
-	if ( pRec->a1 == 0.0 )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		if (fabs(pRec->oa0-pRec->o) < fabs(pRec->oa0-pRec->c)) pRec->od = 1;  /* shutter open */
-                else                                                   pRec->od = 0;  /* shutter closed */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubSHPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubSHPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubSHDebug > 1) printf ("tsubSHPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   printf ("tsubSHPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubSHPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-  	if (tsubSHDebug > 1) printf ("tsubSHPsSpeed: m1=%5.2f\n",m1);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubSHPsRef[] = {
-    {"tsubSHPs",      (REGISTRYFUNCTION)tsubSHPs},
-    {"tsubSHPsSync",  (REGISTRYFUNCTION)tsubSHPsSync},
-    {"tsubSHPsMtr",   (REGISTRYFUNCTION)tsubSHPsMtr},
-    {"tsubSHPsDrv",   (REGISTRYFUNCTION)tsubSHPsDrv},
-    {"tsubSHPsSpeed", (REGISTRYFUNCTION)tsubSHPsSpeed}
-};
-
-static void tsubSHPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubSHPsRef,NELEMENTS(tsubSHPsRef));
-}
-epicsExportRegistrar(tsubSHPsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubSeq.c b/pmacApp/tsubSrc/tsubSeq.c
deleted file mode 100644
index b25a00c..0000000
--- a/pmacApp/tsubSrc/tsubSeq.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/* @(#) tsubSeq.c 1.1 97/05/22 */
-
-/* tsubSeq.c - Transformation Subroutines For Sequence Function */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-#define TSUB_DIAGNOSTIC tsubSeqDebug
-
-#if TSUB_DIAGNOSTIC
-volatile int TSUB_DIAGNOSTIC = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code)  {if ((pRec->tpro == (level)) || (TSUB_DIAGNOSTIC == (level))) {code}}
-#else
-#define TSUB_TRACE(level,code);
-#endif
-
-/* ===========================================
- * tsubSeqInit - Initialization
- */
-static long tsubSeqInit (struct tsubRecord *pRec) {
-	return (0);
-}
-
-/* ===========================================
- * tsubSeqProc - Process
- */
-static long tsubSeqProc (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	pRec->od = pRec->d;
-	pRec->oe = pRec->e;
-	pRec->of = pRec->f;
-	pRec->og = pRec->g;
-	pRec->oh = pRec->h;
-	pRec->oi = pRec->i;
-	pRec->oj = pRec->j;
-
-	pRec->oa0 = pRec->a0;
-	pRec->oa1 = pRec->a1;
-	pRec->oa2 = pRec->a2;
-	pRec->oa3 = pRec->a3;
-	pRec->oa4 = pRec->a4;
-	pRec->oa5 = pRec->a5;
-	pRec->oa6 = pRec->a6;
-	pRec->oa7 = pRec->a7;
-	pRec->oa8 = pRec->a8;
-	pRec->oa9 = pRec->a9;
-
-	pRec->ob0 = pRec->b0;
-	pRec->ob1 = pRec->b1;
-	pRec->ob2 = pRec->b2;
-	pRec->ob3 = pRec->b3;
-	pRec->ob4 = pRec->b4;
-	pRec->ob5 = pRec->b5;
-	pRec->ob6 = pRec->b6;
-	pRec->ob7 = pRec->b7;
-	pRec->ob8 = pRec->b8;
-	pRec->ob9 = pRec->b9;
-
-	pRec->oc0 = pRec->c0;
-	pRec->oc1 = pRec->c1;
-	pRec->oc2 = pRec->c2;
-	pRec->oc3 = pRec->c3;
-	pRec->oc4 = pRec->c4;
-	pRec->oc5 = pRec->c5;
-	pRec->oc6 = pRec->c6;
-	pRec->oc7 = pRec->c7;
-	pRec->oc8 = pRec->c8;
-	pRec->oc9 = pRec->c9;
-
-	pRec->od0 = pRec->d0;
-	pRec->od1 = pRec->d1;
-	pRec->od2 = pRec->d2;
-	pRec->od3 = pRec->d3;
-	pRec->od4 = pRec->d4;
-	pRec->od5 = pRec->d5;
-	pRec->od6 = pRec->d6;
-	pRec->od7 = pRec->d7;
-	pRec->od8 = pRec->d8;
-	pRec->od9 = pRec->d9;
-
-	pRec->oe0 = pRec->e0;
-	pRec->oe1 = pRec->e1;
-	pRec->oe2 = pRec->e2;
-	pRec->oe3 = pRec->e3;
-	pRec->oe4 = pRec->e4;
-	pRec->oe5 = pRec->e5;
-	pRec->oe6 = pRec->e6;
-	pRec->oe7 = pRec->e7;
-	pRec->oe8 = pRec->e8;
-	pRec->oe9 = pRec->e9;
-
-	pRec->of0 = pRec->f0;
-	pRec->of1 = pRec->f1;
-	pRec->of2 = pRec->f2;
-	pRec->of3 = pRec->f3;
-	pRec->of4 = pRec->f4;
-	pRec->of5 = pRec->f5;
-	pRec->of6 = pRec->f6;
-	pRec->of7 = pRec->f7;
-	pRec->of8 = pRec->f8;
-	pRec->of9 = pRec->f9;
-
-	return (0);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubSeqRef[] = {
-    {"tsubSeqInit",  (REGISTRYFUNCTION)tsubSeqInit},
-    {"tsubSeqProc",  (REGISTRYFUNCTION)tsubSeqProc}
-};
-
-static void tsubSeqFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubSeqRef,NELEMENTS(tsubSeqRef));
-}
-epicsExportRegistrar(tsubSeqFunc);
-
diff --git a/pmacApp/tsubSrc/tsubTB.c b/pmacApp/tsubSrc/tsubTB.c
deleted file mode 100644
index e5f2f2a..0000000
--- a/pmacApp/tsubSrc/tsubTB.c
+++ /dev/null
@@ -1,366 +0,0 @@
-/* @(#) tsubTBSt.c 2.0 2004/05/31 -- speed propagation */
-
-/* tsubTBSt.c - Transformation Subroutines for a table supported by 3 motors
- *            - can also be used for the GM/CA CAT KB mirror  */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubTBDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code)       { if ( (pRec->tpro == (level)) || (tsubTBDebug == (level)) ) { code } }
-
-/* if x1=mm, x2,x3=mrad, base=m (BioCAT), then FCTB=1; if base=mm, then FCTB=1000. */
-volatile double FCTB = 1.0;
-
-/* ===========================================
- * tsubTBSt - Table support
- */
-static long tsubTBSt (struct tsubRecord *pRec) {
-        return (0);
-}
-
-
-/* ===========================================
- * tsubTBStSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubTBStSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubTBStMtr - Table support Motors
- *	oa = x1
- *	ob = x2
- *	oc = x3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	a = m1
- *	b = m2
- *	c = m3
- *	m = Base1:23
- *	n = Base23
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubTBStMtr (struct tsubRecord *pRec) {
-	if ( (pRec->m == 0.0) || (pRec->n == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;              /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;              /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;              /* d3=m3*scale3+offset3 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                         /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                         /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                         /* d3=m3*scale3 */
-	}
-
-	pRec->oa  = (pRec->ob1 + pRec->oc1 + 2.0 * pRec->oa1) / 4.0;    /* x1=(d2+d3+2*d1)/4            */
-	pRec->ob  = FCTB * (pRec->ob1 + pRec->oc1 - 2.0 * pRec->oa1)  /* x2=(d2+d3-2*d1)/(2*Base1:23) */
-                  / (2.0 * pRec->m);
-	pRec->oc  = FCTB * (pRec->ob1 - pRec->oc1) / pRec->n;         /* x3=(d2-d3)/Base23            */
-	return (0);
-}
-
-
-
-/* ===========================================
- * tsubTBStDrv - Table support Drives
- *	oa = x1
- *	ob = x2
- *	oc = x3
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1
- *	b = d2
- *	c = d3
- *	m = Base1:23
- *	n = Base23
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubTBStDrv (struct tsubRecord *pRec) {
-	if ( (pRec->m  == 0.0) || (pRec->n == 0.0) ||
-	     (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;            /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;            /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;            /* m3=(d3-offset3)/scale3 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->a) / pRec->a1;                       /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->b) / pRec->b1;                       /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->c) / pRec->c1;                       /* m3=d3/scale3 */
-	}
-	pRec->oa  = (pRec->b + pRec->c + 2.0 * pRec->a) / 4.0;          /* x1=(d2+d3+2*d1)/4            */
-	pRec->ob  = FCTB * (pRec->b + pRec->c - 2.0 * pRec->a)        /* x2=(d2+d3-2*d1)/(2*Base1:23) */
-                  / (2.0 * pRec->m);
-	pRec->oc  = FCTB * (pRec->b - pRec->c) / pRec->n;             /* x3=(d2-d3)/Base23            */
-	return (0);
-}
-
-/* ===========================================
- * tsubTBStAxs - Table support Axes
- *	oa0 = m1
- *	oa1 = d1
- *	ob0 = m2
- *	ob1 = d2
- *	oc0 = m3
- *	oc1 = d3
- *	a = x1
- *	b = x2
- *	c = x3
- *	m = Base1:23
- *	n = Base23
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (0=w/Offsets)[abs,pos] (1=wo/Offsets)[rel,vel]
- */
-static long tsubTBStAxs (struct tsubRecord *pRec) {
-	if ( (pRec->m  == 0.0) ||
-             (pRec->n  == 0.0) ||
-	     (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )
-	{
-		return (-1);
-	}
-	pRec->oa1 = pRec->a - (pRec->b * pRec->m) / (2.0 * FCTB);                     /* d1=x1-(x2*Base1:23)/2            */
-	pRec->ob1 = pRec->a + (pRec->b * pRec->m + pRec->c * pRec->n) / (2.0 * FCTB); /* d2=x1+(x2*Base1:23+x3*Bas23)/2   */
-	pRec->oc1 = pRec->a + (pRec->b * pRec->m - pRec->c * pRec->n) / (2.0 * FCTB); /* d3=x1+(x2*Base1:23-x3*Bas23)/2   */
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->oa1 - pRec->a0) / pRec->a1;     /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->ob1 - pRec->b0) / pRec->b1;     /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->oc1 - pRec->c0) / pRec->c1;     /* m3=(d3-offset3)/scale3 */
-	}
-	else
-	{
-		pRec->oa0 = (pRec->oa1) / pRec->a1;                /* m1=d1/scale1 */
-		pRec->ob0 = (pRec->ob1) / pRec->b1;                /* m2=d2/scale2 */
-		pRec->oc0 = (pRec->oc1) / pRec->c1;                /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubTBStSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	oa2 = x1
- *	ob2 = x2
- *	oc2 = x3
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a2 = x1
- *	b2 = x2
- *	c2 = x3
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *	m = Base1:23
- *	n = Base23
- *      nla = Index of input(m1=1, m2=2, m3=3, d1=11, d2=12, d3=13, x1=21, x2=22, x3=23)
- */
-static long tsubTBStSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3, x1, x2, x3;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubTBDebug > 1) printf ("tsubTBStSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 || pRec->c  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 || pRec->c3 == 0.0 ||
-             pRec->m  == 0.0 || pRec->n  == 0.0) {
-	   printf ("tsubTBStSpeed: exit on zero calc parameters\n");
-	   printf ("tsubTBStSpeed: max1=%5.2f sca1=%g\n",    pRec->a, pRec->a3);
-	   printf ("tsubTBStSpeed: max2=%5.2f sca2=%g\n",    pRec->b, pRec->b3);
-	   printf ("tsubTBStSpeed: max3=%5.2f sca3=%g\n",    pRec->c, pRec->c3);
-	   printf ("tsubTBStSpeed: Base1:23=%g Base23=%g\n", pRec->m, pRec->n);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs(pRec->a0 / pRec->a);           /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs(pRec->b0 / pRec->b);           /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* ------------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs(pRec->c0 / pRec->c);           /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* ------------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else if (pRec->nla == 21.0) /* ------------------------- x1 speed changed */
-	{
-	   if ( pRec->a2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of center is the average of the speeds of all drives */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      d3 = fabs( 1000.0 *  pRec->c * pRec->c3 );   /* d3=m3*scale3 */
-              prcn = fabs( pRec->a2 / ((d2 + d3 + 2.0*d1) / 4.0) );
-	   }
-	}
-	else if (pRec->nla == 22.0) /* ------------------------- x2 speed changed */
-	{
-	   if ( pRec->b2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of angle is twice the speed of each motor divided by base */
-	      d1 = fabs( 1000.0 *  pRec->a * pRec->a3 );   /* d1=m1*scale1 */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      d3 = fabs( 1000.0 *  pRec->c * pRec->c3 );   /* d3=m3*scale3 */
-              prcn = fabs( pRec->b2 / (FCTB*(d2 + d3 + 2.0*d1) / (2.0*pRec->m)) );
-	   }
-	}
-	else if (pRec->nla == 23.0) /* ------------------------- x3 speed changed */
-	{
-	   if ( pRec->c2  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->c2 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else {
-/* Speed of angle is twice the speed of each motor divided by base */
-	      d2 = fabs( 1000.0 *  pRec->b * pRec->b3 );   /* d2=m2*scale2 */
-	      d3 = fabs( 1000.0 *  pRec->c * pRec->c3 );   /* d3=m3*scale3 */
-              prcn = fabs( pRec->c2 / (FCTB*(d2 + d3) / (2.0*pRec->n)) );
-	   }
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                                  /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                                  /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                                  /* m3=prcn*m3_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );                 /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );                 /* d2=m2*scale2 */
-	d3 = fabs( 1000.0 *  m3 * pRec->c3 );                 /* d3=m3*scale3 */
-	x1 = fabs( (d2 + d3 + 2.0*d1) / 4.0 );                /* x1=(d2+d3+2*d1)/4 */
-	x2 = fabs( FCTB*(d2 + d3 + 2.0*d1) / (2.0*pRec->m) ); /* x2=(d2+d3-2*d1)/(2*Base1:23) */
-	x3 = fabs( FCTB*(d2 + d3)          / (2.0*pRec->n) ); /* x2=(d2+d3)     /(2*Base23) */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oc1 = d3;
-	pRec->oa2 = x1;
-	pRec->ob2 = x2;
-	pRec->oc2 = x3;
-  	if (tsubTBDebug > 1) printf ("tsubTBStSpeed: m1=%5.2f  m2=%5.2f  m3=%5.2f\n",m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubTBStRef[] = {
-    {"tsubTBSt",      (REGISTRYFUNCTION)tsubTBSt},
-    {"tsubTBStSync",  (REGISTRYFUNCTION)tsubTBStSync},
-    {"tsubTBStMtr",   (REGISTRYFUNCTION)tsubTBStMtr},
-    {"tsubTBStDrv",   (REGISTRYFUNCTION)tsubTBStDrv},
-    {"tsubTBStAxs",   (REGISTRYFUNCTION)tsubTBStAxs},
-    {"tsubTBStSpeed", (REGISTRYFUNCTION)tsubTBStSpeed}
-};
-
-static void tsubTBStFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubTBStRef,NELEMENTS(tsubTBStRef));
-}
-epicsExportRegistrar(tsubTBStFunc);
-
diff --git a/pmacApp/tsubSrc/tsubX.c b/pmacApp/tsubSrc/tsubX.c
deleted file mode 100644
index 8bbcfa3..0000000
--- a/pmacApp/tsubSrc/tsubX.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* @(#) tsubX.c 2.2 2004/05/31 -- speed propagation */
-
-/* tsubX.c - Transformation Subroutines for X-positioners          */
-/*           or one-axis rotation stages, i.e. any modular drives  */
-/*           This is for 1-motor assemblies -- Stepanov            */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubXDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubXDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubXPs - Assembly-X Initialization
- */
-static long tsubXPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXPsSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubXPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXPsMtr - Assembly-X Motors
- *	oa1 = d1
- *	a = m1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXPsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXPsDrv - Assembly-X Drives
- *	oa0 = m1
- *	a = d1
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXPsDrv (struct tsubRecord *pRec) {
-	if ( pRec->a1 == 0.0 )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubXPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubXDebug > 1) printf ("tsubXPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   printf ("tsubXPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubXPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-  	if (tsubXDebug > 1) printf ("tsubXPsSpeed: m1=%5.2f\n",m1);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubXPsRef[] = {
-    {"tsubXPs",      (REGISTRYFUNCTION)tsubXPs},
-    {"tsubXPsSync",  (REGISTRYFUNCTION)tsubXPsSync},
-    {"tsubXPsMtr",   (REGISTRYFUNCTION)tsubXPsMtr},
-    {"tsubXPsDrv",   (REGISTRYFUNCTION)tsubXPsDrv},
-    {"tsubXPsSpeed", (REGISTRYFUNCTION)tsubXPsSpeed}
-};
-
-static void tsubXPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubXPsRef,NELEMENTS(tsubXPsRef));
-}
-epicsExportRegistrar(tsubXPsFunc);
-
-
diff --git a/pmacApp/tsubSrc/tsubXY.c b/pmacApp/tsubSrc/tsubXY.c
deleted file mode 100644
index 6afb1f7..0000000
--- a/pmacApp/tsubSrc/tsubXY.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/* @(#) tsubXY.c 2.2 2004/05/31 -- speed propagation */
-
-/*  tsubXY.c - Transformation Subroutines for XY positioners   */
-/*             This is for 2-motors assemblies -- S. Stepanov  */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubXYDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubXYDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubXYPs - Assembly-XY Initialization
- */
-static long tsubXYPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYPsSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- */
-static long tsubXYPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYPsMtr - Assembly-XY Motors
- *	oa1 = d1
- *	ob1 = d2
- *	a = m1
- *	b = m2
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYPsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYPsDrv - Assembly-XY Drives
- *	oa0 = m1
- *	ob0 = m2
- *	a = d1
- *	b = d2
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYPsDrv (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-		pRec->ob0 = pRec->b / pRec->b1;                    /* m2=d2/scale2 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oa1 = d1
- *	ob1 = d2
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	a0 = m1
- *	b0 = m2
- *	a1 = d1
- *	b1 = d2
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12)
- */
-static long tsubXYPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, d1, d2;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubXYDebug > 1) printf ("tsubXYPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->b  == 0.0 ||
-             pRec->a3 == 0.0 || pRec->b3 == 0.0 ) {
-	   printf ("tsubXYPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubXYPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubXYPsSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-  	if (tsubXYDebug > 1) printf ("tsubXYPsSpeed: m1=%5.2f  m2=%5.2f\n",m1,m2);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubXYPsRef[] = {
-    {"tsubXYPs",      (REGISTRYFUNCTION)tsubXYPs},
-    {"tsubXYPsSync",  (REGISTRYFUNCTION)tsubXYPsSync},
-    {"tsubXYPsMtr",   (REGISTRYFUNCTION)tsubXYPsMtr},
-    {"tsubXYPsDrv",   (REGISTRYFUNCTION)tsubXYPsDrv},
-    {"tsubXYPsSpeed", (REGISTRYFUNCTION)tsubXYPsSpeed}
-};
-
-static void tsubXYPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubXYPsRef,NELEMENTS(tsubXYPsRef));
-}
-epicsExportRegistrar(tsubXYPsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubXYZ.c b/pmacApp/tsubSrc/tsubXYZ.c
deleted file mode 100644
index 4c9b237..0000000
--- a/pmacApp/tsubSrc/tsubXYZ.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/* @(#) tsubXYZ.c 2.2 2004/10/11 -- speed propagation */
-
-/*  tsubXYZ.c - Transformation Subroutines for XYZ positioners   */
-/*             This is for 3-motors assemblies -- S. Stepanov  */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubXYZDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubXYZDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubXYZPs - Assembly-XYZ Initialization
- */
-static long tsubXYZPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYZPsSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubXYZPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYZPsMtr - Assembly-XYZ Motors
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *	a = m1
- *	b = m2
- *	c = m3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYZPsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;         /* d3=m3*scale3+offset3 */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                    /* d3=m3*scale3 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYZPsDrv - Assembly-XYZ Drives
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	a = d1
- *	b = d2
- *	c = d3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYZPsDrv (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;       /* m3=(d3-offset3)/scale3 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-		pRec->ob0 = pRec->b / pRec->b1;                    /* m2=d2/scale2 */
-		pRec->oc0 = pRec->c / pRec->c1;                    /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYZPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12)
- */
-static long tsubXYZPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-	if (tsubXYZDebug > 1) printf ("tsubXYZPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ||
-             pRec->b  == 0.0 || pRec->b3 == 0.0 ||
-             pRec->c  == 0.0 || pRec->c3 == 0.0 ) {
-	   printf ("tsubXYZPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubXYZPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubXYZPsSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubXYZPsSpeed: max3=%5.2f sca3=%g\n",pRec->c,pRec->c3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* ------------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->c0 / pRec->c );         /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* ------------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                             /* m3=prcn*m3_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	d3 = fabs( 1000.0 *  m3 * pRec->c3 );            /* d3=m3*scale3 */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oc1 = d3;
-        if (tsubXYZDebug > 1) printf ("tsubXYZPsSpeed: m1=%5.2f  m2=%5.2f  m3=%5.2f\n",m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubXYZPsRef[] = {
-    {"tsubXYZPs",      (REGISTRYFUNCTION)tsubXYZPs},
-    {"tsubXYZPsSync",  (REGISTRYFUNCTION)tsubXYZPsSync},
-    {"tsubXYZPsMtr",   (REGISTRYFUNCTION)tsubXYZPsMtr},
-    {"tsubXYZPsDrv",   (REGISTRYFUNCTION)tsubXYZPsDrv},
-    {"tsubXYZPsSpeed", (REGISTRYFUNCTION)tsubXYZPsSpeed}
-};
-
-static void tsubXYZPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubXYZPsRef,NELEMENTS(tsubXYZPsRef));
-}
-epicsExportRegistrar(tsubXYZPsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubXYZ_frac.c b/pmacApp/tsubSrc/tsubXYZ_frac.c
deleted file mode 100644
index 4ff77d4..0000000
--- a/pmacApp/tsubSrc/tsubXYZ_frac.c
+++ /dev/null
@@ -1,251 +0,0 @@
-/* @(#) tsubXYZfra.c 2.2 2004/10/11 -- speed propagation (fractional count) */
-
-/*  tsubXYZfra.c - Transformation Subroutines for XYZ positioners   */
-/*                  This is for 3-motors assemblies -- S. Stepanov  */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubXYZfraDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubXYZfraDebug == (level)) ) { code } }
-
-/* ===========================================
- * tsubXYZfraPs - Assembly-XYZ Initialization
- */
-static long tsubXYZfraPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYZfraPsSync
- *	oa = m1:RqsPos
- *	ob = m2:RqsPos
- *	oc = m2:RqsPos
- *	a  = m1:ActPos
- *	b  = m2:ActPos
- *	c  = m3:ActPos
- */
-static long tsubXYZfraPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	pRec->ob = pRec->b;
-	pRec->oc = pRec->c;
-
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXYZfraPsMtr - Assembly-XYZ Motors
- *	oa1 = d1    oa2=m1_int   oa3=m1_fra
- *	ob1 = d2    ob2=m2_int   ob3=m2_fra
- *	oc1 = d3    oc2=m3_int   oc3=m3_fra
- *	a = m1
- *	b = m2
- *	c = m3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYZfraPsMtr (struct tsubRecord *pRec) {
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0;         /* d1=m1*scale1+offset1 */
-		pRec->ob1 = pRec->b * pRec->b1 + pRec->b0;         /* d2=m2*scale2+offset2 */
-		pRec->oc1 = pRec->c * pRec->c1 + pRec->c0;         /* d3=m3*scale3+offset3 */
-                pRec->oa2 = (long)(pRec->a);
-                pRec->ob2 = (long)(pRec->b);
-                pRec->oc2 = (long)(pRec->c);
-		pRec->oa3 = pRec->a - pRec->oa2;
-		pRec->ob3 = pRec->b - pRec->ob2;
-		pRec->oc3 = pRec->c - pRec->oc2;
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-		pRec->ob1 = pRec->b * pRec->b1;                    /* d2=m2*scale2 */
-		pRec->oc1 = pRec->c * pRec->c1;                    /* d3=m3*scale3 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYZfraPsDrv - Assembly-XYZ Drives
- *	oa0 = m1   oa2 = m1_int   oa3 = m1_fra
- *	ob0 = m2   ob2 = m2_int   ob3 = m2_fra
- *	oc0 = m3   oc2 = m3_int   oc3 = m2_fra
- *	a = d1
- *	b = d2
- *	c = d3
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	b0 = d2:Offset
- *	b1 = d2:Scale
- *	c0 = d3:Offset
- *	c1 = d3:Scale
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXYZfraPsDrv (struct tsubRecord *pRec) {
-	if ( (pRec->a1 == 0.0) ||
-	     (pRec->b1 == 0.0) ||
-	     (pRec->c1 == 0.0) )
-	{
-		return (-1);
-	}
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0) / pRec->a1;       /* m1=(d1-offset1)/scale1 */
-		pRec->ob0 = (pRec->b - pRec->b0) / pRec->b1;       /* m2=(d2-offset2)/scale2 */
-		pRec->oc0 = (pRec->c - pRec->c0) / pRec->c1;       /* m3=(d3-offset3)/scale3 */
-                pRec->oa2 = (long)(pRec->oa0);
-                pRec->ob2 = (long)(pRec->ob0);
-                pRec->oc2 = (long)(pRec->oc0);
-		pRec->oa3 = pRec->oa0 - pRec->oa2;
-		pRec->ob3 = pRec->ob0 - pRec->ob2;
-		pRec->oc3 = pRec->oc0 - pRec->oc2;
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    /* m1=d1/scale1 */
-		pRec->ob0 = pRec->b / pRec->b1;                    /* m2=d2/scale2 */
-		pRec->oc0 = pRec->c / pRec->c1;                    /* m3=d3/scale3 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXYZfraPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	ob0 = m2
- *	oc0 = m3
- *	oa1 = d1
- *	ob1 = d2
- *	oc1 = d3
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	b = m2_max
- *	c = m3_max
- *	a0 = m1
- *	b0 = m2
- *	c0 = m3
- *	a1 = d1
- *	b1 = d2
- *	c1 = d3
- *	a3 = d1:Scale
- *	b3 = d2:Scale
- *	c3 = d3:Scale
- *      nla = Index of input(m1=1, m2=2, d1=11, d2=12)
- */
-static long tsubXYZfraPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, m2, m3, d1, d2, d3;
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-	if (tsubXYZfraDebug > 1) printf ("tsubXYZfraPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ||
-             pRec->b  == 0.0 || pRec->b3 == 0.0 ||
-             pRec->c  == 0.0 || pRec->c3 == 0.0 ) {
-	   printf ("tsubXYZfraPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubXYZfraPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-	   printf ("tsubXYZfraPsSpeed: max2=%5.2f sca2=%g\n",pRec->b,pRec->b3);
-	   printf ("tsubXYZfraPsSpeed: max3=%5.2f sca3=%g\n",pRec->c,pRec->c3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla ==  2.0)  /* ------------------------- m2 speed changed */
-	{
-	   if ( pRec->b0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->b0 / pRec->b );         /* prcn=m2/m2_max */
-	}
-	else if (pRec->nla ==  3.0)  /* ------------------------- m3 speed changed */
-	{
-	   if ( pRec->c0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->c0 / pRec->c );         /* prcn=m3/m3_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else if (pRec->nla == 12.0) /* ------------------------- d2 speed changed */
-	{
-	   if ( pRec->b1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->b1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->b1 / (1000.0 * pRec->b * pRec->b3) );
-	}
-	else if (pRec->nla == 13.0) /* ------------------------- d3 speed changed */
-	{
-	   if ( pRec->c1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->c1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->c1 / (1000.0 * pRec->c * pRec->c3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	m2 = prcn * pRec->b;                             /* m2=prcn*m2_max */
-	m3 = prcn * pRec->c;                             /* m3=prcn*m3_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	d2 = fabs( 1000.0 *  m2 * pRec->b3 );            /* d2=m2*scale2 */
-	d3 = fabs( 1000.0 *  m3 * pRec->c3 );            /* d3=m3*scale3 */
-	pRec->oa0 = m1;
-	pRec->ob0 = m2;
-	pRec->oc0 = m3;
-	pRec->oa1 = d1;
-	pRec->ob1 = d2;
-	pRec->oc1 = d3;
-        if (tsubXYZfraDebug > 1) printf ("tsubXYZfraPsSpeed: m1=%5.2f  m2=%5.2f  m3=%5.2f\n",m1,m2,m3);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubXYZfraPsRef[] = {
-    {"tsubXYZfraPs",      (REGISTRYFUNCTION)tsubXYZfraPs},
-    {"tsubXYZfraPsSync",  (REGISTRYFUNCTION)tsubXYZfraPsSync},
-    {"tsubXYZfraPsMtr",   (REGISTRYFUNCTION)tsubXYZfraPsMtr},
-    {"tsubXYZfraPsDrv",   (REGISTRYFUNCTION)tsubXYZfraPsDrv},
-    {"tsubXYZfraPsSpeed", (REGISTRYFUNCTION)tsubXYZfraPsSpeed}
-};
-
-static void tsubXYZfraPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubXYZfraPsRef,NELEMENTS(tsubXYZfraPsRef));
-}
-epicsExportRegistrar(tsubXYZfraPsFunc);
-
diff --git a/pmacApp/tsubSrc/tsubX_bm_extern_offset.c b/pmacApp/tsubSrc/tsubX_bm_extern_offset.c
deleted file mode 100644
index d7209ee..0000000
--- a/pmacApp/tsubSrc/tsubX_bm_extern_offset.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/* @(#) tsubXbm.c 1.0 2006/05/20 -- speed propagation */
-
-/* tsubXbm.c - Transformation Subroutines for X-positioners          */
-/*           or one-axis rotation stages, i.e. any modular drives  */
-/*           This is for 1-motor assemblies -- Stepanov            */
-/* Chitra:   Modified tsubX.c 2.2 to include offset from upstream mirror    */
-
-#include	<stdlib.h>
-#include	<stdio.h>
-#include	<string.h>
-#include	<math.h>
-
-#include	<dbDefs.h>
-#include	<tsubRecord.h>
-#include	<dbCommon.h>
-#include	<recSup.h>
-#include	<epicsExport.h>		/* Sergey */
-#include	<registryFunction.h>	/* Sergey */
-
-volatile int tsubXbmDebug = 0;
-#define TSUB_MESSAGE	logMsg
-#define TSUB_TRACE(level,code) { if ( (pRec->tpro == (level)) || (tsubXbmDebug == (level)) ) { code } }
-
-/* Distances are measured in mm and mirror angles are in mrad */
-
-/* ===========================================
- * tsubXbmPs - Assembly-X Initialization
- */
-static long tsubXbmPs (struct tsubRecord *pRec) {
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXbmPsSync
- *	oa = m1:RqsPos
- *	a  = m1:ActPos
- */
-static long tsubXbmPsSync (struct tsubRecord *pRec) {
-	pRec->oa = pRec->a;
-	return (0);
-}
-
-
-/* ===========================================
- * tsubXbmPsMtr - Assembly-X Motors
- *	oa1 = d1
- *	a = m1
- *	oh  = S 	(vertical beam shift at sample due to mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	d  = Dms
- *	m  = angleVCM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXbmPsMtr (struct tsubRecord *pRec) {
-	double TwoAlpha=0.0;
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	pRec->oh = pRec->d * tan(TwoAlpha);                    		      /* S=Dms*tan(2*angleVCM) */
-        if (tsubXbmDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVCM)=%g\n",pRec->name,pRec->oh);
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa1 = pRec->a * pRec->a1 + pRec->a0 + pRec->oh;         /* d1=m1*scale1+offset1+S */
-	}
-	else
-	{
-		pRec->oa1 = pRec->a * pRec->a1;                    /* d1=m1*scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXbmPsDrv - Assembly-X Drives
- *	oa0 = m1
- *	a = d1
- *	oh  = S 	(vertical beam shift at sample due to mirror angle)
- *	a0 = d1:Offset
- *	a1 = d1:Scale
- *	d  = Dms
- *	m  = angleVCM
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *	nla = (1=wo/Offsets)[rel,vel] (0=w/Offsets)[abs,pos]
- */
-static long tsubXbmPsDrv (struct tsubRecord *pRec) {
-	double TwoAlpha=0.0;
-
-	if ( pRec->a1 == 0.0 )
-	{
-		return (-1);
-	}
-
-
-	if ( pRec->n != 0.0 ) TwoAlpha = 2.0*(pRec->m)/1000.0;                /* recalc. from mrad */
-        else                  TwoAlpha = 0.0;
-	pRec->oh = pRec->d * tan(TwoAlpha);                    		      /* S=Dms*tan(2*angleVCM) */
-        if (tsubXbmDebug > 2) printf("+++tsub=%s: S=Dms*tan(angleVCM)=%g\n",pRec->name,pRec->oh);
-
-	if (pRec->nla == 0.0)
-	{
-		pRec->oa0 = (pRec->a - pRec->a0 - pRec->oh) / pRec->a1;       /* m1=(d1-offset1-S)/scale1 */
-	}
-	else
-	{
-		pRec->oa0 = pRec->a / pRec->a1;                    	      /* m1=d1/scale1 */
-	}
-	return (0);
-}
-
-/* ===========================================
- * tsubXbmPsSpeed - Speed propagation spreadsheet
- *	oa0 = m1
- *	oa1 = d1
- *      oj  = sdis (sdis=1 -- disable record processing)
- *	a = m1_max
- *	a0 = m1
- *	a1 = d1
- *	a3 = d1:Scale
- *	n  = (0=don't use mirror angle) (1=use mirror angle)
- *      nla = Index of input(m1=1, d1=11)
- */
-static long tsubXbmPsSpeed (struct tsubRecord *pRec) {
-	double prcn = 0.0;
-	double m1, d1;
-
-	long ifail = 0;
-/* Disable next record processing in order to avoid infinite loop.
- * This actually points to a record linked to the SDIS field of the tsub.
- * The SDIS has to be re-enabled before next tsub record call */
-   	pRec->oj = 1;                                    /* sdis=1 */
-
-  	if (tsubXbmDebug > 1) printf ("tsubXbmPsSpeed: called with n=%f \n",pRec->nla);
-
-	if ( pRec->a  == 0.0 || pRec->a3 == 0.0 ) {
-	   printf ("tsubXbmPsSpeed: exit on zero calc parameters\n");
-	   printf ("tsubXbmPsSpeed: max1=%5.2f sca1=%g\n",pRec->a,pRec->a3);
-           return (-1);
-	}
-
-	if      (pRec->nla ==  1.0)  /* ------------------------- m1 speed changed */
-	{
-	   if ( pRec->a0 == 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-	   else prcn = fabs( pRec->a0 / pRec->a );         /* prcn=m1/m1_max */
-	}
-	else if (pRec->nla == 11.0) /* ------------------------- d1 speed changed */
-	{
-	   if ( pRec->a1  < 0.0 ) ifail = -1;              /* x,d speeds are always > 0 */
-	   if ( pRec->a1 <= 0.0 ) prcn = 1.0;              /* if 0, then set to max */
-/* m speed must have same sign as m_max */
-	   else prcn = fabs( pRec->a1 / (1000.0 * pRec->a * pRec->a3) );
-	}
-	else
-	{
-	   return (-1);
-	}
-
-	if ( prcn < 0.0 || prcn > 1.0 ) {
-/* If **anything** is wrong set speed to normal */
-          ifail = -1;
-	  prcn = 1.0;
-	}
-	m1 = prcn * pRec->a;                             /* m1=prcn*m1_max */
-	d1 = fabs( 1000.0 *  m1 * pRec->a3 );            /* d1=m1*scale1 */
-	pRec->oa0 = m1;
-	pRec->oa1 = d1;
-  	if (tsubXbmDebug > 1) printf ("tsubXbmPsSpeed: m1=%5.2f\n",m1);
-	return (ifail);
-}
-
-/* ===========================================
- *               Names registration
- *  =========================================== */
-static registryFunctionRef tsubXbmPsRef[] = {
-    {"tsubXbmPs",      (REGISTRYFUNCTION)tsubXbmPs},
-    {"tsubXbmPsSync",  (REGISTRYFUNCTION)tsubXbmPsSync},
-    {"tsubXbmPsMtr",   (REGISTRYFUNCTION)tsubXbmPsMtr},
-    {"tsubXbmPsDrv",   (REGISTRYFUNCTION)tsubXbmPsDrv},
-    {"tsubXbmPsSpeed", (REGISTRYFUNCTION)tsubXbmPsSpeed}
-};
-
-static void tsubXbmPsFunc(void) {				/* declare this via registrar in DBD */
-    registryFunctionRefAdd(tsubXbmPsRef,NELEMENTS(tsubXbmPsRef));
-}
-epicsExportRegistrar(tsubXbmPsFunc);
-
diff --git a/testApp/Db/Makefile b/testApp/Db/Makefile
deleted file mode 100644
index 48f73c9..0000000
--- a/testApp/Db/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-TOP=../..
-include $(TOP)/configure/CONFIG
-#DB += testIPServer.db
-include $(TOP)/configure/RULES
diff --git a/testApp/Makefile b/testApp/Makefile
deleted file mode 100644
index ab15bfb..0000000
--- a/testApp/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-TOP = ..
-include $(TOP)/configure/CONFIG
-DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *src*))
-DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *Src*))
-DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *db*))
-DIRS := $(DIRS) $(filter-out $(DIRS), $(wildcard *Db*))
-include $(TOP)/configure/RULES_DIRS
diff --git a/testApp/src/Makefile b/testApp/src/Makefile
deleted file mode 100644
index 63f67b6..0000000
--- a/testApp/src/Makefile
+++ /dev/null
@@ -1,52 +0,0 @@
-TOP=../..
-
-include $(TOP)/configure/CONFIG
-#----------------------------------------
-#  ADD MACRO DEFINITIONS AFTER THIS LINE
-
-
-SCRIPTS=testPmacAsynIP.boot
-
-
-PROD_IOC += testPmacAsynIP
-
-DBD += testPmacAsynIPPort.dbd
-DBD += testPmacAsynIPPortVx.dbd
-
-
-testPmacAsynIPPort_DBD += base.dbd
-testPmacAsynIPPort_DBD += asyn.dbd
-testPmacAsynIPPort_DBD += motorSupport.dbd
-testPmacAsynIPPort_DBD += drvAsynIPPort.dbd
-testPmacAsynIPPort_DBD += drvAsynSerialPort.dbd
-testPmacAsynIPPort_DBD += pmacAsynMotor.dbd
-testPmacAsynIPPort_DBD += pmacAsynIPPort.dbd
-testPmacAsynIPPort_DBD += testPmacAsynIP.dbd
-
-testPmacAsynIPPortVx_DBD += $(testPmacAsynIPPort_DBD) pmacInclude.dbd
-
-
-testPmacAsynIP_SRCS = testPmacAsynIPPort.c 
-testPmacAsynIP_SRCS_DEFAULT += testPmacAsynIPPort_registerRecordDeviceDriver.cpp testPmacAsynIPPortMain.cpp
-testPmacAsynIP_SRCS_vxWorks  += testPmacAsynIPPort_registerRecordDeviceDriver.cpp
-
-testPmacAsynIPPort_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary
-
-
-
-# This line says that this IOC Application depends on the
-# xxx Support Module
-testPmacAsynIP_LIBS_vxWorks += pmacIoc $(EPICS_BASE_IOC_LIBS)
-testPmacAsynIP_LIBS += pmacAsynMotor
-testPmacAsynIP_LIBS += pmacAsynIPPort
-testPmacAsynIP_LIBS += motor
-testPmacAsynIP_LIBS += asyn
-
-# We need to link this IOC Application against the EPICS Base libraries
-testPmacAsynIP_LIBS_DEFAULT += $(EPICS_BASE_IOC_LIBS)
-
-
-
-include $(TOP)/configure/RULES
-#----------------------------------------
-#  ADD RULES AFTER THIS LINE
diff --git a/testApp/src/testPmacAsynIP.dbd b/testApp/src/testPmacAsynIP.dbd
deleted file mode 100644
index eba10a9..0000000
--- a/testApp/src/testPmacAsynIP.dbd
+++ /dev/null
@@ -1,2 +0,0 @@
-#registrar(asynRegister)
-registrar(testPmacAsynIPPortRegister)
diff --git a/testApp/src/testPmacAsynIP.src b/testApp/src/testPmacAsynIP.src
deleted file mode 100644
index 340a575..0000000
--- a/testApp/src/testPmacAsynIP.src
+++ /dev/null
@@ -1,44 +0,0 @@
-#!$(INSTALL)/bin/$(ARCH)/testPmacAsynIP
-
-cd "$(INSTALL)"
-
-# Load binaries on architectures that need to do so.
-# VXWORKS_ONLY, LINUX_ONLY and RTEMS_ONLY are macros that resolve
-# to a comment symbol on architectures that are not the current
-# build architecture, so they can be used liberally to do architecture
-# specific things. Alternatively, you can include an architecture
-# specific file.
-$(VXWORKS_ONLY)ld < bin/$(ARCH)/testPmacAsynIP.munch
-
-## This drvTS initializer is needed if the IOC has a hardware event system
-#TSinit
-
-## Register all support components
-$(VXWORKS_ONLY)dbLoadDatabase("dbd/testPmacAsynIPPortVx.dbd")
-$(VXWORKS_ONLY)testPmacAsynIPPort_registerRecordDeviceDriver(pdbbase)
-
-$(LINUX_ONLY)dbLoadDatabase("dbd/testPmacAsynIPPort.dbd")
-$(LINUX_ONLY)testPmacAsynIPPort_registerRecordDeviceDriver(pdbbase)
-
-###########################################################
-# Configure asyn device
-#
-pmacVmeDebug = 0
-drvPmacDebug = 0
-
-
-#### IP pmac - start ####
-drvAsynIPPortConfigure("TEST","172.23.243.143:1025",0,0,0)
-#asynSetTraceMask -> 0=none,1=err,2=IO_device,4=IO_filter,8=IO_driver,0x10=flow
-#asynSetTraceMask("TEST",-1,0x1F)
-asynSetTraceMask("TEST",-1,0x13)
-asynSetTraceMask("TEST",-1,0x3)
-# asynSetTraceIOMask -> 0=none,1=ascii,2=esc,4=hex
-asynSetTraceIOMask("TEST",-1,0x2)
-pmacAsynIPPortConfigure("TEST",0)
-#### IP pmac - end ####
-
-testPmacAsynIPPort("TEST",0)
-
-
-iocInit()
diff --git a/testApp/src/testPmacAsynIPPort.c b/testApp/src/testPmacAsynIPPort.c
deleted file mode 100644
index e1e52af..0000000
--- a/testApp/src/testPmacAsynIPPort.c
+++ /dev/null
@@ -1,272 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include <cantProceed.h>
-#include <epicsMutex.h>
-#include <epicsEvent.h>
-#include <epicsStdio.h>
-#include <epicsString.h>
-#include <epicsThread.h>
-#include <epicsAssert.h>
-#include <asynDriver.h>
-#include <asynOctet.h>
-#include <asynOctetSyncIO.h>
-#include <drvAsynIPPort.h>
-#include <iocsh.h>
-#include <registryFunction.h>
-#include <epicsExport.h>
-#include "testPmacAsynIPPort.h"
-
-#define BUFFER_SIZE 80
-/*#define READ_TIMEOUT -1.0  - this would wait forever */
-#define READ_TIMEOUT 5.0
-#define WRITE_TIMEOUT 2.0
-
-#define MAX_CMD 20
-
-typedef struct myData {
-    epicsMutexId mutexId;
-    char         *portName;
-    double       readTimeout;
-    asynOctet    *pasynOctet;
-    void         *octetPvt;
-    void         *registrarPvt;
-    char         *cmd[MAX_CMD];
-}myData;
-
-
-/*** pmac commands for axis 1 ***/
-/* Initiate an absolute move to position (zz) with velocity (vv) and acceleration (aa): Ixx22=vv Ixx20=aa #xx J=zz */
-char* cmdMoveA="I122=1 I120=0.5 #1 J=10";
-/* Initiate a relative move of distance (zz) with velocity (vv) and acceleration (aa): Ixx22=vv Ixx20=aa #xx J^zz */
-char* cmdMoveR="I122=1 I120=0.5 #1 J^10";
-/* Initiate a forwards velocity move with velocity (vv) and acceleration (aa): Ixx22=vv Ixx20=aa #xx J+ */
-char* cmdJF="I122=1 I120=0.5 #1 J+";
-/* Initiate a reverse velocity move with velocity (vv) and acceleration (aa): Ixx22=vv Ixx20=aa #xx J- */
-char* cmdJR="I122=1 I120=0.5 #1 J-";
-/* re-enable limits if limits: Ixx24=Ixx24&$FDFFFF */ 
-char* cmdEnLim="I124=I124&$FDFFFF";
-/* Homing with velocity (vv) and acceleration (aa): Ixx23=vv Ixx20=aa #xx HOME */
-char* cmdHome="I123=1 I120=0.5 #1 HOME";
-/* Homing with velocity (vv) and acceleration (aa) and temporarily disabling limits: Ixx23=vv Ixx20=aa #xx HOME Ixx24=Ixx24|$20000 */
-char* cmdHomeNL="I123=1 I120=0.5 #1 HOME I124=I124|$20000";
-/* Stopping any motion command: #xx J/ */
-char* cmdStop="#1 J/";
-/* Determining homing and limits status - yy is the macro node (i.e. (xx-1)*2-mod((xx-1),2)): MSyy,I912 MSyy,I913 Ixx24 Ixx23 Ixx26 */
-char* cmdHLStatus="MS0,I912 MS0,I913 I124 I123 I126";
-/* Polling status: #xx ? P F V */
-char* cmdPollStatus="#1 ? P F V";
-/* Determining the initial status: Ixx13 Ixx14 Ixx30 Ixx31 Ixx33 */
-char* cmdPosStatus="I113 I114 I130 I131 I133";
-/* Enable axis: Ix00=1 */
-char* cmdEnable="I100=1";
-/* Disable axis: Ix00=0 */
-char* cmdDisable="I100=0";
-/* Definining the current position to be a new fixed value (zz=value *32+0.5): #xx K Mxx61=zz*Ixx08 Mxx62=zz*Ixx08 J/ */
-char* cmdDefPos="#1 K M161=640.5*I108 M162=640.5*I108 J/";
-/* Set axis low limit to value (zz): Ixx14=zz */
-char* cmdSetLoLim="I114=-1000";
-/* Set axis high limit to value (zz): Ixx13=zz */
-char* cmdSetHiLim="I113=1000";
-/* Set axis proportional gain to value (zz): Ixx30=zz */
-char* cmdSetPGain="I130=2000";
-/* Set axis differential gain to value (zz): Ixx31=zz */
-char* cmdSetDGain="I131=0";
-/* Set axis integral gain to value (zz): Ixx33=zz */
-char* cmdSetIGain="I133=0";
-/* Report status words for all motors */
-char* cmdCTRLB="\2";
-/* Report all coordinate system status words */
-char* cmdCTRLC="\3";
-/* Report following errors for all motors */
-char* cmdCTRLF="\6";
-/* Report global status word */
-char* cmdCTRLG="\7";
-/* Report position of all motors */
-char* cmdCTRLP="\16";
-/* Report velocity of all motors */
-char* cmdCTRLV="\22";
-/* Get comms setup */
-char* cmdCommsStatus="I3 I6";
-
-asynStatus sendCmd(asynUser *pasynUser, myData *pPvt, char* cmd )
-{
-    char buffer[BUFFER_SIZE];
-    int nread, nwrite, eomReason;
-    asynStatus status;
-
-        buffer[0] = 0;
-
-        status = pasynOctetSyncIO->writeRead( pasynUser,
-                                          cmd, strlen(cmd),
-                                          buffer, BUFFER_SIZE,
-                                          pPvt->readTimeout,
-                                          &nwrite, &nread, &eomReason );
-        switch (status) {
-        case asynTimeout:
-            asynPrint(pasynUser, ASYN_TRACE_ERROR,
-                      "testPmacAsynIPPort: TIMEOUT\n");
-            /* no break - fall throught to asynSuccess */
-            
-        case asynSuccess:
-             asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,cmd,strlen(cmd),
-                 "testPmacAsynIPPort: %s write %d:\n",pPvt->portName,strlen(cmd));
-             asynPrintIO(pasynUser,ASYN_TRACEIO_DEVICE,buffer,nread,
-                 "testPmacAsynIPPort: %s read %d:\n",pPvt->portName,nread);
-            break;
-
-        default:
-            asynPrint(pasynUser, ASYN_TRACE_ERROR,
-                      "testPmacAsynIPPort: writeRead error on: %s: write %d: %s, status=%d error=%s\n", 
-                      pPvt->portName, strlen(cmd), cmd, status, pasynUser->errorMessage);
-            break;
-        }
-        return status;
-}
-
-void testHandler(myData *pPvt)
-{
-    asynUser *pasynUser;
-    asynStatus status;
-    int i;
-
-    status = pasynOctetSyncIO->connect(pPvt->portName, 0, &pasynUser, NULL);
-    if (status) {
-        asynPrint(pasynUser, ASYN_TRACE_ERROR,
-                  "echoHandler: unable to connect to port %s\n", 
-                  pPvt->portName);
-        return;
-    }
-
-    asynPrint(pasynUser, ASYN_TRACE_FLOW, 
-              "testPmacAsynIPPort: testHandler, portName=%s\n", pPvt->portName);
-    
-/***  EOS setup is not required - its already done by pmacAsynIPPort interpose interface
-    status = pasynOctetSyncIO->setInputEos(pasynUser, "\6", 1);
-    if (status) {
-        asynPrint(pasynUser, ASYN_TRACE_ERROR,
-                  "testPmacAsynIPPort: unable to set input EOS on %s: %s\n", 
-                  pPvt->portName, pasynUser->errorMessage);
-        return;
-    }
-    status = pasynOctetSyncIO->setOutputEos(pasynUser, "\r", 1);
-    if (status) {
-        asynPrint(pasynUser, ASYN_TRACE_ERROR,
-                  "testPmacAsynIPPort: unable to set output EOS on %s: %s\n", 
-                  pPvt->portName, pasynUser->errorMessage);
-        return;
-    }
-***/
-
-    printf("*****************************************************************\n");
-    printf("********** Ensure I3=2 and I6=1 on PMAC before testing **********\n");
-    printf("*****************************************************************\n");
-
-    /*** send the test commands ***/
-    status = asynSuccess;
-    pPvt->cmd[0]=cmdCommsStatus;
-    pPvt->cmd[1]=cmdPollStatus; 
-    pPvt->cmd[2]=cmdPosStatus;
-    pPvt->cmd[3]=cmdEnable;
-    pPvt->cmd[4]=cmdEnLim;
-    pPvt->cmd[5]=cmdMoveA;
-    pPvt->cmd[6]=cmdStop;
-    pPvt->cmd[7]=cmdMoveR;
-    pPvt->cmd[8]=cmdStop;
-    pPvt->cmd[9]=cmdJF;
-    pPvt->cmd[10]=cmdStop;
-    pPvt->cmd[11]=cmdHomeNL;
-    pPvt->cmd[12]=cmdStop;
-    pPvt->cmd[13]=cmdSetLoLim;
-    pPvt->cmd[14]=cmdSetHiLim;
-    pPvt->cmd[15]=cmdHLStatus;
-/*    pPvt->cmd[??]=cmdCTRLP;*/
-    pPvt->cmd[16]=NULL; /* end of command list */
-
-    for(i=0; i<MAX_CMD && pPvt->cmd[i] && status==asynSuccess; i++) {
-        status = sendCmd(pasynUser, pPvt, pPvt->cmd[i] );
-    }
-    
-    if (status==asynSuccess)
-        printf("**********TEST PASSED ********\n");
-    else    
-        printf("**********TEST FAILED ********\n");
-    return;
-}
-
-                         
-static void connectionCallback(void *drvPvt, asynUser *pasynUser, char *portName, size_t len, int eomReason)
-{
-/*    myData     *pPvt = (myData *)drvPvt;
-    myData     *newPvt = calloc(1, sizeof(myData));
-*/
-    asynPrint(pasynUser, ASYN_TRACE_FLOW, 
-              "testPmacAsynIPPort: connectionCallback, portName=%s\n", portName);
-
-}
-
-epicsShareFunc int testPmacAsynIPPort(const char *portName, int readTimeout)
-{
-    myData        *pPvt;
-    asynUser      *pasynUser;
-    asynStatus    status;
-    int           addr=0;
-    asynInterface *pasynInterface;
-
-    pPvt = (myData *)callocMustSucceed(1, sizeof(myData), "testPmacAsynIPPort");
-    pPvt->mutexId = epicsMutexCreate();
-    pPvt->portName = epicsStrDup(portName);
-    pasynUser = pasynManager->createAsynUser(0,0);
-    pasynUser->userPvt = pPvt;
-    status = pasynManager->connectDevice(pasynUser,portName,addr);
-    if(status!=asynSuccess) {
-        printf("testPmacAsynIPPort: can't connect to port %s: %s\n", portName, pasynUser->errorMessage);
-        return -1;
-    }
-    pasynInterface = pasynManager->findInterface(
-       pasynUser,asynOctetType,1);
-    if(!pasynInterface) {
-        printf("testPmacAsynIPPort: %s driver not supported\n",asynOctetType);
-        return -1;
-    }
-    if (readTimeout == 0) 
-        pPvt->readTimeout = READ_TIMEOUT;
-    else 
-        pPvt->readTimeout = (double)readTimeout;
-    pPvt->pasynOctet = (asynOctet *)pasynInterface->pinterface;
-    pPvt->octetPvt = pasynInterface->drvPvt;
-    status = pPvt->pasynOctet->registerInterruptUser(
-                 pPvt->octetPvt, pasynUser,
-                 connectionCallback,pPvt,&pPvt->registrarPvt);
-    if(status!=asynSuccess) {
-        printf("testPmacAsynIPPort: devAsynOctet registerInterruptUser %s\n",
-               pasynUser->errorMessage);
-        return -1;       
-    }
-
-    asynPrint(pasynUser,ASYN_TRACE_FLOW, "Done testPmacAsynIPPort OK\n");
-    
-    testHandler(pPvt);
-    return 0;
-}
-
-static const iocshArg testPmacAsynIPPortArg0 = {"port", iocshArgString};
-static const iocshArg testPmacAsynIPPortArg1 = {"read timeout", iocshArgInt};
-static const iocshArg *const testPmacAsynIPPortArgs[] = {
-    &testPmacAsynIPPortArg0,
-    &testPmacAsynIPPortArg1};
-static const iocshFuncDef testPmacAsynIPPortDef = {"testPmacAsynIPPort", 2, testPmacAsynIPPortArgs};
-static void testPmacAsynIPPortCall(const iocshArgBuf * args) 
-{ 
-    testPmacAsynIPPort(args[0].sval, args[1].ival);
-}
-
-static void testPmacAsynIPPortRegister(void)
-{
-    static int firstTime = 1;
-    if(!firstTime) return;
-    firstTime = 0;
-    iocshRegister(&testPmacAsynIPPortDef,testPmacAsynIPPortCall);
-}
-epicsExportRegistrar(testPmacAsynIPPortRegister);
diff --git a/testApp/src/testPmacAsynIPPort.h b/testApp/src/testPmacAsynIPPort.h
deleted file mode 100644
index d7566ec..0000000
--- a/testApp/src/testPmacAsynIPPort.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef testPmacAsynIPPort_H
-#define testPmacAsynIPPort_H
-
-#include <shareLib.h>
-#include <epicsExport.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif  /* __cplusplus */
-
-epicsShareFunc int testPmacAsynIPPort(const char *portName,int addr);
-
-#ifdef __cplusplus
-}
-#endif  /* __cplusplus */
-
-#endif /* testPmacAsynIPPort_H */
diff --git a/testApp/src/testPmacAsynIPPortMain.cpp b/testApp/src/testPmacAsynIPPortMain.cpp
deleted file mode 100644
index a7845b8..0000000
--- a/testApp/src/testPmacAsynIPPortMain.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-/* exampleMain.c */
-/* Author:  Marty Kraimer Date:    17MAR2000 */
-
-/***********************************************************************
-* Copyright (c) 2002 The University of Chicago, as Operator of Argonne
-* National Laboratory, and the Regents of the University of
-* California, as Operator of Los Alamos National Laboratory, and
-* Berliner Elektronenspeicherring-Gesellschaft m.b.H. (BESSY).
-* gpibCore is distributed subject to a Software License Agreement
-* found in file LICENSE that is included with this distribution.
-***********************************************************************/
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "epicsThread.h"
-#include "iocsh.h"
-
-int main(int argc,char *argv[])
-{
-    if(argc>=2) {    
-        iocsh(argv[1]);
-        epicsThreadSleep(.2);
-    }
-    iocsh(NULL);
-    return(0);
-}
-- 
1.7.10.4

